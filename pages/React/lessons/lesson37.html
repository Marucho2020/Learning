<html><head><title>Lesson 37 == useMemo ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../react-learning-list.html'>ðŸ”™ Quay láº¡i danh sÃ¡ch</a><br><h1>Lesson 37 -- useMemo -//</h1><pre>
# Giá»›i Thiá»‡u Vá» Hook useMemo Trong React (Má»©c Äá»™ Senior) 
	useMemo lÃ  má»™t hook quan trá»ng trong React, Ä‘Æ°á»£c giá»›i thiá»‡u tá»« phiÃªn báº£n 16.8, dÃ¹ng Ä‘á»ƒ memoize (lÆ°u cache) cÃ¡c giÃ¡ trá»‹ tÃ­nh toÃ¡n, giÃºp trÃ¡nh viá»‡c recalculate khÃ´ng cáº§n thiáº¿t trong má»—i render. Äiá»u nÃ y cáº£i thiá»‡n performance báº±ng cÃ¡ch giáº£m computations náº·ng ná», Ä‘áº·c biá»‡t trong cÃ¡c component vá»›i dá»¯ liá»‡u phá»©c táº¡p hoáº·c child components memoized. á»ž má»©c Ä‘á»™ senior, chÃºng ta cáº§n hiá»ƒu sÃ¢u vá» memoization mechanism dá»±a trÃªn dependencies, cÃ¡ch hook tÃ­ch há»£p vá»›i reconciliation process cá»§a React, xá»­ lÃ½ stale values trong closures, vÃ  tá»‘i Æ°u hÃ³a trong scenarios nhÆ° large datasets, virtualization, hoáº·c SSR (Server-Side Rendering). Memoization á»Ÿ Ä‘Ã¢y dá»±a trÃªn shallow compare cá»§a dependency array, giÃºp stable references cho values nhÆ° objects/arrays, trÃ¡nh unnecessary re-renders.	
	
	
# 	1. CÆ¡ Cháº¿ Hoáº¡t Äá»™ng Ná»™i Bá»™ Cá»§a useMemo
	Äá»‹nh nghÄ©a cÆ¡ báº£n: useMemo(computeFunction, dependencies) nháº­n má»™t function compute (tráº£ vá» value cáº§n memoize) vÃ  máº£ng dependencies, tráº£ vá» value memoized. Compute chá»‰ cháº¡y khi deps thay Ä‘á»•i (shallow compare: === cho primitives, reference cho objects). Náº¿u deps lÃ  [], compute cháº¡y chá»‰ láº§n Ä‘áº§u (mount).	
	
	Memoization vÃ  Performance: React lÆ°u cache value trong fiber node, so sÃ¡nh deps trong render phase. Náº¿u deps khÃ´ng Ä‘á»•i, return cached value, trÃ¡nh re-compute. Äiá»u nÃ y giáº£m CPU usage cho heavy ops nhÆ° sorting large arrays, filtering, hoáº·c complex calculations.	
	
	
	## 	So sÃ¡nh vá»›i useCallback:
	useMemo: Memoize báº¥t ká»³ value (sá»‘, object, array, etc.), dÃ¹ng cho computations tráº£ vá» data.
	
	useCallback: Memoize function (callback), tÆ°Æ¡ng Ä‘Æ°Æ¡ng useMemo(() => fn, deps). DÃ¹ng khi cáº§n stable function reference (props, deps).
	
	KhÃ¡c biá»‡t: useMemo cháº¡y compute vÃ  cache result; useCallback cache function mÃ  khÃ´ng cháº¡y nÃ³ ngay. Cáº£ hai Ä‘á»u giÃºp stable props Ä‘á»ƒ trÃ¡nh re-render child vá»›i React.memo.
	

	## 	Lifecycle:
		Compute cháº¡y sync trong render (trÆ°á»›c DOM paint), nÃªn trÃ¡nh blocking ops (dÃ¹ng Web Workers náº¿u cáº§n). Cache persist qua renders, reset khi deps Ä‘á»•i hoáº·c unmount.

	## Pitfalls chuyÃªn sÃ¢u: 
	
		- Missing deps: QuÃªn dep gÃ¢y stale values (compute capture old closures).
		- Over-memoization: Memoize simple values gÃ¢y overhead (allocation cost > lá»£i Ã­ch).
		- Mutable returns: Náº¿u return mutable object vÃ  mutate nÃ³, gÃ¢y bugs (luÃ´n return immutable).
		- Infinite loops: Náº¿u dep bao gá»“m value tá»« compute, gÃ¢y loop.
		- SSR considerations: Compute cháº¡y trÃªn server, Ä‘áº£m báº£o deterministic (khÃ´ng random).	
	
# 	VÃ­ dá»¥ cÆ¡ báº£n
	Sá»­a váº¥n Ä‘á» performance vá»›i expensive calculation.
	
// KhÃ´ng useMemo - váº¥n Ä‘á»
import { useState } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState([]);

  const calculation = expensiveCalculation(count); // Cháº¡y má»—i render, gÃ¢y lag khi addTodo

  const increment = () => setCount(c => c + 1);
  const addTodo = () => setTodos(t => [...t, 'New Todo']);

  return (
    <div>
      <h2>My Todos</h2>
      {todos.map((todo, index) => <p key={index}>{todo}</p>)}
      <button onClick={addTodo}>Add Todo</button>
      <hr />
      Count: {count} <button onClick={increment}>+</button>
      <h2>Expensive Calculation: {calculation}</h2>
    </div>
  );
}

const expensiveCalculation = (num) => {
  console.log('Calculating...'); // Log má»—i render
  let result = num;
  for (let i = 0; i < 1000000000; i++) {
    result += 1;
  }
  return result;
};	
	
	Giáº£i thÃ­ch: Khi addTodo, component re-render, expensiveCalculation cháº¡y láº¡i dÃ¹ khÃ´ng liÃªn quan Ä‘áº¿n todos, gÃ¢y delay.
	
	## Giáº£i phÃ¡p vá»›i useMemo:
	
import { useState, useMemo } from 'react';

function App() {
  const [count, setCount] = useState(0);
  const [todos, setTodos] = useState([]);

  const calculation = useMemo(() => {
    try {
      return expensiveCalculation(count);
    } catch (error) {
      console.error('Calculation error:', error);
      return 0; // Fallback
    }
  }, [count]); // Chá»‰ re-compute khi count Ä‘á»•i

  const increment = () => setCount(c => c + 1);
  const addTodo = () => setTodos(t => [...t, 'New Todo']);

  return (
    <div>
      <h2>My Todos</h2>
      {todos.map((todo, index) => <p key={index}>{todo}</p>)}
      <button onClick={addTodo}>Add Todo</button>
      <hr />
      Count: {count} <button onClick={increment}>+</button>
      <h2>Expensive Calculation: {calculation}</h2>
    </div>
  );
}

const expensiveCalculation = (num) => {
  console.log('Calculating...');
  let result = num;
  for (let i = 0; i < 1000000000; i++) {
    result += 1;
  }
  return result;
};	
	
	Giáº£i thÃ­ch: useMemo cache result, chá»‰ cháº¡y khi count Ä‘á»•i. AddTodo khÃ´ng trigger re-compute, cáº£i thiá»‡n speed.	
	
	
	
# 	2. Use Case NÃ¢ng Cao: Memoize Objects/Arrays Äá»ƒ Stable Props

	DÃ¹ng Ä‘á»ƒ stable complex data, trÃ¡nh re-render child.
	VÃ­ dá»¥: Filtered List Vá»›i Large Data:

import { useState, useMemo, memo } from 'react';

const Item = memo(({ item }) => {
  console.log(`Render ${item.name}`); // Heavy render giáº£ láº­p
  return <li>{item.name} - {item.price}</li>;
});

function ProductList() {
  const [filter, setFilter] = useState('');
  const products = useMemo(() => Array.from({ length: 1000 }, (_, i) => ({ id: i, name: `Product ${i}`, price: i * 10 })), []); // Memoize large array

  const filteredProducts = useMemo(() => {
    return products.filter(product => product.name.toLowerCase().includes(filter.toLowerCase()));
  }, [products, filter]); // Re-compute chá»‰ khi filter/products Ä‘á»•i

  return (
    <>
      <input value={filter} onChange={e => setFilter(e.target.value)} placeholder="Lá»c sáº£n pháº©m..." />
      <ul>
        {filteredProducts.map(product => <Item key={product.id} item={product} />)}
      </ul>
    </>
  );
}


# 3. Use Case NÃ¢ng Cao: TÃ­ch Há»£p Vá»›i useEffect VÃ  API Data

	DÃ¹ng Ä‘á»ƒ derive state tá»« fetched data, trÃ¡nh re-compute trong effect
	VÃ­ dá»¥: Process API Data Vá»›i Memoization:
	
	
	import { useState, useEffect, useMemo } from 'react';

function DataProcessor() {
  const [data, setData] = useState([]);
  const [sortBy, setSortBy] = useState('name');

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users')
      .then(res => res.json())
      .then(setData);
  }, []);

  const sortedData = useMemo(() => {
    console.log('Sorting data...');
    return [...data].sort((a, b) => a[sortBy].localeCompare(b[sortBy]));
  }, [data, sortBy]); // Re-sort chá»‰ khi data/sortBy Ä‘á»•i

  return (
    <>
      <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
        <option value="name">Name</option>
        <option value="email">Email</option>
      </select>
      <ul>
        {sortedData.map(user => <li key={user.id}>{user.name} - {user.email}</li>)}
      </ul>
    </>
  );
}



# 4. Use Case NÃ¢ng Cao: Custom Hooks Vá»›i useMemo

	Encapsulate memo logic reusable.

import { useMemo } from 'react';

function useFilteredData(data, filter) {
  return useMemo(() => {
    if (!data) return [];
    return data.filter(item => item.toLowerCase().includes(filter.toLowerCase()));
  }, [data, filter]); // Memoize filter
}

function SearchComponent() {
  const [filter, setFilter] = useState('');
  const items = ['Apple', 'Banana', 'Cherry', 'Date'];
  const filtered = useFilteredData(items, filter);

  return (
    <>
      <input value={filter} onChange={e => setFilter(e.target.value)} />
      <ul>{filtered.map((item, idx) => <li key={idx}>{item}</li>)}</ul>
    </>
  );
}




# 5. Use Case NÃ¢ng Cao: Memoize Trong Context Äá»ƒ Giáº£m Re-Renders
	DÃ¹ng cho value trong Provider, stable context.
	VÃ­ dá»¥: Theme Context Vá»›i Computed Styles:

import { createContext, useContext, useState, useMemo } from 'react';

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const themeStyles = useMemo(() => ({
    background: theme === 'light' ? 'white' : 'black',
    color: theme === 'light' ? 'black' : 'white',
    // Expensive computations here, e.g., generate CSS vars
  }), [theme]); // Memoize object

  return (
    <ThemeContext.Provider value={{ theme, setTheme, styles: themeStyles }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemedComponent() {
  const { styles } = useContext(ThemeContext);
  return <div style={styles}>Themed Content</div>;
}

// App.js
function App() {
  return (
    <ThemeProvider>
      <ThemedComponent />
    </ThemeProvider>
  );
}



https://www.w3schools.com/react/react_customhooks.asp
</pre><a id='backBottom' href='../react-learning-list.html' style='display:none;'>ðŸ”™ Quay láº¡i danh sÃ¡ch</a><br><button onclick='toggleTheme()'>ðŸŒ™ Chuyá»ƒn giao diá»‡n</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>