<html><head><title>Lesson 94 == Binary Search Tree (BST) ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 94 -- Binary Search Tree (BST) -//</h1><pre>
# Kh√°i ni·ªám 
	BST l√† m·ªôt c√¢y nh·ªã ph√¢n c√≥ t√≠nh ch·∫•t : 
		- M·ªói node c√≥ t·ªëi ƒëa 2 con 
		- V·ªõi m·ªói node N : 
			- T·∫•t c·∫£ c√°c gi√° tr·ªã b√™n tr√°i < N 
			- T·∫•t c·∫£ c√°c gi√° tr·ªã b√™n ph·∫£i > N 
	
	
						  8
						/   \
						3     10
					  / \       \
					  1   6     14

	
	BST l√† c∆° s·ªü cho nhi·ªÅu c·∫•u tr√∫c d·ªØ li·ªáu h·ªá th·ªëng nh∆∞ :
		- TreeMap, TreeSet (Java) 
		- Database Index (B-Tree l√† bi·∫øn th·ªÉ) 
		- Memory Allocators (buddy allocator)
		- Autocomplete Engines, Prefix Searching 
		
		
		
# C√°c thao t√°c c∆° b·∫£n  
		
		
Thao t√°c  		| M·ª•c ƒë√≠ch 			          | ƒê·ªô ph·ª©c t·∫°p (avg)   | ƒê·ªô ph·ª©c t·∫°p (worst)
insert()  		| Ch√®n node m·ªõi 	          | O(log n) 			| O(n) n·∫øu c√¢y b·ªã l·ªách
search()  		| T√¨m gi√° tr·ªã 		          | O(log n) 			| O(n)
delete()  		| Xo√° node			          | O(log n) 			| O(n)
inOrder() 		| Duy·ªát theo th·ª© t·ª± tƒÉng d·∫ßn  | O(n)	 			| O(n)	
	
	
	
# 	üß† III. T∆∞ duy h·ªá th·ªëng (v∆∞·ª£t kh·ªèi l√Ω thuy·∫øt) 

	## ‚ùó V·∫•n ƒë·ªÅ l·ªõn nh·∫•t: C√¢y m·∫•t c√¢n b·∫±ng 
	BST g·ªëc c√≥ th·ªÉ tho√°i ho√° th√†nh Linked List n·∫øu d·ªØ li·ªáu kh√¥ng ph√¢n b·ªë ƒë·ªÅu: 
	
    1
     \
      2
       \
        3
         \
          4
	
	
	Khi ƒë√≥ 
		search() t·ª´ O(log n) ‚Üí O(n) 
		T·ªá h∆°n c·∫£ ArrayList 
		
	üí° Gi·∫£i ph√°p: D√πng Balanced BST nh∆∞: 
		
	
		AVL Tree
		Red-Black Tree (Java TreeMap, TreeSet d√πng c√°i n√†y)
		Splay Tree (cho c√°c truy c·∫≠p th∆∞·ªùng xuy√™n)
		Treap / Scapegoat Tree n·∫øu y√™u c·∫ßu kh√°c bi·ªát	
	
	
# IV. Tri·ªÉn khai th·ª±c t·∫ø trong Java 
	## Custom BST 
	class Node {
		int value;
		Node left, right;
	
		Node(int value) { this.value = value; }
	}

	public Node insert(Node root, int val) {
		if (root == null) return new Node(val);
		if (val < root.value) root.left = insert(root.left, val);
		else if (val > root.value) root.right = insert(root.right, val);
		return root;
	}
	


	## 2. TreeSet / TreeMap trong Java 
		TreeMap<Integer, String> map = new TreeMap<>();
		map.put(5, "five");
		map.put(1, "one");
		map.put(10, "ten");
		
		System.out.println(map.firstKey());  // 1
		System.out.println(map.lastKey());   // 10
	D∆∞·ªõi hood, TreeMap l√† Red-Black Tree, m·ªôt lo·∫°i BST t·ª± c√¢n b·∫±ng.



# üß∞ V. BST d√πng l√†m g√¨ trong h·ªá th·ªëng l·ªõn? 

Use-case 										| BST l√†m g√¨ ·ªü ƒë√¢y?
Database Index (MySQL, PostgreSQL) 				| D√πng bi·∫øn th·ªÉ B-Tree ƒë·ªÉ t√¨m d·ªØ li·ªáu nhanh
Memory Allocator				   				| C·∫•p ph√°t memory block theo size ‚Äì c·∫ßn t√¨m block nh·ªè nh·∫•t >= X
Compiler 						   				| D√πng ƒë·ªÉ x√¢y Abstract Syntax Tree
Autocomplete / Search Engine	   				| C√¢y prefix (Ternary BST) ƒë·ªÉ l∆∞u t·ª´ ƒëi·ªÉn
Time Series Engine				   				| BST l∆∞u c√°c m·ªëc th·ªùi gian, d·ªÖ t√¨m range	



# üìè VI. Khi n√†o KH√îNG d√πng BST? 
	
T√¨nh hu·ªëng												 | T·∫°i sao
Truy c·∫≠p key tr·ª±c ti·∫øp th∆∞·ªùng xuy√™n 				    | D√πng HashMap t·ªët h∆°n (O(1))
D·ªØ li·ªáu kh√¥ng th·ªÉ so s√°nh (kh√¥ng c√≥ th·ª© t·ª± r√µ r√†ng)     | BST y√™u c·∫ßu d·ªØ li·ªáu so s√°nh ƒë∆∞·ª£c
D·ªØ li·ªáu thay ƒë·ªïi li√™n t·ª•c, d·ªÖ g√¢y m·∫•t c√¢n b·∫±ng		    | Ph·∫£i d√πng AVL/Red-Black Tree



# ‚öñÔ∏è VII. So s√°nh BST vs c√°c c·∫•u tr√∫c kh√°c 

C·∫•u tr√∫c	  | Truy c·∫≠p 		| S·∫Øp x·∫øp 	| T√¨m g·∫ßn ƒë√∫ng 					| Ghi nh·ªõ th·ª© t·ª±
HashMap 	  | ‚úÖ O(1) 	   | ‚ùå  			| ‚ùå 							| ‚ùå
TreeMap (BST) | ‚ö†Ô∏è O(log n)    | ‚úÖ			| ‚úÖ (ceilingKey, floorKey)     | ‚úÖ
ArrayList     | ‚úÖ O(1) 	   | ‚ùå 			| ‚ùå 							| ‚úÖ
LinkedList    | ‚ùå 			   | ‚ùå 			| ‚ùå 							| ‚úÖ


# üìö VIII. C√°c ch·ªß ƒë·ªÅ li√™n quan c·∫ßn h·ªçc ƒë·ªÉ master BST 

Ch·ªß ƒë·ªÅ 					| Gi·∫£i th√≠ch
AVL Tree			 | BST t·ª± c√¢n b·∫±ng, m·ªói node gi·ªØ balance factor
Red-Black Tree		 | C√¢n b·∫±ng m√†u s·∫Øc, b·∫£o ƒë·∫£m O(log n)
B-Tree / B+ Tree 	 | D√πng trong database / h·ªá th·ªëng file
Treap / Splay Tree   | BST d√πng cho cache ho·∫∑c d·ªØ li·ªáu thi√™n l·ªách
Augmented BST        | BST v·ªõi extra data (ex: count, size, sum)


# üß® N·∫øu scale l√™n h√†ng tri·ªáu node? 

	- Kh√¥ng d√πng pointer tree ƒë∆°n thu·∫ßn.
	- D√πng external memory tree (nh∆∞ B+ Tree), tr√°nh RAM overload.
	- C·∫ßn serialize tree ho·∫∑c d√πng disk-based storage.
	- K·∫øt h·ª£p caching (Redis, memcached) cho node truy c·∫≠p nhi·ªÅu.
	- Kh√¥ng x√¢y t·ª´ scratch ‚Äì d√πng th∆∞ vi·ªán (Guava TreeMultiset, Apache Commons Tree).


# üéØ T√≥m l·∫°i

	Binary Search Tree kh√¥ng ph·∫£i ƒë·ªÉ "l∆∞u tr·ªØ d·ªØ li·ªáu" cho vui.
	N√≥ l√† m·ªôt t∆∞ duy c·ª±c k·ª≥ hi·ªáu qu·∫£ khi b·∫°n c·∫ßn gi·ªØ d·ªØ li·ªáu c√≥ th·ª© t·ª±, t√¨m ki·∫øm g·∫ßn ƒë√∫ng, v√† thao t√°c v·ªõi range query.
	
	Hi·ªÉu BST l√† hi·ªÉu c·ªët l√µi c·ªßa nhi·ªÅu h·ªá th·ªëng backend.
	Kh√¥ng c·∫ßn reinvent b√°nh xe ‚Üí nh∆∞ng ph·∫£i hi·ªÉu t·∫°i sao th∆∞ vi·ªán ch·ªçn Red-Black Tree thay v√¨ AVL.
	
	Mu·ªën ƒëi xa h∆°n: h·ªçc th√™m Segment Tree, Interval Tree, Fenwick Tree n·∫øu l√†m realtime analytics, ho·∫∑c engine ch∆°i game AI.




	
	
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>