<html><head><title>Lesson 213 == Resilient Event Stream (Reactive Integration) ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 213 -- Resilient Event Stream (Reactive Integration) -//</h1><pre>
# üß† 1. V·∫•n ƒë·ªÅ th·ª±c t·∫ø
	Trong h·ªá th·ªëng microservices ho·∫∑c data pipeline, event stream (d√≤ng s·ª± ki·ªán) l√† x∆∞∆°ng s·ªëng:

		Kafka, RabbitMQ, ho·∫∑c gRPC-stream g·ª≠i li√™n t·ª•c h√†ng ng√†n event/gi√¢y.
		
		M·ªói event c·∫ßn ƒë∆∞·ª£c x·ª≠ l√Ω: validate ‚Üí enrich ‚Üí save ‚Üí publish.
		
		Nh∆∞ng s·ª± c·ªë x·∫£y ra th∆∞·ªùng xuy√™n: network timeout, payload l·ªói, service downstream ch·∫øt t·∫°m th·ªùi.

	N·∫øu ch·ªâ x·ª≠ l√Ω tu·∫ßn t·ª± (synchronous retry, try/catch), b·∫°n s·∫Ω ngh·∫Ωn thread pool v√† m·∫•t t√≠nh ph·∫£n ·ª©ng.
	
	Gi·∫£i ph√°p: Reactive Resilience ‚Äî resilience √°p d·ª•ng v√†o Flux/Flow thay v√¨ h√†m ƒë∆°n l·∫ª.



# ‚öôÔ∏è 2. Reactive Resilience Core

	## ‚ë† Flux.retryWhen()
		Gi·ªëng nh∆∞ withRetry(fn, n) ·ªü functional, nh∆∞ng cho stream:

Flux<Event> source = kafkaFlux()
    .flatMap(this::processEvent)
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
    .onErrorContinue((err, obj) -> log.warn("Skip bad event: {}", obj));

	‚Üí N·∫øu processEvent l·ªói, retry t·ªëi ƒëa 3 l·∫ßn v·ªõi exponential backoff.
		N·∫øu v·∫´n l·ªói, skip v√† x·ª≠ l√Ω ti·∫øp event k·∫ø ti·∫øp ‚Üí kh√¥ng ng·∫Øt c·∫£ pipeline.




	## ‚ë° onErrorResume()
		T∆∞∆°ng ƒë∆∞∆°ng fallback trong functional.

Flux<Event> result = processFlux()
    .onErrorResume(e -> backupFlux());

	‚Üí Khi c√≥ l·ªói, chuy·ªÉn sang stream kh√°c (fallback), v√≠ d·ª•: backup provider, cache local, ho·∫∑c requeue.




	## ‚ë¢ timeout()
		Gi·ªëng withTimeout(fn, Duration), nh∆∞ng reactive native:
	
		‚Üí Event n√†o x·ª≠ l√Ω qu√° 2 gi√¢y b·ªã b·ªè qua, kh√¥ng l√†m t·∫Øc lu·ªìng.
	
	
	
	
# 	üß© 3. Backpressure-Aware Resilience
	
	Backpressure = c∆° ch·∫ø ‚Äúgi·ªõi h·∫°n d√≤ng ch·∫£y‚Äù ‚Äî n·∫øu downstream (consumer) ch·∫≠m, upstream (producer) ph·∫£i gi·∫£m t·ªëc.
	Reactive Streams chu·∫©n h√≥a ƒëi·ªÅu n√†y qua Subscription.request(n).
	
	Khi k·∫øt h·ª£p resilience, ta kh√¥ng d√πng blocking retry m√† l√† non-blocking operator, v√≠ d·ª•:
	
	Flux<Event> resilientFlux = kafkaFlux()
    .limitRate(100)
    .retryWhen(Retry.fixedDelay(5, Duration.ofMillis(500)))
    .onBackpressureDrop(e -> log.warn("Dropped: {}", e));

		- limitRate(100) tr√°nh consumer b·ªã overload.
		- onBackpressureDrop gi·ªØ cho h·ªá th·ªëng ·ªïn ƒë·ªãnh, kh√¥ng out of memory khi event v√†o qu√° nhanh.
	
	
	
# 	üß† 4. Composable Resilience Operators
	Reactive pipeline cho ph√©p compose resilience operators:

kafkaFlux()
  .timeout(Duration.ofSeconds(3))
  .retryWhen(Retry.backoff(3, Duration.ofMillis(500)))
  .onErrorContinue(...)
  .onBackpressureBuffer(1000)

	‚Üí T∆∞∆°ng t·ª± nh∆∞ withRetry().andThen(withTimeout()).andThen(withFallback()) trong b√†i 13.
	Ch·ªâ kh√°c l√† ·ªü ƒë√¢y ta decorator h√≥a d√≤ng d·ªØ li·ªáu thay v√¨ function.



# üè¢ 5. ·ª®ng d·ª•ng Enterprise

	## üßæ Tr∆∞·ªùng h·ª£p: Kafka Consumer resilient 
		Gi·∫£ s·ª≠ c√≥ consumer x·ª≠ l√Ω order:
		
Flux<Order> orders = kafkaReceiver.receive()
    .map(record -> deserialize(record.value()))
    .flatMap(this::processOrder)
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
    .onErrorContinue((err, order) -> {
        log.error("Failed order {}, skipping", order);
        deadLetter(order);
    });


	N·∫øu 1 order l·ªói ‚Üí retry 3 l·∫ßn.
	N·∫øu v·∫´n l·ªói ‚Üí g·ª≠i sang Dead Letter Queue (DLQ).
	Kh√¥ng h·ªÅ block thread, pipeline v·∫´n ti·∫øp t·ª•c.
	
	‚úÖ Kh√¥ng c·∫ßn Spring Retry, kh√¥ng c·∫ßn annotation, thu·∫ßn reactive operator.	


# üß± 6. Tri·∫øt l√Ω s√¢u h∆°n
	Reactive Resilience l√†:

		‚ÄúD√≤ng d·ªØ li·ªáu c√≥ th·ªÉ t·ª± ph·ª•c h·ªìi ‚Äî t·ª´ng ph·∫ßn, kh√¥ng l√†m gi√°n ƒëo·∫°n t·ªïng th·ªÉ.‚Äù

	Trong functional world, resilience = ‚Äúdecorated function‚Äù.
	Trong reactive world, resilience = ‚Äúdecorated stream‚Äù.

	C·∫£ hai ƒë·ªÅu tu√¢n theo tri·∫øt l√Ω:

		No try/catch imperative.
		Kh√¥ng block.
		Composable (retry + timeout + fallback + bulkhead c√≥ th·ªÉ gh√©p t√πy √Ω).
		Declarative DSL style ‚Äî ‚Äúch√≠nh s√°ch‚Äù ch·ª© kh√¥ng ‚Äúc√¢u l·ªánh‚Äù.


</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>