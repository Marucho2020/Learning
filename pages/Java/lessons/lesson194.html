<html><head><title>Lesson 194 == Functional design patterns & best practices ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 194 -- Functional design patterns & best practices -//</h1><pre>
# 1. Functional mindset trong enterprise

	Functional design kh√¥ng ƒë∆°n gi·∫£n l√† ‚Äúd√πng lambda cho g·ªçn code‚Äù, m√† l√†:

		- Chia nh·ªè function: m·ªói function l√†m m·ªôt vi·ªác duy nh·∫•t (Single Responsibility).
		- Compose: gh√©p l·∫°i th√†nh pipeline, d·ªÖ test, d·ªÖ thay ƒë·ªïi rule.
		- Immutability & no side-effects: pipeline thread-safe, d·ªÖ parallelize, kh√¥ng lo race condition.
		- Declarative style: code m√¥ t·∫£ c√°i g√¨ c·∫ßn l√†m, kh√¥ng ph·∫£i l√†m th·∫ø n√†o.

	üëâ ƒê√¢y ch√≠nh l√† "functional design pattern" ‚Äî thay v√¨ design OOP b·∫±ng class hierarchy, ta design b·∫±ng function composition.



# 2. Patterns quan tr·ªçng

	## (a) Pipeline pattern

		T∆∞ duy: d·ªØ li·ªáu ch·∫£y qua nhi·ªÅu function nh·ªè, m·ªói function transform 1 b∆∞·ªõc.
		
		Thay v√¨ if-else kh·ªïng l·ªì, ta c√≥ Predicate chain + Function chain.
		
		Code d·ªÖ maintain: thay rule = inject th√™m function.

	V√≠ d·ª• validate ‚Üí transform ‚Üí aggregate:

List<Employee> employees = ...;

String report = employees.stream()
    .filter(e -> e.getSalary() > 1000)                  // validate rule
    .map(Employee::getEmail)                            // transform
    .collect(Collectors.joining(", "));                 // aggregate

System.out.println("Report: " + report);

	ƒê√¢y l√† functional pipeline pattern: t√°ch t·ª´ng concern th√†nh stage.



# (b) Composition over inheritance

	Trong OOP, ta hay extend class ƒë·ªÉ th√™m behavior. Functional approach: compose function.

		Function<Employee, String> normalizeEmail =
			e -> e.getEmail().toLowerCase();
		
		Function<Employee, String> format =
			normalizeEmail.andThen(email -> "Mail: " + email);
		
	Kh√¥ng c·∫ßn subclass EmployeeFormatter ‚Üí ch·ªâ c·∫ßn compose function.



# (c) Predicate logic composition

	Thay v√¨ vi·∫øt:
		if (age > 18 && status.equals("ACTIVE") && email != null) { ... }

	Ta vi·∫øt:

		Predicate<Employee> valid = 
			e -> e.getAge() > 18;
		valid = valid.and(e -> "ACTIVE".equals(e.getStatus()))
					.and(e -> e.getEmail() != null);
		

	∆Øu ƒëi·ªÉm: 

		D·ªÖ t√°i s·ª≠ d·ª•ng, test ri√™ng t·ª´ng rule.
		D·ªÖ add/remove rule trong runtime (plug-and-play).	



	## (d) Exception handling functional style

		Streams kh√¥ng ‚ÄúƒÉn‚Äù checked exception, n√™n best practice:

			Wrap v√†o Optional: fail ‚Üí empty.
			Custom wrapper: try-catch lambda.


Function<String, Optional<Integer>> safeParse =
    s -> {
        try { return Optional.of(Integer.parseInt(s)); }
        catch (NumberFormatException e) { return Optional.empty(); }
    };



# 3. Enterprise example ‚Äì Report pipeline

Predicate<Employee> isValid =
    e -> e.getSalary() > 1000 &&
         "ACTIVE".equals(e.getStatus()) &&
         e.getEmail() != null;

Function<Employee, String> toEmail = 
    Employee::getEmail;

Function<String, String> toLower = 
    String::toLowerCase;

String report = employees.stream()
    .filter(isValid)                         // validate
    .map(toEmail.andThen(toLower))           // transform
    .collect(Collectors.joining(", "));      // aggregate

System.out.println("Report: " + report);


Pipeline n√†y c√≥ th·ªÉ extend r·∫•t d·ªÖ:

	Add stage maskSensitiveData.
	Add stage sendToExternalSystem.
	Kh√¥ng c·∫ßn rewrite core logic.
	

# 4. Senior-level best practices

	Avoid side-effects trong lambda ‚Üí thread-safe khi parallel.
	
		T·ªá: .forEach(list::add) (shared mutable state).
		T·ªët: d√πng collect.	
	
	Prefer composition over inheritance ‚Üí gi·∫£m coupling.
	Use Optional + wrapper ƒë·ªÉ x·ª≠ l√Ω exception, kh√¥ng throw lung tung trong stream.
	Unit-test t·ª´ng function nh·ªè thay v√¨ test pipeline kh·ªïng l·ªì.
	Think in algebra: Function + Predicate + Collector = building blocks. T∆∞ duy nh∆∞ Lego: build pipeline t·ª´ kh·ªëi nh·ªè, thay v√¨ vi·∫øt procedural code d√†i d√≤ng.	
	
	
	
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>