<html><head><title>Lesson 169 == Fork/Join Framework & Parallel Streams ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 169 -- Fork/Join Framework & Parallel Streams -//</h1><pre>
#  1. Fork/Join Framework ‚Äì Concept 

	Fork/Join = divide and conquer cho multi-threading.
	√ù t∆∞·ªüng:
		- Chia task l·ªõn th√†nh c√°c sub-task nh·ªè (fork).
		- Ch·∫°y sub-task song song.
		- K·∫øt h·ª£p k·∫øt qu·∫£ (join).

	Thread pool ƒë·∫∑c bi·ªát: ForkJoinPool: 
		S·ª≠ d·ª•ng work-stealing algorithm:
			- M·ªói worker thread c√≥ deque.
			- N·∫øu h·∫øt task, steal task t·ª´ thread kh√°c ‚Üí t·∫≠n d·ª•ng CPU.	

	Ph√π h·ª£p v·ªõi CPU-bound tasks, recursive computation, thao t√°c d·ªØ li·ªáu l·ªõn.


# 2. RecursiveTask & RecursiveAction 

| Class              | M·ª•c ƒë√≠ch                         |
| ------------------ | -------------------------------- |
| `Rec Task<V>` | Task c√≥ tr·∫£ v·ªÅ gi√° tr·ªã           |
| `RecursiveAction`  | Task kh√¥ng tr·∫£ v·ªÅ gi√° tr·ªã (void) |

	## üîπ V√≠ d·ª• t√≠nh t·ªïng m·∫£ng l·ªõn: 

class SumTask extends RecursiveTask<Long> {
    private final int[] arr;
    private final int start, end;
    private static final int THRESHOLD = 1000;

    SumTask(int[] arr, int start, int end) {
        this.arr = arr; this.start = start; this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) sum += arr[i];
            return sum;
        } else {
            int mid = (start + end) / 2;
            SumTask left = new SumTask(arr, start, mid);
            SumTask right = new SumTask(arr, mid, end);
            left.fork(); // fork left
            long rightResult = right.compute(); // compute right tr·ª±c ti·∫øp
            long leftResult = left.join(); // join left
            return leftResult + rightResult;
        }
    }
}

	Tip senior: fork + compute ‚Üí tr√°nh deadlock, t·∫≠n d·ª•ng work-stealing.


# 3. ForkJoinPool ‚Äì Common Pool vs Custom Pool

	ForkJoinPool.commonPool():
		Shared pool cho parallelStream() m·∫∑c ƒë·ªãnh.
		Size = s·ªë CPU cores.
		T·ª± ƒë·ªông work-stealing.

	C√≥ th·ªÉ t·∫°o custom pool:
		ForkJoinPool pool = new ForkJoinPool(8); // max 8 threads
		pool.submit(() -> data.parallelStream().forEach(...)).get();

ForkJoinPool pool = new ForkJoinPool(8); // max 8 threads
pool.submit(() -> data.parallelStream().forEach(...)).get();

	Tuning: THRESHOLD qu√° nh·ªè ‚Üí overhead fork/join nhi·ªÅu ‚Üí ch·∫≠m h∆°n sequential; qu√° l·ªõn ‚Üí √≠t parallelism ‚Üí kh√¥ng t·∫≠n d·ª•ng CPU.


# 4. Parallel Streams ‚Äì S·ª≠ d·ª•ng Fork/Join

	Stream.parallel() = abstraction tr√™n ForkJoinPool.
	spliterator chia d·ªØ li·ªáu th√†nh chunk ‚Üí worker threads x·ª≠ l√Ω.
		long sum = Arrays.stream(arr).parallel().sum();

	ƒêi·ªÅu quan tr·ªçng:
		D·ªØ li·ªáu n√™n splittable efficiently ‚Üí Array, ArrayList t·ªët; LinkedList kh√¥ng t·ªët.
		Tr√°nh side-effect mutable state ‚Üí kh√¥ng thread-safe



# Work-Stealing Insight (Senior-level)

	Thread worker:
		Push tasks v√†o deque c·ªßa ri√™ng m√¨nh.
		N·∫øu empty, steal t·ª´ tail c·ªßa deque kh√°c.

	L·ª£i √≠ch:
		CPU utilization cao.
		Kh√¥ng c·∫ßn lock to√†n c·ª•c.

	Nh∆∞·ª£c ƒëi·ªÉm:
		N·∫øu tasks kh√¥ng c√¢n b·∫±ng ‚Üí m·ªôt thread c√≥ th·ªÉ idle, c·∫ßn dynamic threshold ho·∫∑c splitting logic t·ªët.


# 6. Performance Tuning

	Task size (threshold):
		Too small ‚Üí overhead fork/join nhi·ªÅu.
		Too large ‚Üí √≠t parallelism.

	Data structure:
		Prefer Array, ArrayList ‚Üí O(1) random access ‚Üí spliterator chia t·ªët.
		Avoid LinkedList, Stream.generate (infinite) ‚Üí kh√≥ chia.		

	Avoid blocking inside Fork/Join:
		Thread-blocking ‚Üí deadlock (common pool), n·∫øu c·∫ßn ‚Üí custom pool.
		
	Use work-stealing-aware design:	
		Compute-heavy tasks benefit ‚Üí CPU-bound tasks.
		IO-bound ‚Üí ForkJoin kh√¥ng t·ªëi ∆∞u, d√πng cached thread pool.

		
		
# 7. T√≥m t·∫Øt		
		
	| Feature          | Fork/Join                | Parallel Stream                   |
| ---------------- | ------------------------ | --------------------------------- |
| Thread pool      | ForkJoinPool             | ForkJoinPool.commonPool           |
| Task granularity | Explicit (RecursiveTask) | Implicit (spliterator)            |
| Work-stealing    | ‚úî                        | ‚úî                                 |
| Suitable         | CPU-bound, recursive     | CPU-bound, splittable collections |
| Caveats          | Blocking ‚Üí deadlock      | Side-effect state, LinkedList     |
| Tuning           | Threshold, custom pool   | Chunk size, avoid side-effects    |
	

# 8. Senior-level mindset

	Fork/Join = power tool: fine-grained CPU-bound parallelism.
	
	ParallelStream = high-level abstraction: nhanh, d·ªÖ d√πng, nh∆∞ng ph·∫£i hi·ªÉu splitting + thread-safety.
	
	Hi·ªÉu task decomposition, threshold, work-stealing, common pool contention ‚Üí tr√°nh performance trap.
	
	Khi design h·ªá th·ªëng: CPU-bound ‚Üí Fork/Join, IO-bound ‚Üí thread pool b√¨nh th∆∞·ªùng ho·∫∑c reactive.



</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>