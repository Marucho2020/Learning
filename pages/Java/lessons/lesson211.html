<html><head><title>Lesson 211 == Functional Bulkhead & Rate Limiter ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>ğŸ”™ Quay láº¡i danh sÃ¡ch</a><br><h1>Lesson 211 -- Functional Bulkhead & Rate Limiter -//</h1><pre># âš™ï¸ 1. Bá»‘i cáº£nh thá»±c táº¿
	Trong microservice thá»±c táº¿, lá»—i thÆ°á»ng khÃ´ng Ä‘áº¿n tá»« bug mÃ  tá»« quÃ¡ táº£i:
	
	CÃ³ quÃ¡ nhiá»u request Ä‘á»“ng thá»i vÃ o cÃ¹ng má»™t service (thÆ°á»ng lÃ  API call Ä‘áº¿n DB hoáº·c external service).

	Thread pool bá»‹ chiáº¿m háº¿t â†’ request treo, timeout â†’ cascade failure toÃ n há»‡ thá»‘ng

	## Giáº£i phÃ¡p: 

		Giá»›i háº¡n concurrency (bulkhead).
		Giá»›i háº¡n request rate (rate limiter).
		NhÆ°ng lÃ m thuáº§n functional, khÃ´ng block, khÃ´ng annotation, khÃ´ng Redis.
		

# ğŸ§© 2. Bulkhead Pattern â€” giá»›i háº¡n sá»‘ lÆ°á»£ng concurrent call

	## ğŸ”¸ Truyá»n thá»‘ng (OOP cÃ¡ch cÅ©)
		Ta thÆ°á»ng dÃ¹ng Semaphore hoáº·c ThreadPoolExecutor.

Semaphore semaphore = new Semaphore(10);

void handleRequest() {
    if (semaphore.tryAcquire()) {
        try {
            process();
        } finally {
            semaphore.release();
        }
    } else {
        reject();
    }
}


	CÃ¡ch nÃ y á»•n, nhÆ°ng:

		Cáº§n try/finally â†’ imperative style.
		KhÃ³ compose.
		Dá»… block náº¿u dÃ¹ng acquire().


	## ğŸ”¸ Functional Bulkhead
		Biáº¿n giá»›i háº¡n concurrency thÃ nh má»™t pure function wrapper, khÃ´ng phá»¥ thuá»™c class hay thread pool.
	
<T> Supplier<CompletableFuture<T>> limitConcurrency(
        Supplier<CompletableFuture<T>> fn,
        Semaphore semaphore
) {
    return () -> {
        if (semaphore.tryAcquire()) {
            return fn.get()
                     .whenComplete((r, e) -> semaphore.release());
        } else {
            return CompletableFuture.failedFuture(new RuntimeException("Bulkhead limit reached"));
        }
    };
}
	
	BÃ¢y giá» báº¡n cÃ³ thá»ƒ wrap báº¥t ká»³ function nÃ o:	
	
var limitedPayment = limitConcurrency(() -> callPaymentAPI(), new Semaphore(10));

limitedPayment.get(); // sáº½ fail náº¿u quÃ¡ 10 request Ä‘ang cháº¡y
	
		â†’ KhÃ´ng block thread, cháº¡y async, pure functional style.
	
	## ğŸ§  Má»Ÿ rá»™ng
		Báº¡n cÃ³ thá»ƒ nÃ¢ng cáº¥p thÃ nh Higher-Order Function giá»‘ng cÃ¡c bÃ i trÆ°á»›c:
		Function<Supplier<CompletableFuture<T>>, Supplier<CompletableFuture<T>>> withBulkhead(int permits)

		Ä‘á»ƒ compose Ä‘Æ°á»£c:
withRetry(3)
.andThen(withTimeout(Duration.ofSeconds(2)))
.andThen(withBulkhead(10))
.apply(() -> callService());
	
	
	
	
# ğŸ§® 3. Rate Limiter Pattern â€” giá»›i háº¡n tá»‘c Ä‘á»™ request

	## ğŸ”¸ Truyá»n thá»‘ng
		ThÆ°á»ng dÃ¹ng Redis hoáº·c Guava RateLimiter. NhÆ°ng Redis = external state â†’ khÃ´ng thuáº§n functional.


	## ğŸ”¸ Functional Token Bucket
		Ta cÃ³ thá»ƒ tá»± táº¡o pure token bucket.

	Ã tÆ°á»Ÿng:
		Ta cÃ³ thá»ƒ tá»± táº¡o pure token bucket.
	
		CÃ³ tokens Ä‘Æ°á»£c sinh ra theo thá»i gian (vÃ­ dá»¥: 10 token/giÃ¢y).
		Má»—i request tiÃªu 1 token.
		Náº¿u háº¿t token â†’ reject.

class TokenBucket {
    final int capacity;
    final AtomicInteger tokens;
    final long refillRateMillis;
    final AtomicLong lastRefillTime = new AtomicLong(System.currentTimeMillis());

    TokenBucket(int capacity, long refillRateMillis) {
        this.capacity = capacity;
        this.tokens = new AtomicInteger(capacity);
        this.refillRateMillis = refillRateMillis;
    }

    boolean tryConsume() {
        refill();
        if (tokens.get() > 0) {
            tokens.decrementAndGet();
            return true;
        }
        return false;
    }

    private void refill() {
        long now = System.currentTimeMillis();
        long last = lastRefillTime.get();
        long elapsed = now - last;
        if (elapsed > refillRateMillis) {
            int newTokens = (int) (elapsed / refillRateMillis);
            tokens.set(Math.min(capacity, tokens.get() + newTokens));
            lastRefillTime.set(now);
        }
    }
}


	## Sau Ä‘Ã³, functional wrapper: 

<T> Supplier<CompletableFuture<T>> withRateLimit(
        Supplier<CompletableFuture<T>> fn, TokenBucket bucket
) {
    return () -> bucket.tryConsume()
            ? fn.get()
            : CompletableFuture.failedFuture(new RuntimeException("Rate limit exceeded"));
}



# ğŸ§  4. So sÃ¡nh Bulkhead vs Rate Limiter

| Pattern          | Giá»›i háº¡n cÃ¡i gÃ¬                              | CÆ¡ cháº¿       | Khi dÃ¹ng                                    |
| ---------------- | -------------------------------------------- | ------------ | ------------------------------------------- |
| **Bulkhead**     | Sá»‘ lÆ°á»£ng *request Ä‘á»“ng thá»i*                 | Semaphore    | Giá»›i háº¡n concurrency (vÃ­ dá»¥ DB connections) |
| **Rate Limiter** | Sá»‘ lÆ°á»£ng *request trÃªn má»™t Ä‘Æ¡n vá»‹ thá»i gian* | Token bucket | Giá»›i háº¡n tá»‘c Ä‘á»™ (throttling API, user spam) |

	## Cáº£ hai cÃ³ thá»ƒ dÃ¹ng chung:

withBulkhead(10)
.andThen(withRateLimit(100, Duration.ofSeconds(1)))
.apply(() -> callAPI());



# ğŸ¢ 5. Enterprise Use Cases


	## ğŸ’³ 1. Payment Gateway
		Bulkhead giá»›i háº¡n 10 concurrent request tá»›i Stripe.
		Rate limiter giá»›i háº¡n 100 req/s theo user ID.
		
	## ğŸ“Š 2. API Gateway Multi-tenant
		Má»—i tenantId cÃ³ bucket riÃªng.
		Functional map<tenantId, TokenBucket> lÆ°u táº¡i gateway.
		KhÃ´ng cáº§n Redis, khÃ´ng annotation.
		
var bucket = bucketMap.computeIfAbsent(userId, id -> new TokenBucket(100, 100));
withRateLimit(() -> handleUserRequest(id), bucket).get();


	## ğŸ§  3. Reactive Streaming
		Flux hoáº·c Flow.Publisher cÃ³ thá»ƒ dÃ¹ng functional limiter Ä‘á»ƒ Ä‘iá»u tiáº¿t backpressure.


# ğŸ§© 6. Æ¯u Ä‘iá»ƒm Functional Approach

| Æ¯u Ä‘iá»ƒm                 | Giáº£i thÃ­ch                                              |
| ----------------------- | ------------------------------------------------------- |
| âœ… KhÃ´ng block thread    | Sá»­ dá»¥ng `CompletableFuture` hoáº·c reactive stream        |
| âœ… Dá»… test               | Bulkhead vÃ  bucket lÃ  pure object, testable             |
| âœ… Compose Ä‘Æ°á»£c          | `.andThen()` chain resilience policy                    |
| âœ… KhÃ´ng framework magic | KhÃ´ng cáº§n `@RateLimiter`, `@Bulkhead`, hay Resilience4j |




# ğŸ”® 7. Tá»•ng káº¿t triáº¿t lÃ½

	Functional resilience khÃ´ng pháº£i lÃ  â€œÄ‘em pattern OOP viáº¿t láº¡i báº±ng lambdaâ€,
mÃ  lÃ  chuyá»ƒn tá»« stateful control â†’ pure composition,
Ä‘á»ƒ má»—i cÆ¡ cháº¿ resilience chá»‰ lÃ  má»™t function transform policy, cÃ³ thá»ƒ gáº¯n, thÃ¡o, thá»­ nghiá»‡m mÃ  khÃ´ng phÃ¡ code gá»‘c.



</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>ğŸ”™ Quay láº¡i danh sÃ¡ch</a><br><button onclick='toggleTheme()'>ğŸŒ™ Chuyá»ƒn giao diá»‡n</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>