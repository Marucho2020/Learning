<html><head><title>Lesson 183 == Functional Interfaces c∆° b·∫£n ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 183 -- Functional Interfaces c∆° b·∫£n -//</h1><pre>
# 1. Functional Interfaces l√† g√¨?

	Functional Interface (Èñ¢Êï∞Âûã„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ, kans≈´-gata intƒÅfƒìsu) = interface ch·ªâ c√≥ m·ªôt abstract method duy nh·∫•t (SAM: Single Abstract Method).
	
	Annotation @FunctionalInterface ƒë∆∞·ª£c d√πng ƒë·ªÉ compiler check.
	
	C√°c lambda („É©„É†„ÉÄÂºè) v√† method reference („É°„ÇΩ„ÉÉ„ÉâÂèÇÁÖß) ƒë·ªÅu d·ª±a tr√™n functional interface.
	

	## V√≠ d·ª•:

@FunctionalInterface
interface Greeting {
    void sayHello(String name);
}

Greeting g = (n) -> System.out.println("Hello " + n);
g.sayHello("B·∫£o");



# 2. Nh√≥m Functional Interfaces trong java.util.function
	Java chu·∫©n h√≥a m·ªôt nh√≥m "ƒë·∫∑c s·∫£n" functional interface trong package java.util.function. C√°c lo·∫°i ch√≠nh:


| Interface             | K√Ω hi·ªáu input/output     | M·ª•c ƒë√≠ch                                       | V√≠ d·ª•                                                |
| --------------------- | ------------------------ | ---------------------------------------------- | ---------------------------------------------------- |
| **Function\<T,R>**    | `T ‚Üí R`                  | Chuy·ªÉn ƒë·ªïi t·ª´ input sang output                | `Function<Employee,String> f = e -> e.getEmail();`   |
| **Consumer<T>**       | `T ‚Üí void` (side-effect) | Nh·∫≠n input v√† *l√†m g√¨ ƒë√≥*, kh√¥ng tr·∫£ output    | `Consumer<Employee> c = e -> saveToDB(e);`           |
| **Supplier<T>**       | `() ‚Üí T` (lazy)          | Kh√¥ng nh·∫≠n input, *cung c·∫•p* output            | `Supplier<UUID> s = () -> UUID.randomUUID();`        |
| **Predicate<T>**      | `T ‚Üí boolean`            | Ki·ªÉm tra ƒëi·ªÅu ki·ªán, l·ªçc d·ªØ li·ªáu                | `Predicate<Employee> p = e -> e.getSalary() > 5000;` |
| **UnaryOperator<T>**  | `T ‚Üí T`                  | Nh·∫≠n 1 input, tr·∫£ v·ªÅ c√πng ki·ªÉu                 | `UnaryOperator<String> u = s -> s.toUpperCase();`    |
| **BinaryOperator<T>** | `(T,T) ‚Üí T`              | Nh·∫≠n 2 input c√πng ki·ªÉu, tr·∫£ 1 output c√πng ki·ªÉu | `BinaryOperator<Integer> b = (a,b2) -> a+b2;`        |



# 3. Lambda vs Method Reference

	Lambda: ng·∫Øn g·ªçn, inline logic.
	Method reference („É°„ÇΩ„ÉÉ„ÉâÂèÇÁÖß): t√°i s·ª≠ d·ª•ng method c√≥ s·∫µn.

	## V√≠ d·ª• v·ªõi Function<Employee, String>: 
		
// Lambda
Function<Employee, String> f1 = e -> e.getEmail();

// Method reference
Function<Employee, String> f2 = Employee::getEmail;




# 4. Ph√¢n bi·ªát input ‚Üí output, side-effect, lazy


	Input ‚Üí Output (chuy·ªÉn ƒë·ªïi thu·∫ßn t√∫y, pure function):
		Function, UnaryOperator, BinaryOperator.
	
	Side-effect (ÂâØ‰ΩúÁî®, fukusay≈ç):
		Consumer ‚Üí t√°c ƒë·ªông ra ngo√†i (ghi log, l∆∞u DB).
	
	Lazy / Supplier:
		Supplier ‚Üí ch·ªâ cung c·∫•p khi ƒë∆∞·ª£c g·ªçi .get(), kh√¥ng c·∫ßn input.



# 5. Enterprise Example 
	V√≠ d·ª•: x·ª≠ l√Ω Employee trong m√¥i tr∆∞·ªùng enterprise (·ª©ng d·ª•ng qu·∫£n l√Ω nh√¢n s·ª±).

import java.util.*;
import java.util.function.*;

class Employee {
    String name;
    String email;
    double salary;

    Employee(String name, String email, double salary) {
        this.name = name; this.email = email; this.salary = salary;
    }

    String getEmail() { return email; }
    double getSalary() { return salary; }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("A", "a@corp.jp", 4000),
            new Employee("B", "b@corp.jp", 7000)
        );

        // Predicate: l·ªçc theo business rule
        Predicate<Employee> highSalary = e -> e.getSalary() > 5000;
        employees.stream()
                 .filter(highSalary)
                 .forEach(e -> System.out.println("High-salary: " + e.name));

        // Function: tr√≠ch xu·∫•t email
        Function<Employee, String> getEmail = Employee::getEmail;
        employees.stream()
                 .map(getEmail)
                 .forEach(System.out::println);

        // Consumer: log nh√¢n vi√™n
        Consumer<Employee> logEmployee = e -> System.out.println("Logging: " + e.name);
        employees.forEach(logEmployee);

        // Supplier: cung c·∫•p ID m·ªõi
        Supplier<UUID> idSupplier = UUID::randomUUID;
        System.out.println("New ID: " + idSupplier.get());
    }
}



# 6. Level Senior ‚Äì Li√™n h·ªá thi c·ª≠ & th·ª±c t·∫ø

	## Trong Java Silver, ƒë·ªÅ s·∫Ω h·ªèi b·∫°n ph√¢n bi·ªát Function vs Consumer vs Predicate ‚Üí nh·ªõ ch·ªØ k√Ω method:
		apply, accept, get, test, andThen, compose.


	## Trong Java Gold, s·∫Ω ƒëi xa h∆°n:  

		Combinator pattern: predicate1.and(predicate2).or(...).
		
		Chaining function: f1.andThen(f2) vs f1.compose(f2).
		
		Stream API + Lambda: K·∫øt h·ª£p functional interface v√†o pipeline.
		
		Method reference thay v√¨ lambda ƒë·ªÉ code s·∫°ch h∆°n.
		
		
	## 	Trong Enterprise th·ª±c t·∫ø: 	
		
		Predicate = business rules engine.
		
		Function = DTO mapping (entity ‚Üí DTO).
		
		Consumer = side-effect nh∆∞ audit log.
		
		Supplier = factory pattern, lazy init.
		
		Unary/BinaryOperator = transformation/aggregation logic.		
		
		
		
		
		
		
		
		
		
		
		
		
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>