<html><head><title>Lesson 176 == callback- method - fallback ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 176 -- callback- method - fallback -//</h1><pre>
# üîπ 1. method (ph∆∞∆°ng th·ª©c b√¨nh th∆∞·ªùng)

	Definition: kh·ªëi logic c√≥ input/output, g·ªçi xong th√¨ tr·∫£ k·∫øt qu·∫£ (ho·∫∑c exception).
	
	Flow: synchronous, caller ki·ªÉm so√°t lu·ªìng.
	
	Error handling: d√πng try/catch ho·∫∑c checked/unchecked exceptions.

üëâ D√πng khi: logic tuy·∫øn t√≠nh, ƒë·ªìng b·ªô, l·ªói ƒë∆∞·ª£c n√©m tr·ª±c ti·∫øp v·ªÅ caller.




# üîπ 2. callback (h√†m g·ªçi ng∆∞·ª£c)

	Definition: b·∫°n truy·ªÅn m·ªôt function/h√†m/lambda v√†o API, API s·∫Ω g·ªçi ng∆∞·ª£c l·∫°i khi event/async task xong.
	
	Flow: control flow inverted (Inversion of Control). Caller kh√¥ng quy·∫øt ƒë·ªãnh khi n√†o ch·∫°y ‚Üí callee quy·∫øt ƒë·ªãnh.

	Error handling: l·ªói th∆∞·ªùng propagate qua callback ho·∫∑c Future/CompletableFuture.

CompletableFuture.supplyAsync(() -> fetchData())
    .thenAccept(result -> System.out.println("Got: " + result))
    .exceptionally(ex -> { 
        System.err.println("Error: " + ex); 
        return null; 
    });


	·ªû ƒë√¢y, thenAccept v√† exceptionally ch√≠nh l√† callback.
	
	üëâ D√πng khi:

		- Code b·∫•t ƒë·ªìng b·ªô (I/O, network, task background).
		- Event-driven (UI, reactive systems).
		- B·∫°n mu·ªën non-blocking execution.
		
		
#üîπ 3. fallback (ph∆∞∆°ng √°n thay th·∫ø khi fail) 		
		
	Definition: c∆° ch·∫ø degrade gracefully. N·∫øu main method th·∫•t b·∫°i (timeout, exception), h·ªá th·ªëng g·ªçi fallback method ƒë·ªÉ tr·∫£ v·ªÅ k·∫øt qu·∫£ thay th·∫ø.	
		
	Flow: v·∫´n synchronous ho·∫∑c asynchronous t√πy implementation, nh∆∞ng lu√¥n c√≥ default path khi main path fail.	
		
	Error handling: thay v√¨ throw exception l√™n caller, b·∫°n convert n√≥ th√†nh m·ªôt response t·ª´ fallback.	
		
	V√≠ d·ª• (Spring Cloud Resilience4j / Hystrix style):	
		
public String getUserProfile(String id) {
    return Try.of(() -> userService.fetchProfile(id))
              .recover(ex -> defaultProfile(id))  // fallback
              .get();
}
		
		
	üëâ D√πng khi:	
Distributed systems, microservices.

Tr√°nh propagation c·ªßa l·ªói, tƒÉng resilience.

Khi y√™u c·∫ßu t√≠nh s·∫µn s√†ng > t√≠nh ch√≠nh x√°c (v√≠ d·ª•: search service down ‚Üí tr·∫£ v·ªÅ cached result).		
		
		
# üîπ So s√°nh tr·ªçng t√¢m		


| Kh√≠a c·∫°nh          | Method                  | Callback                       | Fallback                             |
| ------------------ | ----------------------- | ------------------------------ | ------------------------------------ |
| **Control flow**   | Caller quy·∫øt ƒë·ªãnh       | Callee quy·∫øt ƒë·ªãnh khi n√†o ch·∫°y | Caller g·ªçi, n·∫øu fail ‚Üí fallback ch·∫°y |
| **ƒê·ªìng b·ªô**        | Th∆∞·ªùng sync             | Th∆∞·ªùng async/non-blocking      | C·∫£ sync/async                        |
| **Error handling** | throw exception         | propagate qua callback         | chuy·ªÉn sang logic thay th·∫ø           |
| **Use case**       | Business logic ƒë∆°n gi·∫£n | Event-driven, async            | Fault tolerance, resilience          |


# üîπ Mindset Senior

	Method = "logic core" ‚Üí d√πng khi deterministic v√† ƒë·ªìng b·ªô.
	
	Callback = "event reaction" ‚Üí d√πng khi inversion of control / async.
	
	Fallback = "Plan B" ‚Üí d√πng khi resilience, degrade gracefully.


	Trong m·ªôt h·ªá th·ªëng microservices enterprise:

		- Method l√† core logic.
		- Callback xu·∫•t hi·ªán trong messaging (Kafka consumer, HTTP async client).
		- Fallback n·∫±m trong resilience layer (Resilience4j, Hystrix, Polly).



# üëâ V√≠ d·ª• th·ª±c chi·∫øn: 

	## Gi·∫£ s·ª≠ b·∫°n c√≥ m·ªôt service g·ªçi API t·ª´ b√™n ngo√†i:

public CompletableFuture<User> getUser(String id) {
    return httpClient.fetchAsync("/users/" + id)
        .thenApply(response -> parseUser(response))     // callback
        .exceptionally(ex -> cachedUser(id));           // fallback
}

	- fetchAsync ‚Üí method call async.
	- thenApply ‚Üí callback khi response v·ªÅ.
	- exceptionally ‚Üí fallback khi API fail.






		
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>