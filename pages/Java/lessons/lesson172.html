<html><head><title>Lesson 172 == Semaphore ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 172 -- Semaphore -//</h1><pre>
# üîπ Semaphore ‚Äì B·ªô ƒë·∫øm c·∫•p ph√©p (permit counter)
	- Semaphore l√† m·ªôt c∆° ch·∫ø ƒë·ªìng b·ªô ho√° d·ª±a tr√™n permit (gi·∫•y ph√©p).
	- C√≥ N permits, thread mu·ªën ti·∫øp t·ª•c ph·∫£i acquire() (xin ph√©p).
	- Khi xong vi·ªác ‚Üí release() (tr·∫£ ph√©p).

	üëâ N·∫øu kh√¥ng c√≤n permit, thread b·ªã block cho ƒë·∫øn khi c√≥ permit kh√°c tr·∫£ l·∫°i.



# 2. C∆° ch·∫ø ho·∫°t ƒë·ªông 

	N·ªôi b·ªô, Semaphore ƒë∆∞·ª£c implement d·ª±a tr√™n AbstractQueuedSynchronizer (AQS)
	C√≥ hai lo·∫°i:
		
		## Fair semaphore (new Semaphore(n, true)): 
			Threads x·∫øp h√†ng FIFO, c√¥ng b·∫±ng.
			√çt starvation, nh∆∞ng throughput th·∫•p h∆°n.

		## Non-fair semaphore (new Semaphore(n)): 
			- Thread m·ªõi ƒë·∫øn c√≥ th·ªÉ v∆∞·ª£t h√†ng.
			- Throughput cao, nh∆∞ng c√≥ nguy c∆° starvation.
	

# 3. Use cases th·ª±c t·∫ø 

	## Resource Pool 
		- V√≠ d·ª•: b·∫°n c√≥ pool v·ªõi 10 connection ‚Üí semaphore v·ªõi 10 permits.
		- Thread n√†o mu·ªën d√πng connection ‚Üí acquire().
		- Khi tr·∫£ connection ‚Üí release().
		- N·∫øu kh√¥ng c√≥ permit ‚Üí thread block ‚Üí tr√°nh overload DB.


	## Bounded concurrency 
		- Ki·ªÉm so√°t s·ªë thread ch·∫°y song song trong critical section.
		- V√≠ d·ª•: gi·ªõi h·∫°n ch·ªâ cho 3 thread truy c·∫≠p API g·ªçi third-party ƒë·ªÉ tr√°nh rate limit

	## Throttling / Rate limiting (primitive) 
		- Semaphore c√≥ th·ªÉ ƒë∆∞·ª£c d√πng ƒë·ªÉ gi·ªõi h·∫°n s·ªë l∆∞·ª£ng task ƒë·ªìng th·ªùi.


	## Alternative cho Mutex 
		
		- Semaphore v·ªõi 1 permit ~ binary semaphore ~ mutex.
		- Nh∆∞ng c·∫©n th·∫≠n: mutex l√† reentrant + ownership strict, c√≤n binary semaphore th√¨ kh√¥ng enforce ownership.
		
		
# 	4. Senior-level code example	
		
class ConnectionPool {
    private final Semaphore semaphore;
    private final List<Connection> pool;

    public ConnectionPool(int poolSize) {
        this.semaphore = new Semaphore(poolSize, true); // fair
        this.pool = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < poolSize; i++) pool.add(new Connection("conn-" + i));
    }

    public Connection acquire() throws InterruptedException {
        semaphore.acquire(); // block n·∫øu h·∫øt permits
        synchronized (pool) {
            return pool.remove(0);
        }
    }

    public void release(Connection conn) {
        synchronized (pool) {
            pool.add(conn);
        }
        semaphore.release();
    }
}
		
	üëâ ƒêi·ªÅu n√†y thay th·∫ø vi·ªác b·∫°n ph·∫£i t·ª± spin-lock + counter.	
		
		
		
# 5. ∆Øu ƒëi·ªÉm vs Nh∆∞·ª£c ƒëi·ªÉm		
		
	## 	‚úÖ ∆Øu ƒëi·ªÉm 
		
		- ƒê∆°n gi·∫£n, d·ªÖ hi·ªÉu, d·ªÖ implement resource pool.
		- C√≥ mode fairness (quan tr·ªçng khi l√†m vi·ªác v·ªõi IO/DB).
		- Linh ho·∫°t h∆°n synchronized (c√≥ th·ªÉ c·∫•p nhi·ªÅu permits 1 l·∫ßn).		
		
			
	## 	‚ö†Ô∏è Nh∆∞·ª£c ƒëi·ªÉm / trap 
		
		- Kh√¥ng enforce ownership: Thread A acquire, Thread B release v·∫´n h·ª£p l·ªá ‚Üí d·ªÖ bug logic.
		- Kh√¥ng reentrant: N·∫øu m·ªôt thread acquire nhi·ªÅu l·∫ßn m√† kh√¥ng release ‚Üí deadlock ch√≠nh n√≥.
		- C√≥ th·ªÉ g√¢y deadlock/livelock n·∫øu kh√¥ng thi·∫øt k·∫ø chu·∫©n (v√≠ d·ª• release qu√™n g·ªçi ‚Üí permit leak ‚Üí to√†n h·ªá th·ªëng block).
		
		
		
# 6. So s√°nh v·ªõi c√°c c∆° ch·∫ø kh√°c


| C∆° ch·∫ø                           | ƒê·∫∑c ƒëi·ªÉm                                      | Khi n√†o d√πng                                          |
| -------------------------------- | --------------------------------------------- | ----------------------------------------------------- |
| `synchronized` / `ReentrantLock` | Mutual exclusion, ownership strict, reentrant | Khi b·∫£o v·ªá **1 resource duy nh·∫•t**                    |
| `Semaphore(1)`                   | Binary semaphore, kh√¥ng ownership strict      | Khi mu·ªën **binary control**, √≠t quan tr·ªçng reentrancy |
| `Semaphore(n)`                   | Counting semaphore, c·∫•p ph√©p N                | Khi c√≥ **pool t√†i nguy√™n gi·ªõi h·∫°n (DB, socket, GPU)** |
| `CountDownLatch`                 | ƒê·∫øm ng∆∞·ª£c 1 chi·ªÅu, kh√¥ng reset                | Khi c·∫ßn **ƒë·ªìng b·ªô ƒëi·ªÉm h·∫πn**                          |
| `CyclicBarrier`                  | ƒê·ªìng b·ªô nh√≥m threads, reset ƒë∆∞·ª£c              | Khi c·∫ßn **barrier rendezvous**                        |


# 7. Senior-level Best Practices 
	
	1. Prefer higher-level constructs (Executor + BlockingQueue) h∆°n l√† t·ª± qu·∫£n l√Ω Semaphore, tr·ª´ khi b·∫°n c·∫ßn ki·ªÉm so√°t concurrency th√¥. 
	
	2. Always release in finally ƒë·ªÉ tr√°nh leak permit: 
semaphore.acquire();
try {
    // do work
} finally {
    semaphore.release();
}


	3. N·∫øu d√πng cho resource pool ‚Üí n√™n wrap logic acquire/release v√†o abstraction, tr√°nh cho client qu√™n release. 
	
	4. C·∫©n th·∫≠n v·ªõi tryAcquire(timeout) ‚Üí n·∫øu timeout, logic fallback ph·∫£i r√µ r√†ng.

	5. V·ªõi workload CPU-bound ‚Üí semaphore kh√¥ng gi√∫p, d√πng ForkJoinPool tuning s·∫Ω hi·ªáu qu·∫£ h∆°n. 

üëâ T√≥m l·∫°i: Semaphore l√† counting gatekeeper ‚Äì cho ph√©p gi·ªõi h·∫°n s·ªë thread truy c·∫≠p t√†i nguy√™n. ·ªû level senior, b·∫°n ph·∫£i ph√¢n bi·ªát r√µ mutex vs semaphore, hi·ªÉu fair vs non-fair, v√† bi·∫øt tr√°nh trap non-reentrant + ownership leak.


</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>