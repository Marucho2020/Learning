<html><head><title>Lesson 111 == Merge Sort Tree ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>ğŸ”™ Quay láº¡i danh sÃ¡ch</a><br><h1>Lesson 111 -- Merge Sort Tree -//</h1><pre># KhÃ¡i niá»‡m  
	Merge Sort Tree lÃ  má»™t cáº¥u trÃºc dá»¯ liá»‡u nÃ¢ng cao, káº¿t há»£p giá»¯a : 
		- Segment Tree(phÃ¢n Ä‘oáº¡n vÃ¹ng dá»¯ liá»‡u )
		- vÃ  Merge Sort (chia Ä‘á»ƒ trá»‹, trá»™n máº£ng con Ä‘Ã£ sáº¯p xáº¿p )
		
	ğŸ“Œ Má»¥c Ä‘Ã­ch chÃ­nh: 
		Tráº£ lá»i cÃ¡c truy váº¥n cÃ³ Ä‘iá»u kiá»‡n thá»© háº¡ng trÃªn Ä‘oáº¡n [L, R] má»™t cÃ¡ch nhanh chÃ³ng. 


# ğŸ§  Váº¤N Äá»€ Cáº¦N GIáº¢I:

	Cho máº£ng A[1..n]. CÃ³ thá»ƒ báº¡n sáº½ pháº£i tráº£ lá»i truy váº¥n kiá»ƒu:
	count(L, R, x): trong Ä‘oáº¡n A[L..R], cÃ³ bao nhiÃªu pháº§n tá»­ â‰¤ x?
	kth(L, R, k): pháº§n tá»­ nhá» thá»© k trong Ä‘oáº¡n A[L..R] lÃ  gÃ¬?
	ğŸ” Náº¿u báº¡n dÃ¹ng sort má»—i láº§n, thÃ¬ Ä‘á»™ phá»©c táº¡p sáº½ lÃ  O(n log n) má»—i truy váº¥n. KhÃ´ng tá»‘i Æ°u.




# âœ… Cáº¤U TRÃšC MERGE SORT TREE: 

	Má»—i node Ä‘áº¡i diá»‡n cho má»™t Ä‘oáº¡n [l..r] cá»§a máº£ng.
	Dá»¯ liá»‡u lÆ°u táº¡i node: lÃ  má»™t máº£ng con Ä‘Ã£ Ä‘Æ°á»£c sáº¯p xáº¿p tá»« A[l..r]. 
	
	â†’ Giá»‘ng y nhÆ° cÃ¡ch Merge Sort tÃ¡ch máº£ng rá»“i trá»™n láº¡i, nhÆ°ng ta lÆ°u toÃ n bá»™ máº£ng Ä‘Ã£ sort á»Ÿ tá»«ng node.
	
	
# 	ğŸ—ï¸ Cáº¤U TRÃšC: 


class MergeSortTree {
    int n;
    ArrayList<Integer>[] tree;

    MergeSortTree(int[] arr) {
        n = arr.length;
        tree = new ArrayList[4 * n];
        build(1, 0, n - 1, arr);
    }

    void build(int node, int l, int r, int[] arr) {
        tree[node] = new ArrayList<>();
        if (l == r) {
            tree[node].add(arr[l]);
            return;
        }
        int mid = (l + r) / 2;
        build(2 * node, l, mid, arr);
        build(2 * node + 1, mid + 1, r, arr);
        tree[node] = merge(tree[2 * node], tree[2 * node + 1]);
    }

    ArrayList<Integer> merge(List<Integer> left, List<Integer> right) {
        ArrayList<Integer> result = new ArrayList<>();
        int i = 0, j = 0;
        while (i < left.size() && j < right.size()) {
            if (left.get(i) < right.get(j))
                result.add(left.get(i++));
            else
                result.add(right.get(j++));
        }
        while (i < left.size()) result.add(left.get(i++));
        while (j < right.size()) result.add(right.get(j++));
        return result;
    }
}


# ğŸ” QUERY Äáº¾M PHáº¦N Tá»¬ â‰¤ X TRONG [L, R]
int query(int node, int l, int r, int ql, int qr, int x) {
    if (qr < l || ql > r) return 0;  // khÃ´ng giao
    if (ql <= l && r <= qr) {
        // Táº¡i node nÃ y chá»©a máº£ng Ä‘Ã£ sort -> binary search
        return upperBound(tree[node], x);
    }
    int mid = (l + r) / 2;
    return query(2 * node, l, mid, ql, qr, x) +
           query(2 * node + 1, mid + 1, r, ql, qr, x);
}

int upperBound(List<Integer> list, int x) {
    int low = 0, high = list.size();
    while (low < high) {
        int mid = (low + high) / 2;
        if (list.get(mid) <= x) low = mid + 1;
        else high = mid;
    }
    return low; // sá»‘ pháº§n tá»­ â‰¤ x
}



# ğŸ“ˆ Äá»˜ PHá»¨C Táº P: 
	XÃ¢y dá»±ng: O(n log n log n) â†’ vÃ¬ táº¡i má»—i node merge máº¥t O(n log n).
	Query: O(log^2 n) â†’ má»—i level lÃ  O(log n) node, má»—i node O(log n) cho binary search.
	Nhanh hÆ¡n ráº¥t nhiá»u náº¿u báº¡n dÃ¹ng cho truy váº¥n cÃ³ Ä‘iá»u kiá»‡n so sÃ¡nh.


# âœ… á»¨NG Dá»¤NG THá»°C Táº¾: 
| TÃ¬nh huá»‘ng                                | Giáº£i phÃ¡p Merge Sort Tree                     |
| ----------------------------------------- | --------------------------------------------- |
| Game: TÃ¬m sá»‘ ngÆ°á»i cÃ³ Ä‘iá»ƒm < X trong vÃ¹ng | TÃ­nh toÃ¡n nhanh sá»‘ lÆ°á»£ng Ä‘iá»ƒm náº±m trong range |
| Analytics: Top-k / rank queries           | Truy váº¥n pháº§n tá»­ nhá» thá»© k trong Ä‘oáº¡n         |
| Há»‡ thá»‘ng log, realtime data               | Truy váº¥n táº­p há»£p dá»¯ liá»‡u cÃ³ Ä‘iá»u kiá»‡n lá»c     |
| Káº¿t há»£p Lazy Propagation (khÃ³ hÆ¡n)        | Cáº§n má»Ÿ rá»™ng MergeSortTree lazy-aware          |




# ğŸ§  CÃC Cáº¤U TRÃšC LIÃŠN QUAN NÃŠN Há»ŒC:
| TÃªn cáº¥u trÃºc            | Má»¥c tiÃªu                              |
| ----------------------- | ------------------------------------- |
| Segment Tree            | Truy váº¥n tá»•ng, min/max, update        |
| Binary Indexed Tree     | Nháº¹ hÆ¡n Segment Tree (prefix sum)     |
| Persistent Segment Tree | LÆ°u lá»‹ch sá»­ thay Ä‘á»•i                  |
| Wavelet Tree            | Truy váº¥n rank/k-th + táº§n suáº¥t pháº§n tá»­ |
| Merge Sort Tree         | Äáº¿m pháº§n tá»­ thá»a Ä‘iá»u kiá»‡n (â‰¤ x)      |


</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>ğŸ”™ Quay láº¡i danh sÃ¡ch</a><br><button onclick='toggleTheme()'>ğŸŒ™ Chuyá»ƒn giao diá»‡n</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>