<html><head><title>Lesson 207 == Functional System Integration & Resilience Pattern ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>ğŸ”™ Quay láº¡i danh sÃ¡ch</a><br><h1>Lesson 207 -- Functional System Integration & Resilience Pattern -//</h1><pre>
# ğŸ¯ Má»¥c tiÃªu

Hiá»ƒu cÃ¡ch tÃ­ch há»£p há»‡ thá»‘ng (integration) vÃ  Ä‘áº£m báº£o resilience (chá»‘ng lá»—i, retry, timeout, circuit breaker) mÃ  váº«n giá»¯ nguyÃªn tinh tháº§n functional â€” tá»©c lÃ :

	KhÃ´ng phá»¥ thuá»™c vÃ o annotation nhÆ° @Retryable, @CircuitBreaker.
	KhÃ´ng áº©n logic trong framework magic (Resilience4j, Spring Retry).
	Má»i cÆ¡ cháº¿ resilience Ä‘á»u lÃ  function thuáº§n (pure, composable, testable).
	
	

# ğŸ” 1. Functional System Integration lÃ  gÃ¬?

	Trong enterprise, "integration" nghÄ©a lÃ  káº¿t ná»‘i giá»¯a cÃ¡c service hoáº·c API bÃªn ngoÃ i.
	ThÃ´ng thÆ°á»ng trong OOP/Spring style, ta lÃ m nhÆ° sau:



	@Service
public class OrderService {
    @Retryable
    public OrderResult process(Order order) {
        return externalPaymentApi.call(order);
    }
}

	CÃ¡ch nÃ y dá»…, nhÆ°ng áº©n logic retry trong annotation.
		Functional design thÃ¬ minh báº¡ch hÃ³a toÃ n bá»™ pipeline retry/timeout, vÃ  ta cÃ³ thá»ƒ compose cÃ¡c policy nhÆ° lego.


# âš™ï¸ 2. Functional Resilience â€” Báº£n cháº¥t

	Ta Ä‘á»‹nh nghÄ©a cÃ¡c hÃ m resilience nhÆ° Higher-Order Functions (HOF):
	HÃ m nháº­n vÃ o â€œcore functionâ€ vÃ  tráº£ vá» â€œwrapped function cÃ³ resilienceâ€.

Function<T, R> withRetry(Function<T, R> fn, int maxRetries);
Function<T, R> withTimeout(Function<T, R> fn, Duration timeout);
Function<T, R> withCircuitBreaker(Function<T, R> fn, CircuitState state);

	Sau Ä‘Ã³, ta compose:

Function<Order, Result> processOrder =
    withCircuitBreaker(
        withTimeout(
            withRetry(externalPaymentCall, 3),
            Duration.ofSeconds(2)
        ),
        circuitState
    );

	ğŸ’¡ Má»i logic resilience trá»Ÿ thÃ nh pure functional layer, khÃ´ng phá»¥ thuá»™c framework, dá»… unit test, dá»… tÃ¡i sá»­ dá»¥ng.


# ğŸ§  3. VÃ­ dá»¥ thá»±c táº¿ â€” Payment API Integration

	## TrÆ°á»›c: OOP kiá»ƒu Spring Boot

@Retryable
@CircuitBreaker
public PaymentResponse call(PaymentRequest req) {
    return restTemplate.postForObject(apiUrl, req, PaymentResponse.class);
}



	## Sau: Functional 
		â†’ KhÃ´ng cáº§n framework, logic rÃµ rÃ ng, cÃ³ thá»ƒ compose linh hoáº¡t, log, test tá»«ng lá»›p resilience riÃªng.


Function<PaymentRequest, PaymentResponse> apiCall = req -> restClient.send(req);

Function<PaymentRequest, PaymentResponse> resilientApiCall =
    withCircuitBreaker(
        withRetry(
            withTimeout(apiCall, Duration.ofSeconds(3)),
            5
        ),
        state
    );

PaymentResponse response = resilientApiCall.apply(req);


	â†’ KhÃ´ng cáº§n framework, logic rÃµ rÃ ng, cÃ³ thá»ƒ compose linh hoáº¡t, log, test tá»«ng lá»›p resilience riÃªng.


# ğŸ§© 4. Backpressure + Retry phá»‘i há»£p tháº¿ nÃ o?

	Khi káº¿t há»£p reactive (vÃ­ dá»¥ Reactor, Flow, Akka Streams), resilience cÃ³ thá»ƒ Ä‘Æ°á»£c nhÃºng vÃ o pipeline:

Flux.from(publisher)
    .flatMap(request -> Mono.fromCallable(() -> apiCall.apply(request))
                             .timeout(Duration.ofSeconds(2))
                             .retryWhen(Retry.max(3))
    )
    .onErrorContinue((err, req) -> log.warn("failed {}", req))
    .subscribe();


	â†’ ÄÃ¢y lÃ  functional reactive resilience:
	Má»—i policy lÃ  má»™t operator, táº¥t cáº£ Ä‘á»u pure vÃ  composable â€” khÃ´ng â€œáº©nâ€ bÃªn trong annotation.




# ğŸ”’ 5. Enterprise Pattern Mapping

| OOP/Imperative Pattern   | Functional Equivalent              |
| ------------------------ | ---------------------------------- |
| `@Retryable`, `@Timeout` | `withRetry`, `withTimeout` (HOF)   |
| `CircuitBreakerAspect`   | `withCircuitBreaker(fn, state)`    |
| `Bulkhead pattern`       | `limitConcurrency(fn, permits)`    |
| `Fallback method`        | `fn.orElse(fallbackFn)`            |
| `@Transactional`         | `withTransaction(fn)`              |
| `try/catch`              | `Try<T>` hoáº·c `Either<L, R>` Monad |




# ğŸ’¼ 6. Enterprise Application â€” Resilient ETL Pipeline

	Má»™t ETL service cáº§n táº£i dá»¯ liá»‡u tá»« nhiá»u nguá»“n API khÃ´ng á»•n Ä‘á»‹nh, vÃ  gá»­i sang Kafka.

	Functional pipeline:

Flux.fromIterable(sources)
    .flatMap(source ->
        Mono.fromCallable(() -> fetchData(source))
            .transform(withRetryFn(3))
            .transform(withTimeoutFn(Duration.ofSeconds(5)))
            .onErrorResume(ex -> Mono.just(FallbackData.EMPTY))
    )
    .map(transformToUnifiedFormat)
    .flatMap(sendToKafka)
    .subscribe();


	â†’ KhÃ´ng framework magic, toÃ n bá»™ resilience logic compose tá»« pure function.
	â†’ Unit test dá»…: test tá»«ng withRetryFn, withTimeoutFn riÃªng biá»‡t.



# ğŸ§© 7. TÆ° duy Functional Resilience

	KhÃ´ng giáº¥u lá»—i, khÃ´ng áº©n logic
		â†’ Functional = minh báº¡ch vÃ  cÃ³ thá»ƒ reasoning.
	
	Composability > Configuration
		â†’ DÃ¹ng function composition, khÃ´ng config YAML.
	
	Determinism > Magic
		â†’ Ta cÃ³ thá»ƒ dá»± Ä‘oÃ¡n chÃ­nh xÃ¡c pipeline sáº½ lÃ m gÃ¬ â€” khÃ´ng phá»¥ thuá»™c runtime annotation.



# ğŸ”š Káº¿t luáº­n

Functional System Integration & Resilience Pattern lÃ  bÆ°á»›c tiáº¿n cá»§a enterprise Java:

	- Biáº¿n resilience thÃ nh pure logic, dá»… compose.
	- Dá»… kiá»ƒm thá»­, dá»… logging, dá»… reuse.
	- Loáº¡i bá» dependency vÃ o framework, annotation, AOP.
	- GiÃºp reactive + functional pipeline Ä‘áº¡t deterministic reliability.

</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>ğŸ”™ Quay láº¡i danh sÃ¡ch</a><br><button onclick='toggleTheme()'>ğŸŒ™ Chuyá»ƒn giao diá»‡n</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>