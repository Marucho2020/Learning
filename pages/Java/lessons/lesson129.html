<html><head><title>Lesson 129 == Fenwick Tree (BIT) ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 129 -- Fenwick Tree (BIT) -//</h1><pre># Kh√°i ni·ªám  
	Fenwick Tree l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu d·∫°ng c√¢y nh·ªã ph√¢n ·∫£o d·ª±a tr√™n bit th·∫•p nh·∫•t (x & -x), d√πng ƒë·ªÉ:
		TƒÉng hi·ªáu qu·∫£ t√≠nh prefix sum (ho·∫∑c max/min t√πy bi·∫øn).
		L√†m ƒë∆∞·ª£c t·∫•t c·∫£ n·∫øu thao t√°c c·∫ßn l√† k·∫øt h·ª£p hai ph·∫ßn t·ª≠ theo h√†m k·∫øt h·ª£p (associative).
	‚ö†Ô∏è N√≥ KH√îNG ph·∫£i l√† c√¢y nh·ªã ph√¢n th·∫≠t s·ª±. M·ªói node ƒë·∫°i di·ªán cho m·ªôt kho·∫£ng ƒë·ªông, th∆∞·ªùng l√† m·ªôt ƒëo·∫°n [i - (i & -i) + 1, i].
	
# üß† 2. B·∫£n ch·∫•t to√°n h·ªçc

	Fenwick Tree khai th√°c bi·ªÉu di·ªÖn nh·ªã ph√¢n ƒë·ªÉ "jump" qua c√°c v√πng hi·ªáu qu·∫£:
	
		i += i & -i ‚Üí ƒëi l√™n c√¢y (ƒë·ªÉ c·∫≠p nh·∫≠t)
		i -= i & -i ‚Üí ƒëi xu·ªëng c√¢y (ƒë·ªÉ query)

	V√≠ d·ª•: 
		i = 12 = 1100‚ÇÇ 
		i & -i = 100‚ÇÇ = 4 
		
	ƒêi·ªÅu n√†y nghƒ©a l√† node 12 ƒë·∫°i di·ªán cho ƒëo·∫°n [9, 12] trong m·∫£ng g·ªëc.

# ‚è± 3. ƒê·ªô ph·ª©c t·∫°p th·ª±c t·∫ø	
		
	O(log N) l√† ƒë√∫ng, nh∆∞ng c·ª±c nhanh, do: 
		Kh√¥ng c√≥ recursion, kh√¥ng c√≥ c√¢y th·∫≠t (ch·ªâ l√† m·∫£ng 1 chi·ªÅu).
		Ch·∫°y t·ªët trong v√≤ng l·∫∑p l√™n t·ªõi h√†ng tri·ªáu ph·∫ßn t·ª≠.
		Th∆∞·ªùng nhanh h∆°n segment tree 5‚Äì10 l·∫ßn trong th·ª±c t·∫ø.
		
	
# üõ† 4. Tri·ªÉn khai chu·∫©n
	class BIT {
    int[] bit;
    int n;

    BIT(int size) {
        n = size;
        bit = new int[n + 1];
    }

    void update(int i, int delta) {
        for (; i <= n; i += (i & -i)) {
            bit[i] += delta;
        }
    }

    int query(int i) {
        int res = 0;
        for (; i > 0; i -= (i & -i)) {
            res += bit[i];
        }
        return res;
    }

    int rangeQuery(int l, int r) {
        return query(r) - query(l - 1);
    }
}


# üß® 5. Bi·∫øn th·ªÉ BIT th∆∞·ªùng b·ªã b·ªè qua	
	
	## 5.1. Range Update ‚Äì Point Query 
		D√πng 1 c√¢y BIT ƒë·ªÉ th·ª±c hi·ªán add(l, r, x) v√† get(i):
		
	Update:
    add(i)   += x
    add(j+1) -= x
Query:
    get(i) = prefix sum ƒë·∫øn i
	
	
	## 5.2. Range Update ‚Äì Range Query
		C·∫ßn 2 c√¢y BIT: BIT1 v√† BIT2 ƒë·ªÉ x·ª≠ l√Ω:
			add(l, r, x)
			prefix_sum(i) = BIT1.query(i) * i - BIT2.query(i)
			
		√Åp d·ª•ng nguy√™n l√Ω t√≠ch ph√¢n r·ªùi r·∫°c.
		// BIT1 d√πng ƒë·ªÉ l∆∞u +x
		// BIT2 d√πng ƒë·ªÉ ƒëi·ªÅu ch·ªânh sai s·ªë trong t√≠ch ph√¢n
	

# üß± 6. BIT 2D ‚Äì Binary Indexed Tree 2D
	N·∫øu b·∫°n c√≥ ma tr·∫≠n N x M, th√¨ tri·ªÉn khai BIT 2D ƒë∆°n gi·∫£n nh∆∞ sau:
	
class BIT2D {
    int[][] bit;
    int n, m;

    BIT2D(int n, int m) {
        this.n = n; this.m = m;
        bit = new int[n+1][m+1];
    }

    void update(int x, int y, int delta) {
        for (int i = x; i <= n; i += (i & -i)) {
            for (int j = y; j <= m; j += (j & -j)) {
                bit[i][j] += delta;
            }
        }
    }

    int query(int x, int y) {
        int res = 0;
        for (int i = x; i > 0; i -= (i & -i)) {
            for (int j = y; j > 0; j -= (j & -j)) {
                res += bit[i][j];
            }
        }
        return res;
    }

    int rangeQuery(int x1, int y1, int x2, int y2) {
        return query(x2, y2) - query(x1-1, y2) - query(x2, y1-1) + query(x1-1, y1-1);
    }
}

# üî• 7. ·ª®ng d·ª•ng ƒë·∫∑c bi·ªát (high-level)

| ·ª®ng d·ª•ng                           | Ghi ch√∫                                                 |
| ---------------------------------- | ------------------------------------------------------- |
| T√≠nh inversion trong m·∫£ng          | Duy·ªát ng∆∞·ª£c v√† c·∫≠p nh·∫≠t BIT                             |
| C√¢u h·ªèi s·ªë ph·∫ßn t·ª≠ nh·ªè h∆°n/l·ªõn h∆°n | T√≠nh prefix count                                       |
| Merge k m·∫£ng c√≥ th·ª© t·ª±             | BIT d√πng nh∆∞ priority queue                             |
| K-th order statistic               | T√¨m ph·∫ßn t·ª≠ c√≥ prefix sum b·∫±ng k                        |
| Dynamic range sum                  | T∆∞∆°ng t·ª± Segment Tree nh∆∞ng nh·∫π h∆°n                     |
| 2D/3D prefix sum with update       | D√πng BIT 2D, BIT 3D (n·∫∑ng, nh∆∞ng c√≥ th·ªÉ)                |
| Truy v·∫•n XOR                       | D√πng BIT n·∫øu b·∫°n encode ƒë∆∞·ª£c thao t√°c XOR               |
| RMQ min/max?                       | ‚ùå KH√îNG d√πng BIT. Kh√¥ng associative. D√πng Segment Tree. |

# üß† T·∫ßm nh√¨n xa
	Fenwick Tree l√† v≈© kh√≠ h·∫°ng nh·∫π nh∆∞ng hi·ªáu qu·∫£ c·ª±c cao trong c√°c b√†i to√°n dynamic range prefix
	C·∫•u tr√∫c n√†y g·∫ßn nh∆∞ l√† chu·∫©n v√†ng trong competitive programming n·∫øu b·∫°n c·∫ßn:
		update O(log n)
		query O(log n)
		chi ph√≠ th·∫•p (√≠t RAM, ƒë∆°n gi·∫£n)

	Kh√¥ng th√≠ch h·ª£p n·∫øu:
		B·∫°n c·∫ßn lazy propagation
		H√†m k·∫øt h·ª£p kh√¥ng ph·∫£i c·ªông/tr·ª´
		B·∫°n c·∫ßn query d·∫°ng non-prefix ho·∫∑c theo ƒëi·ªÅu ki·ªán ph·ª©c t·∫°p (v√≠ d·ª• max/min/k-th)
		
		
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>