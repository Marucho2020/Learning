<html><head><title>Lesson 128 == Segment Tree 2D ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 128 -- Segment Tree 2D -//</h1><pre># Kh√°i ni·ªám 
	 l√† m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu m·ªü r·ªông t·ª´ Segment Tree 1D ƒë·ªÉ x·ª≠ l√Ω c√°c truy v·∫•n v√† c·∫≠p nh·∫≠t tr√™n ma tr·∫≠n (2 chi·ªÅu).


# ‚öôÔ∏è T·ªïng quan 
	Segment Tree 2D h·ªó tr·ª£ c√°c truy v·∫•n nh∆∞:
		Query t·ªïng, max, min tr√™n h√¨nh ch·ªØ nh·∫≠t con [(x1, y1), (x2, y2)]
		Update gi√° tr·ªã t·∫°i m·ªôt ƒëi·ªÉm (x, y) ho·∫∑c tr√™n h√¨nh ch·ªØ nh·∫≠t con

# üß† √ù t∆∞·ªüng ch√≠nh 
	X√¢y d·ª±ng Segment Tree theo t·ª´ng chi·ªÅu: 
		Coi h√†ng l√† m·ªôt chi·ªÅu (X-axis), c·ªôt l√† m·ªôt chi·ªÅu (Y-axis).
		V·ªõi m·ªói node trong c√¢y X, b·∫°n x√¢y c√¢y Y t∆∞∆°ng ·ª©ng. 
		
	üëâ C·∫•u tr√∫c c√¢y l√† c√¢y trong c√¢y (nested segment tree).
	

# üì¶ C·∫•u tr√∫c d·ªØ li·ªáu 
	Gi·∫£ s·ª≠ ma tr·∫≠n A c√≥ k√≠ch th∆∞·ªõc N x M, ta x√¢y c√¢y nh∆∞ sau: 
	
	// segTree[x][y] = gi√° tr·ªã (t·ªïng / min / max ...) t·∫°i node (x, y)
	long[][] segTree;
	M·ªói node theo X (h√†ng) s·∫Ω ch·ª©a m·ªôt c√¢y con theo Y (c·ªôt).


# üîß Build Tree
	Pseudocode (t·ªïng qu√°t):
	
// G·ªçi buildX(1, 0, N-1)
void buildX(int vx, int lx, int rx) {
    if (lx == rx) {
        buildY(vx, lx, rx, 1, 0, M-1); // Ch·ªâ c·∫ßn l·∫•y d·ªØ li·ªáu t·ª´ d√≤ng lx
    } else {
        int mx = (lx + rx) / 2;
        buildX(2*vx, lx, mx);
        buildX(2*vx+1, mx+1, rx);
        buildY(vx, lx, rx, 1, 0, M-1); // Sau khi con X ƒë∆∞·ª£c build, m·ªõi build c√¢y Y
    }
}

// G·ªçi buildY(vx, lx, rx, vy, ly, ry)
void buildY(int vx, int lx, int rx, int vy, int ly, int ry) {
    if (ly == ry) {
        if (lx == rx) {
            segTree[vx][vy] = A[lx][ly];
        } else {
            segTree[vx][vy] = segTree[2*vx][vy] + segTree[2*vx+1][vy];
        }
    } else {
        int my = (ly + ry) / 2;
        buildY(vx, lx, rx, 2*vy, ly, my);
        buildY(vx, lx, rx, 2*vy+1, my+1, ry);
        segTree[vx][vy] = segTree[vx][2*vy] + segTree[vx][2*vy+1];
    }
}
	
	
	C·∫•u tr√∫c n√†y t·∫°o n√™n m·ªôt c√¢y 2D, trong ƒë√≥:

		M·ªói node vx qu·∫£n l√Ω ƒëo·∫°n d√≤ng [lx, rx]
		M·ªói c√¢y con vy t·∫°i node vx qu·∫£n l√Ω ƒëo·∫°n c·ªôt [ly, ry]
	
# üì• Update	
	ƒê·ªÉ c·∫≠p nh·∫≠t ƒëi·ªÉm (x, y):
		void updateX(int vx, int lx, int rx, int x, int y, long newVal) {
    if (lx == rx) {
        updateY(vx, lx, rx, 1, 0, M-1, x, y, newVal);
    } else {
        int mx = (lx + rx) / 2;
        if (x <= mx) updateX(2*vx, lx, mx, x, y, newVal);
        else updateX(2*vx+1, mx+1, rx, x, y, newVal);
        updateY(vx, lx, rx, 1, 0, M-1, x, y, newVal);
    }
}
H√†m updateY c·∫≠p nh·∫≠t l·∫°i c√¢y Y t∆∞∆°ng ·ª©ng t·∫°i m·ªói c·∫•p c·ªßa X.


	
#	üîç Query 
	Truy v·∫•n t·ªïng/min/max tr√™n h√¨nh ch·ªØ nh·∫≠t:
	
long queryX(int vx, int lx, int rx, int x1, int x2, int y1, int y2) {
    if (rx < x1 || lx > x2) return 0; // Kh√¥ng giao
    if (x1 <= lx && rx <= x2) return queryY(vx, 1, 0, M-1, y1, y2);
    int mx = (lx + rx) / 2;
    return queryX(2*vx, lx, mx, x1, x2, y1, y2) +
           queryX(2*vx+1, mx+1, rx, x1, x2, y1, y2);
}
	
	H√†m queryY gi·ªëng h·ªát query trong Segment Tree 1D.
	
# üìà ƒê·ªô ph·ª©c t·∫°p	
	X√¢y d·ª±ng: O(N √ó M √ó logN √ó logM)
	Truy v·∫•n / c·∫≠p nh·∫≠t: O(logN √ó logM)
	T·ªëi ∆∞u h∆°n nhi·ªÅu so v·ªõi brute-force (O(N√óM)) v√† hi·ªáu qu·∫£ h∆°n Sparse Table trong b√†i to√°n c√≥ c·∫≠p nh·∫≠t.
	
# ‚öîÔ∏è So s√°nh v√† h·∫°n ch·∫ø	
| C·∫•u tr√∫c         | Update   | Query    | H·ªó tr·ª£ lazy?               |
| ---------------- | -------- | -------- | -------------------------- |
| Brute-force      | O(1)     | O(NM)    | Kh√¥ng                      |
| 2D Prefix Sum    | O(1)     | O(1)     | Kh√¥ng h·ªó tr·ª£ update        |
| Segment Tree 2D  | O(log¬≤N) | O(log¬≤N) | C√≥ (c·∫ßn m·ªü r·ªông)           |
| BIT 2D (Fenwick) | O(log¬≤N) | O(log¬≤N) | Kh√¥ng t·ªët v·ªõi range-update |

# 	üß† Nh·∫≠n x√©t chuy√™n s√¢u (t·∫ßm senior)

	C√¢y Segment 2D c√≥ th·ªÉ m·ªü r·ªông l√™n 3D, nh∆∞ng ph·ª©c t·∫°p tƒÉng c·∫•p s·ªë m≈©.
	ƒê·ªÉ d√πng lazy propagation, b·∫°n c·∫ßn build th√™m lazyY trong m·ªói node X ‚Äì kh√¥ng d·ªÖ maintain, r·∫•t prone to bug.
	Trong nhi·ªÅu tr∆∞·ªùng h·ª£p, Wavelet Tree, Persistent Segment Tree ho·∫∑c Sqrt Decomposition c√≥ th·ªÉ thay th·∫ø n·∫øu b·∫°n ch·ªâ c·∫ßn query k-th, ho·∫∑c c·∫≠p nh·∫≠t theo v√πng nh·ªè.
	Tuy nhi√™n, Segment Tree 2D l√† n·ªÅn t·∫£ng b·∫Øt bu·ªôc n·∫øu b·∫°n l√†m v·ªÅ image processing, computational geometry, game engine backend ho·∫∑c x·ª≠ l√Ω grid ph·ª©c t·∫°p.	
	
	
#üõ† Khi n√†o n√™n d√πng?
	
	C√≥ nhi·ªÅu truy v·∫•n ho·∫∑c c·∫≠p nh·∫≠t trong ma tr·∫≠n
	C·∫ßn hi·ªáu nƒÉng cao (v√≠ d·ª• 10‚Åµ truy v·∫•n, m·ªói query tr√™n l∆∞·ªõi 1000√ó1000)
	Kh√¥ng d√πng ƒë∆∞·ª£c prefix sum v√¨ c√≥ c·∫≠p nh·∫≠t

</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>