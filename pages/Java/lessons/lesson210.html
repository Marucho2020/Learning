<html><head><title>Lesson 210 == Functional Fallback & Recovery Pattern ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 210 -- Functional Fallback & Recovery Pattern -//</h1><pre>

# ‚öôÔ∏è 1. V·∫•n ƒë·ªÅ c·ªßa try/catch trong h·ªá th·ªëng l·ªõn

Trong h·ªá th·ªëng th·ª±c t·∫ø (v√≠ d·ª•: thanh to√°n, email, ETL):


	H·∫ßu nh∆∞ t·∫•t c·∫£ c√°c call ƒë·ªÅu c√≥ th·ªÉ fail.
	B·∫°n c·∫ßn fallback (chuy·ªÉn h∆∞·ªõng sang ph∆∞∆°ng √°n d·ª± ph√≤ng) ‚Äî v√≠ d·ª•:
		Payment fail ‚Üí th·ª≠ backup provider.
		Email service down ‚Üí g·ª≠i qua queue ƒë·ªÉ retry sau.

	N·∫øu ta d√πng try/catch kh·∫Øp n∆°i, code s·∫Ω tr·ªü th√†nh:

try {
    payment.charge();
} catch (Exception e1) {
    try {
        backupPayment.charge();
    } catch (Exception e2) {
        logger.error("Both providers failed");
    }
}


‚Üí V√¥ c√πng r·ªëi, kh√≥ test, kh√≥ compose, v√† t·ªá h∆°n: logic resilience b·ªã l·∫´n v√†o logic nghi·ªáp v·ª•.

Functional approach gi√∫p ta t√°ch bi·ªát ho√†n to√†n hai t·∫ßng n√†y.



# üß© 2. Gi·ªõi thi·ªáu Try<T> Monad (ho·∫∑c Either<Error, T>)

	Try<T> l√† m·ªôt container bi·ªÉu di·ªÖn k·∫øt qu·∫£ c√≥ th·ªÉ th√†nh c√¥ng ho·∫∑c th·∫•t b·∫°i, thay th·∫ø ho√†n to√†n cho try/catch.

	Gi·ªëng nh∆∞ Optional<T>, nh∆∞ng c√≥ th√™m error info:

	Try<T> = Success<T> | Failure<Throwable>

	V√≠ d·ª• minh h·ªça ƒë∆°n gi·∫£n:


class Try<T> {
    private final T value;
    private final Throwable error;

    private Try(T value, Throwable error) {
        this.value = value;
        this.error = error;
    }

    public static <T> Try<T> of(Supplier<T> fn) {
        try {
            return new Try<>(fn.get(), null);
        } catch (Throwable t) {
            return new Try<>(null, t);
        }
    }

    public boolean isSuccess() { return error == null; }
    public T getOrElse(T fallback) { return isSuccess() ? value : fallback; }
    public Try<T> recoverWith(Supplier<T> fallbackFn) {
        return isSuccess() ? this : Try.of(fallbackFn);
    }
}


	## B√¢y gi·ªù, kh√¥ng c·∫ßn try/catch, ta vi·∫øt: 

var result = Try.of(() -> payment.charge())
                .recoverWith(() -> backupPayment.charge());



	## üí° ƒêi·ªÉm m·∫°nh: 

		Kh√¥ng throw exception.
		D·ªÖ chain logic fallback.
		C√≥ th·ªÉ log, map, transform k·∫øt qu·∫£ nh∆∞ stream.



# üß† 3. Either<Error, Result> ‚Äî m√¥ h√¨nh Monad m·∫°nh h∆°n Try

	N·∫øu b·∫°n mu·ªën ph√¢n bi·ªát l·ªói c√≥ lo·∫°i c·ª• th·ªÉ (v√≠ d·ª•: network fail, validation fail, provider fail), ta d√πng Either<L, R>.


	Either<Error, PaymentResponse> result = payment.charge();

		Left = l·ªói
		Right = k·∫øt qu·∫£

	Sau ƒë√≥:
		result.orElse(() -> backupPayment.charge());

	C√°ch n√†y an to√†n h∆°n, v√¨ error type l√† ki·ªÉu c·ª• th·ªÉ (c√≥ th·ªÉ sealed interface trong Java 17+).



# üîó 4. Policy chaining: withRetry().recoverWith(fallback)
	B√¢y gi·ªù ta k·∫øt h·ª£p b√†i tr∆∞·ªõc (Resilience composition) v·ªõi fallback functional.

Supplier<CompletableFuture<String>> resilient =
    withRetry(3)
    .andThen(withTimeout(Duration.ofSeconds(2)))
    .apply(() -> callPaymentProvider())
    .recoverWith(() -> callBackupProvider());

	‚Üí Khi callPaymentProvider() th·∫•t b·∫°i sau retry, fallback t·ª± ƒë·ªông ch·∫°y ‚Äî kh√¥ng try/catch, kh√¥ng annotation.


# üè¢ 5. ·ª®ng d·ª•ng th·ª±c t·∫ø: ETL v√† Payment Pipeline

	ETL Pipelines:
		Trong pipeline data transformation:

		M·ªôt job c√≥ th·ªÉ fail ·ªü m·ªôt stage (v√≠ d·ª• parse JSON).
		D√πng Try ho·∫∑c Either ƒë·ªÉ fallback sang parsing ‚Äúlenient‚Äù mode.

	K·∫øt qu·∫£: pipeline v·∫´n ch·∫°y ti·∫øp, kh√¥ng crash to√†n b·ªô.


	## Payment Orchestration:
Try<PaymentResult> payment =
    Try.of(() -> stripe.charge(request))
       .recoverWith(() -> paypal.charge(request))
       .recoverWith(() -> square.charge(request));

	Ta c√≥ th·ªÉ chain v√¥ h·∫°n provider fallback.
	V√† to√†n b·ªô pipeline b·∫•t bi·∫øn, test d·ªÖ d√†ng:
		assertTrue(payment.isSuccess());

	Kh√¥ng c√≥ try/catch, kh√¥ng throw exception ‚Äî code pure functional.



# üß∞ 6. K·∫øt h·ª£p Try + Logging + Metrics
	B·∫°n c√≥ th·ªÉ k·∫øt h·ª£p log ho·∫∑c metrics m√† v·∫´n gi·ªØ functional purity:

Try.of(() -> stripe.charge(request))
   .peekSuccess(r -> metrics.increment("payment.success"))
   .peekFailure(e -> metrics.increment("payment.fail"))
   .recoverWith(() -> paypal.charge(request));

	‚Üí X·ª≠ l√Ω observability ngay trong pipeline, kh√¥ng ph√° v·ª° purity.


# üí° 7. So s√°nh v·ªõi c√°ch truy·ªÅn th·ªëng

| M√¥ h√¨nh     | Truy·ªÅn th·ªëng        | Functional Monad                         |
| ----------- | ------------------- | ---------------------------------------- |
| C·∫•u tr√∫c    | try/catch l·ªìng nhau | Chain `.recoverWith()`                   |
| Testability | Kh√≥ mock, throw     | Pure function, d·ªÖ test                   |
| Logging     | R·∫£i r√°c             | Centralized `.peekFailure()`             |
| Compose     | Kh√¥ng th·ªÉ           | `.map()`, `.flatMap()`, `.recoverWith()` |
| Readability | R·ªëi                 | R√µ pipeline                              |



# üîÆ 8. Tri·∫øt l√Ω cu·ªëi c√πng

Resilience th·∫≠t s·ª± kh√¥ng n·∫±m ·ªü framework, m√† n·∫±m ·ªü c√°ch b·∫°n t·ªï ch·ª©c lu·ªìng x·ª≠ l√Ω l·ªói m·ªôt c√°ch c√≥ ki·ªÉm so√°t.
Functional fallback cho ph√©p:

	C·∫•u tr√∫c l·ªói th√†nh d·ªØ li·ªáu.
	Compose logic nh∆∞ pipeline.
	Kh√¥ng r∆°i v√†o callback hell hay AOP magic.


</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>