<html><head><title>Lesson 154 == Stream performance tuning ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 154 -- Stream performance tuning -//</h1><pre>
	Trong h·ªá th·ªëng l·ªõn, Stream API c·ªßa Java l√† m·ªôt c√¥ng c·ª• r·∫•t m·∫°nh ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu, nh∆∞ng c≈©ng c√≥ th·ªÉ l√† nguy√™n nh√¢n g√¢y ra bottleneck n·∫øu kh√¥ng ƒë∆∞·ª£c tinh ch·ªânh ƒë√∫ng c√°ch. D∆∞·ªõi ƒë√¢y l√† ph√¢n t√≠ch chi ti·∫øt c·∫•p ƒë·ªô senior v·ªÅ Stream performance tuning k√®m theo c√°c g√≥c nh√¨n th·ª±c chi·∫øn:


# ‚öôÔ∏è 1. Hi·ªÉu r√µ b·∫£n ch·∫•t c·ªßa Stream

	Stream kh√¥ng l∆∞u tr·ªØ d·ªØ li·ªáu ‚Üí ch·ªâ l√† m·ªôt pipeline c·ªßa c√°c ph√©p bi·∫øn ƒë·ªïi (map, filter, flatMap, v.v.)
	
	Stream l√† lazy ‚Üí c√°c operations trung gian kh√¥ng th·ª±c hi·ªán cho ƒë·∫øn khi c√≥ terminal operation (collect, reduce, count, forEach,...).
	
	‚Üí ƒêi·ªÅu n√†y r·∫•t quan tr·ªçng: n·∫øu kh√¥ng c√≥ terminal operation ‚Üí Stream kh√¥ng l√†m g√¨ c·∫£.


# üöß 2. Tr√°nh c√°c l·ªói hi·ªáu nƒÉng ph·ªï bi·∫øn 

	## ‚ùå S·ª≠ d·ª•ng Stream sai ng·ªØ c·∫£nh 
List<String> result = list.stream()
    .filter(s -> s.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());


		N·∫øu danh s√°ch r·∫•t l·ªõn ‚Üí memory pressure tƒÉng nhanh n·∫øu kh√¥ng c√≥ short-circuiting.
		N·∫øu list l√† m·ªôt LinkedList, vi·ªác stream h√≥a s·∫Ω ch·∫≠m h∆°n ArrayList do random access y·∫øu.
		

	## ‚úÖ Khuy·∫øn ngh·ªã:

		Ch·ªâ d√πng Stream khi th·ª±c s·ª± c·∫ßn: d·ªØ li·ªáu l·ªõn + c·∫ßn pipeline h√≥a logic r√µ r√†ng.
		Tr√°nh d√πng Stream trong loop ho·∫∑c khi c·∫ßn logic ph·ª©c t·∫°p l·ªìng nhau nhi·ªÅu t·∫ßng.



# üß† 3. S·ª≠ d·ª•ng parallelStream m·ªôt c√°ch th√¥ng minh
	parallelStream() c√≥ th·ªÉ tƒÉng hi·ªáu nƒÉng‚Ä¶ ho·∫∑c gi·∫øt ch·∫øt performance n·∫øu d√πng sai.
	
	## Khi n√™n d√πng parallelStream(): 
		- D·ªØ li·ªáu l·ªõn (>10,000 ph·∫ßn t·ª≠).
		- M·ªói ph√©p bi·∫øn ƒë·ªïi ƒë·∫Øt ƒë·ªè (CPU-intensive).
		- M√°y c√≥ nhi·ªÅu core (ƒëa lu·ªìng hi·ªáu qu·∫£).


	## Khi kh√¥ng n√™n d√πng:

		D·ªØ li·ªáu nh·ªè.
		C√≥ thao t√°c I/O blocking.
		M·ªói ph·∫ßn t·ª≠ c·∫ßn truy c·∫≠p v√†o shared state (s·∫Ω g√¢y contention).

		‚ö†Ô∏è "Parallel is not always faster." ‚Äì Benchmark k·ªπ t·ª´ng t√¨nh hu·ªëng tr∆∞·ªõc khi tin t∆∞·ªüng n√≥.


# üìö 4. D√πng Collector custom ƒë·ªÉ gi·∫£m allocation
	Collector<T, ?, Map<K, List<T>>> customCollector = 
    Collectors.groupingBy(...);

	Nh·ªØng Collector m·∫∑c ƒë·ªãnh nh∆∞ groupingBy, partitioningBy c√≥ th·ªÉ g√¢y ra allocation th·ª´a ho·∫∑c boxing.

	## ‚úÖ T·∫°o custom Collector n·∫øu: 
		C·∫ßn pooling / reuse container.
		Mu·ªën optimize memory footprint.



# üîÑ 5. Tr√°nh c√°c map() th·ª´a ho·∫∑c .stream().stream() l·ªìng nhau

	V√≠ d·ª• t·ªá:

list.stream()
    .map(obj -> obj.getSubList().stream())
    .collect(Collectors.toList());

‚Üí Kh√¥ng t·∫°o ƒë∆∞·ª£c pipeline ƒë√∫ng, ho·∫∑c g√¢y ra v·∫•n ƒë·ªÅ boxing/unboxing khi x·ª≠ l√Ω primitive.

	‚úÖ D√πng flatMap n·∫øu mu·ªën flatten:
	
list.stream()
    .flatMap(obj -> obj.getSubList().stream())
    .collect(Collectors.toList());


# üß© 6. ∆Øu ti√™n primitive streams khi c√≥ th·ªÉ

IntStream.range(0, 1000000).sum();

Stream<Integer>.range(...).reduce(...)

	‚Üí Tr√°nh boxing/unboxing ‚Üí gi·∫£m GC pressure.



# üßµ 7. C·∫©n tr·ªçng v·ªõi stateful lambda v√† side effect

List<String> logs = new ArrayList<>();
list.stream()
    .filter(x -> {
        logs.add(x.toString());  // side effect
        return true;
    })
    .collect(Collectors.toList());


	‚Üí V·ª´a sai v·ªõi functional style, v·ª´a g√¢y race condition n·∫øu d√πng parallel stream.



# ‚úÖ T·ªïng k·∫øt: Nh·ªØng nguy√™n t·∫Øc Tuning c·∫•p ƒë·ªô Senior 


| K·ªπ thu·∫≠t                                         | M·ª•c ti√™u                             | L∆∞u √Ω                                  |
| ------------------------------------------------ | ------------------------------------ | -------------------------------------- |
| D√πng ƒë√∫ng lo·∫°i `Stream` (sequential vs parallel) | T·ªëi ∆∞u performance theo workload     | Benchmark c·∫©n th·∫≠n                     |
| Tr√°nh boxing                                     | Gi·∫£m GC & CPU overhead               | D√πng `IntStream`, `LongStream`...      |
| ∆Øu ti√™n `flatMap` thay cho stream l·ªìng           | Gi·∫£m nesting, d·ªÖ ƒë·ªçc                 | Tr√°nh `stream().stream()`              |
| Custom Collector                                 | Gi·∫£m allocation, tƒÉng t√≠nh linh ho·∫°t | Y√™u c·∫ßu hi·ªÉu s√¢u `Collector` interface |
| Tr√°nh `stateful lambda`                          | ƒê·∫£m b·∫£o purity                       | D·ªÖ g√¢y race condition                  |
| Kh√¥ng l·∫°m d·ª•ng stream                            | Khi logic ƒë∆°n gi·∫£n                   | `for` loop v·∫´n r·∫•t hi·ªáu qu·∫£            |



/===================== Reactive Streams (Project Reactor, RxJava) ===============

# üß† I. Reactive Streams l√† g√¨?
	Reactive Streams l√† m·ªôt chu·∫©n giao ti·∫øp b·∫•t ƒë·ªìng b·ªô, kh√¥ng ch·∫∑n (non-blocking), backpressure-aware ƒë·ªÉ x·ª≠ l√Ω d√≤ng d·ªØ li·ªáu (stream) kh√¥ng ƒë·ªìng b·ªô gi·ªØa c√°c th√†nh ph·∫ßn.
	
# 	‚öôÔ∏è 1. M·ª•c ti√™u c·ªßa Reactive Streams:
	
	- Asynchronous: x·ª≠ l√Ω d·ªØ li·ªáu kh√¥ng ƒë·ªìng b·ªô.
	- Non-blocking: kh√¥ng gi·ªØ thread ch·ªù d·ªØ li·ªáu.
	- Backpressure: ki·ªÉm so√°t t·ªëc ƒë·ªô ti√™u th·ª• d·ªØ li·ªáu, tr√°nh tr√†n b·ªô nh·ªõ.


# üì¶ II. Reactive Streams API chu·∫©n
	
public interface Publisher<T> {
    void subscribe(Subscriber<? super T> s);
}

public interface Subscriber<T> {
    void onSubscribe(Subscription s);
    void onNext(T t);
    void onError(Throwable t);
    void onComplete();
}

public interface Subscription {
    void request(long n);
    void cancel();
}

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {}


ƒê√¢y l√† specification g·ªëc. Project Reactor, RxJava, Akka Streams, Spring WebFlux... ƒë·ªÅu tu√¢n th·ªß chu·∫©n n√†y.


# ‚öôÔ∏è III. Project Reactor vs RxJava

| Kh√≠a c·∫°nh              | Project Reactor         | RxJava                                      |
| ---------------------- | ----------------------- | ------------------------------------------- |
| ƒê∆∞·ª£c ph√°t tri·ªÉn b·ªüi    | Pivotal / Spring Team   | Netflix                                     |
| Ph√π h·ª£p v·ªõi            | Spring WebFlux, Java 8+ | Android, general reactive                   |
| API ch√≠nh              | `Mono<T>`, `Flux<T>`    | `Single<T>`, `Observable<T>`, `Flowable<T>` |
| Backpressure           | Native                  | `Observable` kh√¥ng h·ªó tr·ª£, `Flowable` c√≥    |
| Chu·∫©n Reactive Streams | ‚úÖ                       | ‚úÖ (ch·ªâ `Flowable`)                          |
| S·ª≠ d·ª•ng ph·ªï bi·∫øn       | Backend, microservices  | Android, backend                            |

# üöÄ IV. C·∫•u tr√∫c c∆° b·∫£n

Flux<String> flux = Flux.just("A", "B", "C")
    .map(s -> s.toLowerCase())
    .filter(s -> !s.equals("b"))
    .doOnNext(System.out::println)
    .subscribe();

Flux<T> = stream nhi·ªÅu ph·∫ßn t·ª≠.

Mono<T> = stream duy nh·∫•t 1 ph·∫ßn t·ª≠ (ho·∫∑c kh√¥ng c√≥ g√¨).



	## RxJava: 
		
Observable<String> obs = Observable.just("A", "B", "C")
    .map(String::toLowerCase)
    .filter(s -> !s.equals("b"))
    .subscribe(System.out::println);


# üß© V. C√°c kh√°i ni·ªám Senior c·∫ßn n·∫Øm v·ªØng

	##1. Backpressure 
		Khi ngu·ªìn ph√°t (Publisher) t·∫°o d·ªØ li·ªáu qu√° nhanh, l√†m ngh·∫Ωn subscriber ‚Üí c·∫ßn ki·ªÉm so√°t.


		### RxJava: 
			Observable kh√¥ng h·ªó tr·ª£ ‚Üí d·ªÖ OOM.
			Flowable h·ªó tr·ª£ ‚Üí d√πng chi·∫øn l∆∞·ª£c nh∆∞ BUFFER, DROP, LATEST, ERROR.
			
Flowable.interval(1, TimeUnit.MILLISECONDS)
    .onBackpressureDrop()
    .observeOn(Schedulers.io())
    .subscribe(...);

		### Reactor: 
			Flux lu√¥n backpressure-aware.
			Subscriber d√πng request(n) ƒë·ªÉ l·∫•y s·ªë l∆∞·ª£ng d·ªØ li·ªáu mong mu·ªën.




	## 2. Operators ‚Äì Functional Style
	
	| Nh√≥m           | V√≠ d·ª•                                 |
| -------------- | ------------------------------------- |
| Transform      | `map`, `flatMap`, `concatMap`         |
| Filter         | `filter`, `take`, `skip`, `distinct`  |
| Combine        | `merge`, `zip`, `combineLatest`       |
| Error handling | `onErrorResume`, `retry`, `doOnError` |
| Terminal       | `subscribe`, `block`, `collectList`   |

		flatMap c√≥ th·ªÉ ph√°t t√°n b·∫•t ƒë·ªìng b·ªô, concatMap duy tr√¨ th·ª© t·ª±.
	
# 	3. Schedulers & Threading
	B·∫°n ph·∫£i ki·ªÉm so√°t lu·ªìng trong Reactive ƒë·ªÉ tr√°nh race condition.
	
Flux.just(1,2,3)
    .subscribeOn(Schedulers.boundedElastic())  // n∆°i emit
    .publishOn(Schedulers.parallel())          // n∆°i x·ª≠ l√Ω
    .map(i -> i * 2)
    .subscribe(System.out::println);
	
	subscribeOn: ƒë·ªãnh nghƒ©a thread b·∫Øt ƒë·∫ßu stream
	publishOn: chuy·ªÉn lu·ªìng ·ªü gi·ªØa pipeline
	
	
# üßµ VI. Reactive trong h·ªá th·ªëng l·ªõn

	##  ‚ö° Reactive vs Imperative 

| Imperative             | Reactive                               |
| ---------------------- | -------------------------------------- |
| Blocking               | Non-blocking                           |
| Nhi·ªÅu thread, ch·ªù ƒë·ª£i  | √çt thread, CPU hi·ªáu qu·∫£                |
| D·ªÖ hi·ªÉu                | Kh√≥ debug, c·∫ßn thi·∫øt k·∫ø l·∫°i            |
| T·ªët cho logic ƒë∆°n gi·∫£n | T·ªët cho API gateway, stream, websocket |



# ‚ò†Ô∏è Nh·ªØng l·ªói ch·∫øt ng∆∞·ªùi trong h·ªá th·ªëng reactive:

| L·ªói                               | H·∫≠u qu·∫£                        |
| --------------------------------- | ------------------------------ |
| Qu√™n x·ª≠ l√Ω backpressure           | Tr√†n b·ªô nh·ªõ, crash             |
| G·ªçi `.block()` trong WebFlux      | Ch·∫∑n event loop ‚Üí m·∫•t reactive |
| Side-effect trong `map()`         | D·ªÖ g√¢y bug kh√≥ trace           |
| D√πng `parallel()` kh√¥ng ki·ªÉm so√°t | Race condition, k·∫øt qu·∫£ sai    |
| Kh√¥ng monitor timeout/cancel      | Leak k·∫øt n·ªëi, queue ƒë·∫ßy        |



# üõ†Ô∏è VII. Spring WebFlux (d√πng Reactor)

@GetMapping("/users/{id}")
public Mono<User> getUser(@PathVariable String id) {
    return userService.getUserById(id); // Mono<User>
}

	WebFlux = non-blocking HTTP layer d·ª±a tr√™n Project Reactor
	Kh√¥ng c·∫ßn container threadpool nh∆∞ Tomcat truy·ªÅn th·ªëng


# ‚úÖ T·ªïng k·∫øt ‚Äì Senior checklist v·ªÅ Reactive

| C·∫ßn hi·ªÉu r√µ                               | Gi·∫£i th√≠ch                                   |
| ----------------------------------------- | -------------------------------------------- |
| `Publisher`, `Subscriber`, `Subscription` | Foundation c·ªßa reactive spec                 |
| `Mono`, `Flux`, `Flowable`, `Observable`  | T√≠nh ch·∫•t, ∆∞u nh∆∞·ª£c, khi n√†o d√πng            |
| Backpressure mechanics                    | Ki·ªÉm so√°t t·ªëc ƒë·ªô x·ª≠ l√Ω d·ªØ li·ªáu               |
| Hot vs Cold Publisher                     | Ph√¢n bi·ªát stream d·∫°ng n√≥ng/l·∫°nh              |
| Error propagation                         | `onErrorResume`, `retry`, `fallback`         |
| Scheduling model                          | Threading + Performance tuning               |
| Reactive vs Blocking                      | T∆∞ duy m·ªõi v·ªÅ h·ªá th·ªëng kh√¥ng thread-blocking |





</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>