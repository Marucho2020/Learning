<html><head><title>Lesson 208 == Functional Retry, Timeout, v√† Circuit Breaker Core ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 208 -- Functional Retry, Timeout, v√† Circuit Breaker Core -//</h1><pre>
# üß© T·ªïng quan: Resilience Functional l√† g√¨?


	Resilience trong h·ªá th·ªëng kh√¥ng ch·ªâ l√† ch·ªëng l·ªói, m√† l√† kh·∫£ nƒÉng duy tr√¨ logic nh·∫•t qu√°n khi l·ªói x·∫£y ra ‚Äî kh√¥ng m·∫•t d·ªØ li·ªáu, kh√¥ng crash, kh√¥ng l√†m user th·∫•y ‚Äúb·ªã l·ªói‚Äù.

	Trong functional style, resilience ƒë∆∞·ª£c vi·∫øt b·∫±ng Higher-Order Functions (HOF) ‚Äî t·ª©c l√† h√†m nh·∫≠n h√†m, tr·∫£ h√†m.



# ‚öôÔ∏è 1Ô∏è‚É£ Retry ‚Äî Functional Recursive Retry

	‚úÖ √ù t∆∞·ªüng
		Thay v√¨ try-catch + v√≤ng for, ta t·∫°o m·ªôt function b·ªçc quanh logic g·ªëc, c√≥ th·ªÉ retry n l·∫ßn n·∫øu l·ªói.
		
import java.util.function.Supplier;

public static <T> T withRetry(Supplier<T> fn, int retries) {
    try {
        return fn.get();
    } catch (Exception e) {
        if (retries > 0) {
            System.out.println("Retrying... attempts left: " + retries);
            return withRetry(fn, retries - 1);
        }
        throw e; // h·∫øt retries ‚Üí n√©m l·ªói ra
    }
}


	##üîç Gi·∫£i th√≠ch:  

		Supplier<T> ƒë·∫°i di·ªán cho logic ‚Äúc√≥ th·ªÉ th·∫•t b·∫°i‚Äù.
		
		Function withRetry l√† Higher-Order Function ‚Äî n√≥ kh√¥ng bi·∫øt logic b√™n trong l√† g√¨ (API call, DB query, hay g·ª≠i mail), ch·ªâ x·ª≠ l√Ω c√°ch retry.
		
		Kh√¥ng d√πng v√≤ng l·∫∑p hay state ngo√†i ‚Üí pure recursion.
		
		Functional ‚Üí c√≥ th·ªÉ compose v·ªõi withTimeout hay withCircuitBreaker.


	## üè¢ Enterprise: 

		Supplier<Response> callApi = () -> httpClient.post("/payment", payload);
		Response res = withRetry(callApi, 3);

	‚Üí Retry 3 l·∫ßn n·∫øu HTTP call l·ªói.
	Kh√¥ng c·∫ßn @Retryable, kh√¥ng ph·ª• thu·ªôc framework.



# ‚öôÔ∏è 2Ô∏è‚É£ Timeout ‚Äî CompletableFuture Timeout Wrapper

	# ‚úÖ √ù t∆∞·ªüng:
		N·∫øu m·ªôt function m·∫•t qu√° l√¢u, ta c·∫ßn gi·ªõi h·∫°n th·ªùi gian th·ª±c thi ‚Äî tr√°nh block thread ho·∫∑c treo pipeline.

import java.util.concurrent.*;

public static <T> T withTimeout(Supplier<T> fn, Duration timeout) {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<T> future = executor.submit(fn::get);
    try {
        return future.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
    } catch (TimeoutException e) {
        throw new RuntimeException("Operation timed out", e);
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        executor.shutdown();
    }
}



	CompletableFuture ho·∫∑c ExecutorService cho ph√©p gi·ªõi h·∫°n th·ªùi gian.
	Kh√¥ng block main thread.
	Functional v√¨: withTimeout ch·ªâ b·ªçc function, kh√¥ng can thi·ªáp logic b√™n trong.
	D·ªÖ compose:
		withRetry(() -> withTimeout(apiCall, Duration.ofSeconds(2)), 3);
	‚Üí Retry t·ªëi ƒëa 3 l·∫ßn, m·ªói l·∫ßn timeout 2 gi√¢y.



# ‚öôÔ∏è 3Ô∏è‚É£ Circuit Breaker ‚Äî Functional State Control

	‚úÖ √ù t∆∞·ªüng
		Khi service downstream l·ªói qu√° nhi·ªÅu ‚Üí ‚Äúng·∫Øt m·∫°ch‚Äù t·∫°m th·ªùi (open state), ƒë·ªÉ kh√¥ng l√†m h·ªá th·ªëng s·∫≠p d√¢y chuy·ªÅn.

import java.util.concurrent.atomic.AtomicReference;
import java.time.Instant;

enum State { CLOSED, OPEN, HALF_OPEN }

class CircuitBreaker {
    private final AtomicReference<State> state = new AtomicReference<>(State.CLOSED);
    private final int failureThreshold;
    private final Duration openDuration;
    private Instant lastFailureTime = Instant.MIN;

    CircuitBreaker(int failureThreshold, Duration openDuration) {
        this.failureThreshold = failureThreshold;
        this.openDuration = openDuration;
    }

    public <T> T call(Supplier<T> fn) {
        if (state.get() == State.OPEN && Instant.now().isBefore(lastFailureTime.plus(openDuration))) {
            throw new RuntimeException("Circuit is open");
        }

        try {
            T result = fn.get();
            state.set(State.CLOSED); // success ‚Üí reset
            return result;
        } catch (Exception e) {
            lastFailureTime = Instant.now();
            state.set(State.OPEN);
            throw new RuntimeException("Circuit opened", e);
        }
    }
}

	
	AtomicReference<State> ƒë·∫£m b·∫£o thread-safe m√† v·∫´n functional immutable style (copy-on-update).
	Kh√¥ng thay ƒë·ªïi fn b√™n trong, ch·ªâ bao quanh n√≥.
	C√≥ th·ªÉ k·∫øt h·ª£p withRetry v√† withTimeout:

CircuitBreaker breaker = new CircuitBreaker(3, Duration.ofSeconds(10));
Response res = breaker.call(() -> withRetry(() -> withTimeout(apiCall, Duration.ofSeconds(2)), 2));


# üîó T·ªïng h·ª£p: Composable Resilience Pipeline

Supplier<Response> resilientCall =
    () -> withRetry(
            () -> withTimeout(
                    () -> breaker.call(apiCall),
                    Duration.ofSeconds(2)),
            3);

Response res = resilientCall.get();


	Code pure functional ‚Äî kh√¥ng ph·ª• thu·ªôc Spring hay annotation.
	D·ªÖ test, d·ªÖ log, d·ªÖ compose.
	Gi·ªØ logic r√µ r√†ng: Retry ‚Üí Timeout ‚Üí Breaker ‚Üí API call.





# üè≠ ·ª®ng d·ª•ng Enterprise th·ª±c t·∫ø:

| T√¨nh hu·ªëng                     | Gi·∫£i ph√°p Functional   |
| ------------------------------ | ---------------------- |
| G·ªçi Payment API c√≥ th·ªÉ l·ªói t·∫°m | `withRetry()`          |
| Email server ch·∫≠m ph·∫£n h·ªìi     | `withTimeout()`        |
| External API s·∫≠p               | `withCircuitBreaker()` |
| H·ªá th·ªëng messaging             | Compose c·∫£ 3 function  |



	## Khi tri·ªÉn khai, c√≥ th·ªÉ d√πng functional DSL:
	
ResiliencePolicy policy = ResiliencePolicy
    .retry(3)
    .timeout(Duration.ofSeconds(2))
    .circuitBreaker(5, Duration.ofSeconds(10));

policy.apply(apiCall);




#üß† T∆∞ duy functional senior c·∫ßn nh·ªõ: 

	Resilience = composition of behaviors, kh√¥ng ph·∫£i ‚Äúannotation magic‚Äù.
	Functional resilience d·ªÖ ki·ªÉm th·ª≠ h∆°n v√¨ m·ªçi th·ª© l√† function ‚Üí test ƒë·ªôc l·∫≠p.
	B·∫°n c√≥ th·ªÉ implement l·∫°i 90% t√≠nh nƒÉng c·ªßa Resilience4j ch·ªâ b·∫±ng v√†i trƒÉm d√≤ng functional code.








</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>