<html><head><title>Lesson 182 == ConClass ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>🔙 Quay lại danh sách</a><br><h1>Lesson 182 -- ConClass -//</h1><pre>
#	Khái niệm 
 Trong Java, ConClass không phải là một từ khóa chính thức. Đây là cách gọi tắt (trong giáo trình ở Nhật hay các công ty Nhật) cho Concrete Class (具象クラス ).

	Concrete Class (具象クラス) = Lớp có thể được khởi tạo đối tượng (インスタンス化する, instantiate) trực tiếp.
	Nó khác với:
		Abstract Class (抽象クラス, chūshō classu): không thể new, chỉ dùng làm khuôn mẫu.
		
		Interface : chỉ định nghĩa hành vi (hợp đồng), không có implementation đầy đủ (từ Java 8+ có default & static method nhưng bản chất vẫn khác).


# 2. Đặc điểm của ConClass (Concrete Class)

	Có thể tạo instance (インスタンス化可能) trực tiếp bằng new.
	
	Cài đặt (実装, jissō) toàn bộ các method kế thừa từ abstract class hoặc interface.
	
	Có thể override (オーバーライド) các method của cha (親クラス, oyakurasu).
	
	Có thể kế thừa (継承) từ abstract class hoặc từ một concrete class khác.
	
	Có thể implement (実装する) nhiều interface.


abstract class Animal {  // 抽象クラス
    abstract void makeSound();
}

interface Pet {  // インターフェース
    void play();
}

// ConClass (具象クラス)
class Dog extends Animal implements Pet {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }

    @Override
    public void play() {
        System.out.println("Playing fetch!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog(); // インスタンス化できる
        d.makeSound();
        d.play();
    }
}


# 4. Mức Gold cần biết thêm gì?

	Design pattern sử dụng concrete class (ví dụ: Factory pattern → trả về concrete class từ abstract hoặc interface).

	Polymorphism (多態性, titaisei):
		Dùng reference kiểu abstract hoặc interface, nhưng thực tế trỏ đến concrete class.
		
		Câu hỏi Gold hay kiểm tra: List<String> list = new ArrayList<>(); → reference type khác với object type.

	Final class (final クラス):
		Một concrete class có thể được khai báo final, nghĩa là không thể kế thừa.
		Ví dụ: String là một final class trong Java.

	Sealed class (封印クラス, fūin classu) từ Java 17+ (chưa có trong SE11 exam, nhưng sau này nên biết).


</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>🔙 Quay lại danh sách</a><br><button onclick='toggleTheme()'>🌙 Chuyển giao diện</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>