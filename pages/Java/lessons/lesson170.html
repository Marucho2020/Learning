<html><head><title>Lesson 170 == Concurrency Design Patterns & Best Practices ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 170 -- Concurrency Design Patterns & Best Practices -//</h1><pre>
# 1. Immutable Objects 
	Nguy√™n t·∫Øc: Object kh√¥ng thay ƒë·ªïi sau khi kh·ªüi t·∫°o ‚Üí thread-safe ‚Äút·ª± nhi√™n‚Äù.
	L·ª£i √≠ch:
		Kh√¥ng c·∫ßn lock.
		D·ªÖ d√†ng share gi·ªØa threads.

final class User {
    private final String name;
    private final int age;
    public User(String name, int age) { this.name = name; this.age = age; }
    public String getName() { return name; }
    public int getAge() { return age; }
}

	Senior tip: Immutable + copy-on-write ‚Üí k·∫øt h·ª£p v·ªõi functional style cho thread-safe state.
	
	
# 2. Thread Confinemen	
	Gi·ªõi h·∫°n d·ªØ li·ªáu/objects cho m·ªôt thread ‚Üí kh√¥ng c·∫ßn lock.
	Types:	
		Stack confinement ‚Äì local variable ch·ªâ d√πng trong method/thread ‚Üí t·ª± thread-safe.
		ThreadLocal ‚Äì gi·ªØ state ri√™ng cho m·ªói thread, v√≠ d·ª• connection pool, date formatter.
		
		private static final ThreadLocal<SimpleDateFormat> df = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

		Pitfall senior: nh·ªõ remove() n·∫øu d√πng thread pool ‚Üí tr√°nh memory leak.
	
	
	
# 3. Thread Pool / Executor Pattern	
	
	Thay v√¨ new Thread():
		- Qu·∫£n l√Ω resource t·ªët h∆°n.
		- T√°i s·ª≠ d·ª•ng thread ‚Üí gi·∫£m overhead.	
	
	C√°c lo·∫°i Executor:
		- FixedThreadPool ‚Üí c·ªë ƒë·ªãnh, predictable.
		- CachedThreadPool ‚Üí dynamic, th√≠ch h·ª£p IO-bound.
		- ScheduledThreadPool ‚Üí ƒë·ªãnh k·ª≥.		
	
	Best practice: lu√¥n shutdown pool, tr√°nh leak threads.
		
	
	
# 4. Double-Checked Locking
	Pattern lazy init singleton thread-safe.

private volatile static Singleton instance;
public static Singleton getInstance() {
    if (instance == null) {
        synchronized(Singleton.class) {
            if (instance == null) instance = new Singleton();
        }
    }
    return instance;
}

	Key: volatile ƒë·ªÉ tr√°nh instruction reordering ‚Üí ƒë·∫£m b·∫£o instance fully constructed.


# 5. Blocking vs Non-blocking

	Blocking:
		synchronized, Lock, BlockingQueue.
		Thread ch·ªù ‚Üí t·ªën context switch.
		
	Non-blocking / lock-free:
		Atomic*, CAS, LongAdder, StampedLock (optimistic read).
		Th√≠ch h·ª£p low-latency, high concurrency.


# 6. Reactive / Event-driven patterns 

	D·ª±a tr√™n async event loops, kh√¥ng block thread.
	
	Java 9+: Flow API (Publisher/Subscriber).
	
	Ph√π h·ª£p IO-bound, s·ªë l∆∞·ª£ng thread √≠t nh∆∞ng x·ª≠ l√Ω nhi·ªÅu s·ª± ki·ªán.	


# 7. Livelock vs Deadlock 

	Deadlock: threads ch·ªù nhau ‚Üí block.
	
	Livelock: threads v·∫´n ch·∫°y, li√™n t·ª•c retry, nh∆∞ng kh√¥ng ti·∫øn tri·ªÉn.
	
	Senior tip:
	
		Detect patterns, d√πng tryLock(timeout), atomic per-key, ho·∫∑c design retry/backoff.



# 8. K·∫øt h·ª£p c√°c pattern


	Immutable + Thread confinement + Executor ‚Üí t·ªëi ∆∞u cho shared state minimal, d·ªÖ maintain.
	
	CAS / atomic + lock-free data structures ‚Üí high concurrency.
	
	BlockingQueue + thread pool ‚Üí producer-consumer pattern.
	
	Reactive + event loop ‚Üí IO-bound, low thread count.
	
	Double-checked locking ‚Üí singleton initialization.
	
	ThreadLocal ‚Üí state per-thread trong pool ‚Üí tr√°nh shared mutable state.
	
	
	
	
# 	9. Senior-level mindset 
	
	Always minimize shared mutable state ‚Üí immutable + confinement.
	
	Use high-level concurrency constructs first ‚Üí Executors, BlockingQueue, ForkJoin, Reactive.
	
	Avoid low-level wait/notify tr·ª´ khi vi·∫øt framework ho·∫∑c c·∫ßn t·ªëi ∆∞u.
	
	Detect deadlock/livelock early ‚Üí diagram locks and resources.
	
	Performance tuning ‚Üí balance thread count, task granularity, lock-free vs blocking.	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>