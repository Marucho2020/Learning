<html><head><title>Lesson 168 == Thread Communication ‚Äì wait/notify & Condition ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 168 -- Thread Communication ‚Äì wait/notify & Condition -//</h1><pre>
# 1. G·ªëc r·ªÖ: Monitor & Guarded Block 
	Java monitor = intrinsic lock + condition queue.
	
	Khi thread g·ªçi wait():
		- Nh·∫£ lock.
		- Chuy·ªÉn thread v√†o waiting queue (g·∫Øn v·ªõi monitor).

	Khi g·ªçi notify() ho·∫∑c notifyAll():
		- M·ªôt ho·∫∑c nhi·ªÅu thread ƒë∆∞·ª£c ƒë√°nh th·ª©c ‚Üí nh∆∞ng ch·ªâ ti·∫øp t·ª•c khi t√°i chi·∫øm lock.



	## üîπ Guarded block pattern (quan tr·ªçng ·ªü level senior): 
	
synchronized(lock) {
    while (!condition) {
        lock.wait();   // release lock, park thread
    }
    // do work khi condition th·ªèa m√£n
}
	
	 - D√πng while, kh√¥ng if ‚Üí ch·ªëng spurious wakeup (JVM c√≥ th·ªÉ wakeup m√† kh√¥ng c√≥ signal).
	 - ƒê√¢y l√† l√Ω do nhi·ªÅu junior code sai (d√πng if ‚Üí race).	
	
	
	
	
# 2. wait/notify pitfalls (senior insight)	
	
	Lost wakeup: 
		N·∫øu notify() g·ªçi tr∆∞·ªõc khi thread v√†o wait(), thread ƒë√≥ s·∫Ω m√£i ng·ªß.
		‚Üí C·∫ßn protocol ƒë·∫£m b·∫£o producer/consumer handshake ƒë√∫ng.	
	
	
	notify() vs notifyAll():
		- notify(): ch·ªâ ƒë√°nh th·ª©c 1 thread, c√≥ th·ªÉ g√¢y starvation n·∫øu nhi·ªÅu consumer ch·ªù.
		- notifyAll(): ƒë√°nh th·ª©c t·∫•t c·∫£ ‚Üí t·ªën context switch nh∆∞ng an to√†n h∆°n.	
	
	
	Deadlock risk: n·∫øu forgot while, ho·∫∑c signal sai lock, threads c√≥ th·ªÉ block vƒ©nh vi·ªÖn.
	


# 3. Condition ‚Äì gi·∫£i ph√°p hi·ªán ƒë·∫°i (java.util.concurrent.locks)


	T√°ch bi·ªát kh·ªèi intrinsic monitor.
	M·ªói Lock c√≥ th·ªÉ t·∫°o nhi·ªÅu Condition (ƒëa k√™nh ch·ªù), kh√°c v·ªõi intrinsic monitor ch·ªâ c√≥ 1 queue.

	API: 
		await() ~ wait()
		
		signal() ~ notify()
		
		signalAll() ~ notifyAll()


	## üîπ V√≠ d·ª• v·ªõi Condition: 

Lock lock = new ReentrantLock();
Condition notEmpty = lock.newCondition();
Queue<String> queue = new LinkedList<>();

public void put(String x) throws InterruptedException {
    lock.lock();
    try {
        queue.add(x);
        notEmpty.signal(); // ƒë√°nh th·ª©c consumer
    } finally {
        lock.unlock();
    }
}

public String take() throws InterruptedException {
    lock.lock();
    try {
        while (queue.isEmpty()) {
            notEmpty.await();  // release lock, wait
        }
        return queue.poll();
    } finally {
        lock.unlock();
    }
}


		∆Øu ƒëi·ªÉm:
		- C√≥ th·ªÉ c√≥ nhi·ªÅu condition ri√™ng (e.g. notEmpty, notFull) cho queue bounded.
		- Tr√°nh false wakeup handling ph·ª©c t·∫°p ‚Üí explicit v√† r√µ r√†ng h∆°n.


# 4. Producer-Consumer ‚Äì Case Study


	## V·ªõi wait/notify: 
		
synchronized (lock) {
    while (buffer.isEmpty()) lock.wait();
    item = buffer.remove();
    lock.notifyAll();
}


	## V·ªõi Condition (senior-preferred): 
	
while (buffer.isEmpty()) notEmpty.await();
item = buffer.remove();
notFull.signal();

	Code r√µ r√†ng h∆°n, ƒë·∫∑c bi·ªát khi c√≥ nhi·ªÅu condition kh√°c nhau (v√≠ d·ª•: notFull & notEmpty).



# 5. Trade-offs 

| Feature                  | wait/notify                   | Condition                              |
| ------------------------ | ----------------------------- | -------------------------------------- |
| Lock type                | Intrinsic (`synchronized`)    | Explicit (`Lock`)                      |
| Condition queues         | 1 queue duy nh·∫•t              | Nhi·ªÅu queue ƒë·ªôc l·∫≠p                    |
| Readability              | Ng·∫Øn g·ªçn                      | R√µ r√†ng, t∆∞·ªùng minh                    |
| Spurious wakeup handling | `while` b·∫Øt bu·ªôc              | `while` v·∫´n c·∫ßn                        |
| Control                  | √çt (notify c√≥ th·ªÉ l·∫°c target) | Ch√≠nh x√°c (ch·ªâ signal queue li√™n quan) |


# 6. Best Practices / Senior Tips 

	- Always use while loop khi await() ho·∫∑c wait() ‚Üí ch·ªëng spurious wakeup.
	- Prefer Condition n·∫øu c√≥ nhi·ªÅu t√¨nh hu·ªëng ch·ªù kh√°c nhau (multi-condition synchronization).
	- Avoid naked notify():
		+  N·∫øu uncertain, d√πng notifyAll().
	- notify() ch·ªâ an to√†n khi ch·∫Øc ch·∫Øn ch·ªâ c√≥ 1 nh√≥m thread ƒëang ch·ªù.
	- Document protocol r√µ r√†ng: thread n√†o signal khi n√†o, condition g√¨ c·∫ßn ki·ªÉm tra ‚Üí n·∫øu kh√¥ng, debug deadlock r·∫•t kh√≥.
	- Trong business-critical system, d√πng BlockingQueue thay v√¨ t·ª± vi·∫øt producer-consumer b·∫±ng wait/notify ‚Üí √≠t bug h∆°n, t·ªëi ∆∞u h∆°n.



# 7. T∆∞ duy Senior

	- wait/notify = low-level primitive, d·ªÖ bug ‚Üí ch·ªâ n√™n d√πng khi vi·∫øt framework ho·∫∑c c·∫ßn t·ªëi ∆∞u h√≥a ƒë·∫∑c bi·ªát.
	- Condition = mid-level abstraction ‚Üí explicit, d·ªÖ ƒë·ªçc, d·ªÖ maintain.
	- BlockingQueue / Exchanger / Semaphore = high-level constructs ‚Üí n√™n ∆∞u ti√™n khi gi·∫£i b√†i to√°n th·ª±c t·∫ø.
	- Khi debug v·∫•n ƒë·ªÅ multi-threading: ‚Äúthread kh√¥ng ch·∫°y c√≥ th·ªÉ kh√¥ng ph·∫£i do bug logic, m√† do lost signal / missed notify‚Äù ‚Üí ph·∫£i ph√¢n t√≠ch ƒë∆∞·ªùng ƒëi c·ªßa signal.



</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>