<html><head><title>Lesson 189 == Collectors n√¢ng cao ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 189 -- Collectors n√¢ng cao -//</h1><pre>
# 1. Collectors.toMap

	Bi·∫øn Stream th√†nh Map<K,V>.

Map<Integer, String> map = employees.stream()
    .collect(Collectors.toMap(Employee::getId, Employee::getName));


	‚ö†Ô∏è Senior point: ph·∫£i ƒë·ªÉ √Ω key collision („Ç≠„ÉºË°ùÁ™Å).
	N·∫øu 2 Employee c√πng id ‚Üí IllegalStateException.
	Gi·∫£i ph√°p: truy·ªÅn merge function:

toMap(Employee::getId, Employee::getName, (oldVal, newVal) -> oldVal)

ho·∫∑c ch·ªçn theo rule (newVal ghi ƒë√® oldVal, ho·∫∑c concat).


# 2. groupingBy

	Gi·ªëng SQL GROUP BY.
	Tr·∫£ v·ªÅ Map<K, List<T>> ho·∫∑c v·ªõi downstream collector ‚Üí Map<K, SomethingElse>.
	V√≠ d·ª•: group theo department, r·ªìi t√≠nh t·ªïng l∆∞∆°ng:

Map<String, Integer> salaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment,
             Collectors.summingInt(Employee::getSalary)));

‚ö†Ô∏è Senior point:

	groupingByConcurrent t·ªëi ∆∞u parallel stream.
	Downstream collector c√≥ th·ªÉ l·ªìng ‚Üí powerful nh∆∞ multi-level aggregation (Â§öÊÆµÈõÜÁ¥Ñ).



# 3. partitioningBy

	Special case c·ªßa groupingBy ‚Üí key l√† boolean.
	D√πng khi rule ch·ªâ c√≥ 2 tr·∫°ng th√°i (‰∫åÂàÜ).

Map<Boolean, List<Employee>> result =
    employees.stream().collect(Collectors.partitioningBy(e -> e.getSalary() > 1000));

	‚ö†Ô∏è D√πng partitioningBy thay v√¨ groupingBy khi ch·ªâ c·∫ßn true/false ƒë·ªÉ code clear.


# 4. joining

	Gom c√°c String th√†nh m·ªôt chu·ªói.
	joining(", ") = CSV output.

String csv = employees.stream()
    .map(Employee::getName)
    .collect(Collectors.joining(","));

‚ö†Ô∏è Senior point: joining c√≥ overload cho prefix/suffix, h·ªØu √≠ch khi xu·∫•t ra JSON-like string, CSV, log format.




# 5. reducing

	Collector th·∫•p nh·∫•t, gi·ªëng reduce() nh∆∞ng ƒë·ªÉ trong collect.
	D√πng khi mu·ªën full control.

	V√≠ d·ª• t√≠nh t·ªïng l∆∞∆°ng:

int total = employees.stream()
    .collect(Collectors.reducing(0, Employee::getSalary, Integer::sum));

	‚ö†Ô∏è Senior point: reducing linh ho·∫°t nh∆∞ng verbose. Th∆∞·ªùng thay b·∫±ng summingInt, counting‚Ä¶ cho readable. Nh∆∞ng bi·∫øt reducing l√† b·∫Øt bu·ªôc ·ªü level Gold, v√¨ n√≥ cho th·∫•y b·∫£n ch·∫•t "monoid accumulation" („É¢„Éé„Ç§„ÉâÁï≥„ÅøËæº„Åø).


# 6. Enterprise insight

	Trong enterprise system, Collectors = report generator.
		- groupingBy ‚Üí th·ªëng k√™ nh√¢n vi√™n theo ph√≤ng ban, status, role.
		- toMap ‚Üí build dictionary cache (id ‚Üí object).
		- joining ‚Üí t·∫°o CSV export.
		- reducing ‚Üí t√≠nh KPI, t·ªïng l∆∞∆°ng, max/min salary.

	‚ö†Ô∏è ·ªû level senior: lu√¥n nh·ªõ Collectors ‚âà SQL aggregation nh∆∞ng trong code. Ch·ªçn collector kh√¥ng ch·ªâ ƒë·ªÉ ra k·∫øt qu·∫£, m√† c√≤n ƒë·ªÉ code readable, maintainable, scalable.


	## üëâ T√≥m g·ªçn ki·ªÉu senior:

		toMap: key-value dictionary.
		groupingBy: SQL GROUP BY.
		partitioningBy: boolean split.
		joining: concat string.
		reducing: t·ªïng h·ª£p tu·ª≥ bi·∫øn, hi·ªÉu ƒë∆∞·ª£c monoid pattern.











</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>