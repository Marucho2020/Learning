<html><head><title>Lesson 25 == HashSet ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>🔙 Quay lại danh sách</a><br><h1>Lesson 25 -- HashSet -//</h1><pre># Khái niệm :

	Hash set là một lớp trong gói java.util dùng để lưu trữ một tập hợp các phần tử không trùng lặp. HashSet dựa trên bảng băm(hash table) để quản lý các phần tử 
	
	- Không cho phép phần tử trùng lạp: Mỗi phần tử trong HashSet là duy nhất 
	- Không đảm bảo thứ tự : Thứ tự chèn không được duy trì, vì Hashset sắp xếp phần tử dựa trên mã băm 
	- Cho phép phần tử null : Chỉ một giá trị duy nhất null được phép 
	- Hiệu suất cao : Các thao tác như thêm, xóa, kiểm tra thường có độ phức tạp trung bình là O(1)
	
# Cách sử dụng HashSet 
	## Khai báo và khởi tạo 
		HashSet<String> set = new HashSet<>();
		set.add("Java");
		System.out.println(set);
		

	# Một số phương thức quan trọng 
		add(E e)                    : Thêm phần tử e vào HashSet. Trả về true nếu thêm thành công. false nếu trùng lặp 
		remove(Object o)            : Xóa phần tử o , trả về true nếu xóa thành công 
		contains(Object o)          : Kiểm tra phần tử o có tồn tại trong HashSet hay không 
		size()                      : Trả về số lượng phần tử trong HashSet 
		isEmpty()                   : Kiểm tra HashSet có rỗng không 
		clear()                     : Xóa tất cả các phần tử trong HashSet 
		
		
# Cơ chế hoạt động của HashSet 
		
		
	## Dựa trên HashMap 
		- Nội bộ, HashSet được triển khai dựa trên một thể hiện của HashMap 
		- Với mỗi phần tử trong HashSet là một key trong HashMap, và giá trị value mặc định là một đối tượng const PRESENT 
		
	## Quy trình chèn phần tử 
		- Phần tử được đưa qua phương thức hashCode() để xác định chỉ số bucket trong mảng băm 
		- Nếu bucket không chứa phần tử nào có mã băm tương tự : 	
				-> thêm phần tử vào bucket 
		- Nếu có, sử dụng phương thức equals() để kiểm tra tính duy nhất 
			- Nếu bằng nhau, không thêm phần tử 
			- Nếu không bằng, thêm phần tử vào bucket dưới dạng danh sách liên kết 
		

# Ưu và nhược điểm của HashSet 
	## Ưu điểm 
		- Hiệu suất cao: Các thao tác cơ bản như thêm, xóa, tìm kiếm có độ phức tạp trung bình O(1)
		- Đảm bảo tính duy nhất của phần tử  
		
	## Nhược điểm 
		- Không duy trì thứ tự chèn : Nếu cần tự chèn, hãy dùng LinkedHashSet 
		- Hiệu suất giảm khi xảy ra xung đột băm: Nên đảm bảo hàm hashCode() và equals() được triển khai tốt. 
		
# HashSet nâng cao 
	## Custom HashSet với Comparator 
	- Sử dụng TreeSet nếu muốn lưu các phần tử được sắp xếp 
		TreeSet<Integer> set = new TreeSet<>((a , b) -> b -a);
		set.add(5); set.add(1);
		System.out.println(set) //[5,1]
		
	
	## Xử lý xung đột băm 
		Nếu hai phần tử có mã băm giống nhau, equals() sẽ quyết định chúng có được thêm hay không. Điều này rất quan trọng để giảm xung đột băm và tối ưu HashSet 
		
	## ConcurrentHashSet 
		- Nếu cần sử dụng HashSet trong môi trường đa luồng, bạn có thể dùng
			Collections.synchronizedSet() hoặc CopyOnWriteArraySet 
			
# Các câu hỏi ôn tập 
	
	## HashSet có đảm bảo thứ tự chèn không ? tại sao 
		- không, vì HashSet dựa trên bảng băm, và thứ tự phần tử phụ thuộc vào mã băm 
	## Điểm khác biệt giữa HashSet và TreeSet 
		HashSet : Không đảm bảo thứ tự, hiệu suất cao O(1)
		TreeSet : Sắp xếp các phần tử, hiệu suất thấp hơn O(log n);
	## Điều gì xảy ra khi triển khai sai hashCode và equals() 
		HashSet có thể chứa các phần tử trùng lặp vì không thể xác định tính duy nhất chính xác 
		
		
		
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>🔙 Quay lại danh sách</a><br><button onclick='toggleTheme()'>🌙 Chuyển giao diện</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>