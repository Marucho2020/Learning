<html><head><title>Lesson 167 == Thread-safe Collections & ConcurrentMap ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 167 -- Thread-safe Collections & ConcurrentMap -//</h1><pre>

# 1. V·∫•n ƒë·ªÅ c∆° b·∫£n
	Collection m·∫∑c ƒë·ªãnh (ArrayList, HashMap) ‚Üí kh√¥ng thread-safe.
	D√πng nhi·ªÅu thread ƒë·ªçc/ghi ‚Üí race condition, corruption, ho·∫∑c deadlock n·∫øu wrap b·∫±ng synchronized.
	
	Java cung c·∫•p:
		Legacy: Hashtable, Vector, Collections.synchronizedMap/List ‚Üí safe nh∆∞ng to√†n b·ªô lock, ch·∫≠m khi nhi·ªÅu thread.
		Modern: java.util.concurrent.* ‚Üí fine-grained lock / lock-free, performance cao.



# 2. ConcurrentHashMap

	## Nguy√™n l√Ω 
		Kh√¥ng lock to√†n b·ªô map m√† lock theo bucket / segment (Java 8+ d√πng CAS + bin lock + treeify):
		
		ƒê·ªçc g·∫ßn nh∆∞ kh√¥ng block (volatile read).
		Vi·∫øt:
			- CAS n·∫øu bucket r·ªóng.
			- N·∫øu collision ‚Üí lock bin/linked list/tree, tr√°nh lock global.

		Thread-safe nh∆∞ng performance c·ª±c t·ªët cho nhi·ªÅu reader, √≠t writer ‚Üí read-heavy workload.
		Iterators: weakly consistent, kh√¥ng throw ConcurrentModificationException.


	## V√≠ d·ª• n√¢ng cao
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.compute("key", (k, v) -> (v == null) ? 1 : v + 1); // atomic update

		- compute() ƒë·∫£m b·∫£o atomic per-key, tr√°nh race m√† kh√¥ng c·∫ßn external lock.
		- Kh√¥ng d√πng Hashtable n·ªØa ‚Üí qu√° n·∫∑ng, lock to√†n b·ªô map.

# 3. CopyOnWriteArrayList

	## D√πng khi read-heavy, write-hi·∫øm: 
		M·ªói write ‚Üí copy to√†n b·ªô array ‚Üí expensive.
		Read ‚Üí kh√¥ng c·∫ßn lock, iterator an to√†n.		

	## V√≠ d·ª• ph√π h·ª£p:
		Listener list, config snapshot, subscriber.
	
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A"); // copy underlying array
for (String s : list) { ... } // safe read, no lock
	
		Tip senior: n·∫øu update nhi·ªÅu ‚Üí tr√°nh CopyOnWriteArrayList v√¨ overhead, d√πng Collections.synchronizedList ho·∫∑c custom lock.
	
	
	
# 4. BlockingQueue	
	Thread-safe queue, blocking on empty/full, d√πng cho producer-consumer.	
	C√°c implement n·ªïi b·∫≠t:	
		ArrayBlockingQueue ‚Üí bounded, fair option.
		LinkedBlockingQueue ‚Üí unbounded ho·∫∑c bounded, performance t·ªët khi nhi·ªÅu producer/consumer.
		PriorityBlockingQueue ‚Üí queue theo priority.		
	
	Quan tr·ªçng: t·ª± ƒë·ªìng b·ªô + kh√¥ng c·∫ßn external lock, iterator l√† weakly consistent.
	
	
# 5. SynchronizedMap / SynchronizedList 

	Collections.synchronizedMap(new HashMap()) ‚Üí to√†n b·ªô access ƒë∆∞·ª£c lock.
	Iteration v·∫´n c·∫ßn external lock:

Map<K,V> syncMap = Collections.synchronizedMap(new HashMap<>());
synchronized(syncMap) {
    for (Map.Entry<K,V> e : syncMap.entrySet()) { ... }
}

	Nh∆∞·ª£c ƒëi·ªÉm:
		- Lock to√†n b·ªô map ‚Üí performance k√©m.
		- Kh√¥ng ph√¢n ƒëo·∫°n fine-grained.


# 6. Best Practices / Senior Tips 

	- D√πng ConcurrentHashMap cho map ƒëa thread, t·∫≠n d·ª•ng computeIfAbsent, merge, putIfAbsent.
	- CopyOnWriteArrayList ‚Üí read-heavy, write-hi·∫øm.
	- Avoid legacy synchronized collections (Hashtable, Vector, SynchronizedMap) ‚Üí performance k√©m.
	- Atomic updates per key ‚Üí tr√°nh external locks.
	- Beware weakly consistent iterators:
	- Iteration kh√¥ng throw CME nh∆∞ng kh√¥ng nh·∫•t thi·∫øt snapshot to√†n b·ªô map t·∫°i 1 th·ªùi ƒëi·ªÉm.
	- BlockingQueue ‚Üí producer-consumer pattern, kh√¥ng d√πng wait/notify th·ªß c√¥ng n·ªØa.


# 7. K·∫øt h·ª£p senior-level

	## Hi·ªÉu performance trade-off: 
		- ConcurrentHashMap ‚Üí high throughput, low latency.
		- SynchronizedMap ‚Üí d·ªÖ code, nh∆∞ng bottleneck.
		- CopyOnWriteArrayList ‚Üí read-mostly ‚Üí lock-free reads.

	Bi·∫øt pattern atomic per-key + compute ‚Üí tr√°nh race condition, deadlock, lock contention.

	Lu√¥n nghƒ© iteration weakly consistent, thread c√≥ th·ªÉ ƒë·ªçc gi√° tr·ªã ‚Äúc≈©‚Äù ho·∫∑c ‚Äúm·ªõi‚Äù trong qu√° tr√¨nh duy·ªát.
	
	
	


</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>