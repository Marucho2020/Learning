<html><head><title>Lesson 123 == Lazy Propagation ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 123 -- Lazy Propagation -//</h1><pre>
# Kh√°i ni·ªám 

Lazy Propagation l√† m·ªôt k·ªπ thu·∫≠t t·ªëi ∆∞u h√≥a cho c√°c c·∫•u tr√∫c d·ªØ li·ªáu ph√¢n ƒëo·∫°n (nh∆∞ Segment Tree, Interval Tree‚Ä¶), gi√∫p tr√¨ ho√£n (delay) c·∫≠p nh·∫≠t ƒë·∫øn khi th·∫≠t s·ª± c·∫ßn thi·∫øt
	üí° Thay v√¨ c·∫≠p nh·∫≠t ngay t·∫•t c·∫£ c√°c node b·ªã ·∫£nh h∆∞·ªüng b·ªüi m·ªôt thao t√°c, ta ƒë√°nh d·∫•u r·∫±ng n√≥ s·∫Ω c·∫ßn c·∫≠p nh·∫≠t sau ‚Äî v√† ch·ªâ th·ª±c hi·ªán khi ph·∫£i truy v·∫•n ch√≠nh x√°c v√†o v√πng ƒë√≥.
	
	
	
# üî• 2. T·∫°i sao ph·∫£i d√πng Lazy Propagation? 

	B√†i to√°n v√≠ d·ª•: C·∫≠p nh·∫≠t c·ªông th√™m 5 v√†o ƒëo·∫°n [l, r] v√† sau ƒë√≥ query t·ªïng ƒëo·∫°n [a, b].
	N·∫øu d√πng Segment Tree th∆∞·ªùng, b·∫°n ph·∫£i c·∫≠p nh·∫≠t O(log n) node v√† c√°c node con b√™n d∆∞·ªõi n·ªØa ‚Üí t·ªën c√¥ng d√π ch∆∞a ch·∫Øc c·∫ßn d√πng ƒë·∫øn. 
	V·ªõi Lazy Propagation, b·∫°n ƒë√°nh d·∫•u node n√†o ‚Äún·ª£‚Äù c·∫≠p nh·∫≠t, v√† ch·ªâ x·ª≠ l√Ω th·∫≠t s·ª± khi bu·ªôc ph·∫£i ƒëi s√¢u xu·ªëng truy v·∫•n.
	‚úÖ Gi·∫£m ƒë·ªô ph·ª©c t·∫°p t·ª´ O(n) v·ªÅ O(log n) trong c√°c tr∆∞·ªùng h·ª£p update ƒëo·∫°n l·ªõn m√† query nh·ªè.
	
	
	
# üß† 3. √Åp d·ª•ng ·ªü ƒë√¢u?

	Memory-efficient real-time systems.
	Analytics engine ghi log theo th·ªùi gian (query nhanh, update ch·∫≠m).
	H·ªá th·ªëng c√≥ c·∫≠p nh·∫≠t h√†ng lo·∫°t (batch update) v√† truy v·∫•n c·ª•c b·ªô.
	Distributed computing (ch·∫≠m propagation gi·ªØa node v√¨ t·ªëi ∆∞u traffic).


# ‚öôÔ∏è 4. Nguy√™n l√Ω ho·∫°t ƒë·ªông 
	
	Khi c·∫≠p nh·∫≠t m·ªôt kho·∫£ng [l, r]:
	N·∫øu node hi·ªán t·∫°i n·∫±m ho√†n to√†n trong [l, r] ‚Üí c·∫≠p nh·∫≠t node hi·ªán t·∫°i v√† ƒë√°nh d·∫•u c√°c con l√† "dirty" (n·ª£ c·∫≠p nh·∫≠t).
	N·∫øu ch·ªâ giao m·ªôt ph·∫ßn ‚Üí ƒê·∫©y lazy update t·ª´ cha xu·ªëng con (propagate) tr∆∞·ªõc khi ti·∫øp t·ª•c.
	N·∫øu n·∫±m ngo√†i ƒëo·∫°n ‚Üí b·ªè qua.


# üìê 5. C·∫•u tr√∫c Segment Tree v·ªõi Lazy Propagation 

class SegmentTree {
    int[] tree;
    int[] lazy;
    int n;

    public SegmentTree(int size) {
        n = size;
        tree = new int[4 * n];
        lazy = new int[4 * n];
    }

    void updateRange(int l, int r, int val) {
        update(1, 0, n - 1, l, r, val);
    }

    int queryRange(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }

    private void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += (end - start + 1) * lazy[node]; // C·∫≠p nh·∫≠t gi√° tr·ªã
            if (start != end) {
                lazy[node * 2] += lazy[node];     // G√°n lazy cho con tr√°i
                lazy[node * 2 + 1] += lazy[node]; // G√°n lazy cho con ph·∫£i
            }
            lazy[node] = 0; // Clear lazy
        }
    }

    private void update(int node, int start, int end, int l, int r, int val) {
        propagate(node, start, end);
        if (r < start || end < l) return;

        if (l <= start && end <= r) {
            lazy[node] += val;
            propagate(node, start, end);
            return;
        }

        int mid = (start + end) / 2;
        update(node * 2, start, mid, l, r, val);
        update(node * 2 + 1, mid + 1, end, l, r, val);
        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }

    private int query(int node, int start, int end, int l, int r) {
        propagate(node, start, end);
        if (r < start || end < l) return 0;

        if (l <= start && end <= r) return tree[node];

        int mid = (start + end) / 2;
        return query(node * 2, start, mid, l, r) +
               query(node * 2 + 1, mid + 1, end, l, r);
    }
}


# üìä 6. Ph√¢n t√≠ch th·ªùi gian
| Operation     | With Lazy Propagation |
| ------------- | --------------------- |
| `updateRange` | O(log n)              |
| `queryRange`  | O(log n)              |
| `build tree`  | O(n)                  |



# üß© 7. M·ªü r·ªông & k·∫øt h·ª£p th·ª±c t·∫ø 


| M√¥ h√¨nh ·ª©ng d·ª•ng        | Lazy Propagation bi·∫øn th·ªÉ                                        |
| ----------------------- | ---------------------------------------------------------------- |
| Game map update         | C·∫≠p nh·∫≠t s·ª©c m·∫°nh v√πng AOE nh∆∞ng ch·ªâ khi qu√°i v√†o v√πng ƒë√≥        |
| Event sourcing          | C·∫≠p nh·∫≠t tr·∫°ng th√°i theo batch, ch·ªâ x·ª≠ l√Ω khi user truy c·∫≠p      |
| Inverted Index (search) | Update t·ª´ kh√≥a theo nh√≥m document, query th√¨ m·ªõi ghi ng∆∞·ª£c xu·ªëng |
| Distributed simulation  | Tr√¨ ho√£n ƒë·ªìng b·ªô tr·∫°ng th√°i gi·ªØa c√°c node                        |


# üß† 8. Ki·∫øn th·ª©c n·ªÅn t·∫£ng c·∫ßn h·ªçc ƒë·ªÉ hi·ªÉu & t·ªëi ∆∞u Lazy Propagation

| Ch·ªß ƒë·ªÅ                       | L√Ω do                                                      |
| ---------------------------- | ---------------------------------------------------------- |
| Segment Tree / Interval Tree | C·∫•u tr√∫c n·ªÅn t·∫£ng                                          |
| Recursion n√¢ng cao           | G·ªçi h√†m ƒë·ªá quy kh√¥ng stack overflow                        |
| Java memory model            | ƒê·∫£m b·∫£o consistency n·∫øu d√πng trong multi-thread env        |
| Persistent data structures   | Lazy Propagation k·∫øt h·ª£p v·ªõi snapshot ƒë·ªÉ rollback          |
| Concurrency (advanced)       | N·∫øu tree l√† shared resource trong multi-thread environment |




</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>