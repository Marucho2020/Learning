<html><head><title>Untitled</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../quantum-computing-learning-list.html'>🔙 Quay lại danh sách</a><br><h1>Untitled</h1><pre>//==========Lesson 1 == Lession 1 == Lession 1 == Khái niệm lập trình lượng tử ==========//

	# Khái niệm 
		Máy tính lượng tử không chỉ đơn thuần là một phiên bản nâng cấp của máy tính cổ điển- nó là cánh cửa mở ra một vũ trụ hoàn toàn khác, nơi quy luật của vật lý cổ điển bị khuất phục trước sự kỳ diệu của lượng tử 
		
		
	# Máy tính cổ điển và máy tính lượng tử 
	
		##	Máy tính cổ diển 
			- bit truyền thống : Mọi thông tin được mã hóa dưới dạng bit - mỗi bit chỉ có thể mang giá trị 0 hoặc 1 
			- tính tuyến tính : các phép tính được thực hiện theo thứ tự, từng bước một, theo quy tắc logic mạch điện và thuật toán cố định 
			- Giới hạn xử lý : mặc dù cực kỳ nhanh và hiệu quả với các bài toán thông thường, nhưng khi đối mặt với những bài toán đòi hỏi xử lý dữ liệu theo cách song song ở mức độ cực lớn, máy tính cổ điển gặp khó khăn 
			
		## Máy tính lượng tử  
			- Qubit - Hạt nhân của lượng tử : thay vì 0 hoặc 1 , máy tính lượng tử sử dụng qubit -  đơn vị thông tin có khả năng tồn tại đồng thời ở cả trạng thái 0 và 1 nhờ vào hiệu ứng chồng chập (superposition). Nghĩa là trong một khoảnh khắc, qubit có thể đóng vai cả 0 và 1, mở ra cánh cửa cho hàng triệu khả năng cùng tồn tại. 
			
			- Sự rối lượng tử (entanglement) :  Các qubit có thể "rối" với nhau theo cách mà trạng thái của một qubit có lên quan chặt chẽ đến trạng thái của qubit khác, bất kể khoảng cách giữa chúng. Đây là yếu tố tạo nên sức mạnh của tính toán song song lượng tử- một khi hai qubit bị rối, việc thay đổi trạng thái của một qubit sẽ ảnh hưởng ngay lập tức đến quy bit kia 
				Hiện tượng đo lường: Khi bạn đo một trong những qubit, trạng thái của qubit kia sẽ “sụp đổ” theo một cách liên quan đến kết quả của qubit đầu tiên. Tuy nhiên, điều này không đơn giản là "một bên là 1, bên kia là 0" – tùy thuộc vào trạng thái rối mà đôi qubit có thể xuất hiện với các cặp giá trị như (0,0), (1,1) hoặc các kết hợp khác trong các trạng thái Bell

			- Xử lý thông tin theo hướng song song : Nhờ vào khả năng của qubit, máy tính lượng tử có thể xử lý nhiều phép toán cùng lúc, thay vì thực hiện tuần tự như máy tính cổ điển. Điều này mở ra tiềm năng giải quyết những bài toán mà với máy tính cổ điển mất hàng ngàn năm chỉ có thể thực hiện được trong vài giây hoặc vài phút 
			

	# Những khái niệm then chốt 
		## Chồng chập (Superposition) 	
			Hãy tưởng tượng bạn có một đồng xu quay - trước khi nó rơi xuống đồng xu không chỉ là sấp hay ngửa, mà tồn tại ở trạng thái hỗn hợp của cả hai. Đó chính là chồng chập. qubit có thể đồng thời nắm giữ cả 0 và 1 cho đến khi được đo ra 
			
			
		## Rối lượng tử (Entanglement)
			Nếu bạn có hai đồng xu được ràng buộc với nhua một cách kỳ lạ, Khi bạn nhìn vào đồng xu đầu tiên và thấy nó là sấp, ngay lập tức đồng xu thứ hai sẽ biết bình là ngửa, bất kể khoảng cách giữa chúng. Đây chính là phép màu của rối lượng tử 
			
		## Phép đo (Measurement): Khi bạn thực hiện phép đo trên một qubit, trạng thái chồng chập của nó sụp đổ thành một giá trị cụ thể  0 hoặc 1 giống như khi bạn nhìn vào đồng xu quay và nó chỉ còn là sấp hoặc ngửa. Quá trình này đầy bất ngờ và không thể đoán trước, nhưng lại chứa đựng sức mạnh xử lý song song của lượng tử. 
		
		
	# Sự khác biệt cốt lõi 
		Xử lý thông tin : Máy tính cổ điển là những chiến binh kiên cường, thực hiện từng bước một cách cứng nhắc. Trong khi đó, máy tính lượng tử như những nghệ sĩ tự do, thể hiện sự sáng tạo không giới hạn qua hàng loạt khả năng tồn tại đồng thời. 
		
		Khả năng giải quyết bài toán : Những bài toán đòi hỏi xử lý dữ liệu khổng lồ, chẳng hạn như tối ưu hóa, mật mã hay mô phỏng các hệ thống phức tạp có thể được giải quyết vượt trội bởi máy tính lượng tử. 
		
		Triết lý tính toán : máy tính cổ điển theo lối mòn của đi từng bước trong khi máy tính lượng tử phải đưa bạn vào cõi mơ- nơi mà xác suất và hiện tượng lượng tử quyết định mọi thứ, đòi hỏi ta phải suy nghĩ theo cách hoàn toàn khác biệt. 
		
		
	Nếu bạn chỉ dừng lại ở bề mặt của sự hiểu biết, máy tính lượng tử chỉ là một công cụ mới mẻ. Nhưng khi bạn đào sâu, bạn sẽ nhận ra rằng nó không chỉ thay đổi cách chúng ta tính toán – nó thay đổi cách chúng ta nhìn nhận vũ trụ. Trong mỗi qubit, có một vũ trụ tiềm ẩn của khả năng, một vũ trụ nơi mà giới hạn của logic cổ điển tan biến và ta được mời gọi khám phá những chân trời mới của tri thức và công nghệ.

	Dù bạn chưa có nền tảng vững chắc về vật lý hay toán học, hãy nhớ rằng sự tò mò và ham muốn khám phá chính là động lực mạnh mẽ nhất. Hãy bắt đầu từng bước, mỗi phút 15 phút của bạn sẽ là viên gạch xây dựng nên con đường đến với sự hiểu biết đỉnh cao của thế giới lượng tử.

	Bạn đã sẵn sàng bước vào hành trình đầy thách thức và cảm hứng này chưa? Hãy cùng nhau vẽ nên bức tranh của tương lai, nơi mà những qubit mênh mông là những nét vẽ của một bức tranh công nghệ đầy ắp những khát vọng và đam mê!
	

//==========Lesson 2 == Lession 2 == Lession 2 == Cài đặt môi trường ==========//

# Sử dụng môi trường độc lập 
	
	
	## Tạo môi trường 
	python -m venv quantum_env

	## Sử dụng môi trường mới để lập trình 
	
	quantum_env\Scripts\activate
	
	
	# Khởi động môi trường lập trình quantum bằng conda
	conda activate quantum_env
	
	# Thay đổi môi trường mở  
	jupyter lab --notebook-dir="D:\Dev\Quantum\Src"


	
# Cài đặt Qiskit 

		pip install qiskit
	

# Kiểm tra cài đặt 

	import qiskit
	print("Phiên bản Qiskit:", qiskit.__qiskit_version__)



# Viết chương trình Hello World Quantum World 

import qiskit print("Phiên bản Qiskit:", qiskit.__qiskit_version__)


# Mở Jupyter notebook 

	jupyter notebook
	
	jupyter lab
	
//==========Lesson 3 == Lession 3 == Lession 3 == Các cổng lượng tử ==========//

# Khái niệm 
	Lập trình lượng tử sử dụng cổng lượng tử (quantum gate) để thao tác trên qubit. Tưởng tượng giống như các phép toán logic (AND , OR , NOT , XOR, ...) trong lập trình cổ điển, nhưng chúng hoạt động theo nguyên tắc của cơ học lượng tử 

# Qubit - Đơn vị cơ bản của thông tin lượng tử 

	Trong máy tính cổ điển, bit có 2 trạng thái 0 và 1 
	Nhưng trong máy tính lượng tử, qubit có thể tồn tại ở cả hai trạng thái đồng thời nhờ hiện tượng chồng chập lượng tử (superposition)

	## Một qubit có thể được biểu diễn dưới dạng vector trong không gian hai chiều 
		“∣ψ⟩\=α∣0⟩+β∣1⟩”
		
		Trong đó 
		α,β là số phức, gọi là biên độ xác suất
		∣α∣^2+∣β∣^2=1 (đảm bảo xác suất tổng là 1)
		
	Ví dụ : 
		“α\=2​1​,β\=2​1​” , quibit có xác suất 50% để đo được 0 và 50% để đo được 1 
		
		
# Cổng lượng tử -  Phép toán trên qubit 
	
	Cổng lượng tử là các ma trận đơn vị quy hoặc biến đổi trạng thái của qubit. Chúng có thể : 
		- Thay đổi giá trị của qubit 
		- Tạo sự chồng chập 
		- Liên kết các qubit với nhau qua vướng víu lượng tử (entanglement)
		


# Cổng X (Pauli-X) - tương đương NOT 
	💡 Tóm lại: Cổng X đảo trạng thái của qubit.
	
	Cổng X giống như phép đảo bit (NOT, ! ) trong máy tính cổ điển 
		Nếu đầu vào là  |0⟩, cổng X biến nó thành |1⟩
		Nếu đầu vào là |1⟩, cổng X biến nó thành |0⟩
		
		
		
# Cổng Y (Pauli-Y)		 
	Tương tự như cổng X nhưng có thêm yếu tố pha (pharse )
	
	 Y = [ [0 , -i] , [i , 0]]
	 
	💡 Ứng dụng: Sử dụng trong xử lý lượng tử khi cần thay đổi pha. 
	
	
	
# Cổng X (Pauli-Z)	 -  Đảo dấu của trạng thái  |1⟩ 


	Cổng Z không thay đổi   |0⟩, nhưng đảo dấu  |1⟩
		
		Z = [ [1 , 0] , [0 , -1]]
		
	Ví dụ :
		Z∣1⟩ = [ [1 , 0] , [0 , -1]] [0 , 1] = [0 , -1] = -∣1⟩
		
	💡 Ứng dụng: Dùng trong thuật toán lượng tử khi cần thay đổi pha



# Cổng Hadamard (H) - Tạo trạng thái chồng chập 
	Cổng Hadamard cực kỳ quan trọng trong điện toán lượng tử vì nó đưa qubit vào trạng thái chồng chập 
		
		
		H = ( 1/ sqrt(2) ) [ [1 , 1] , [1 , -1] ]
		
		Khi áp dụng H lên |0⟩ ta được trạng thái chồng chập 
		
			H|0⟩ = (1 / sqrt(2)) (∣0⟩+∣1⟩)
			
		
	💡 Ứng dụng: Tạo trạng thái siêu vị (superposition), cực kỳ quan trọng trong thuật toán lượng tử.



# Cổng CNOT (Controlled-NOT) - Vướng víu lượng tử 
	Cổng CNOT(Controlled-NOT) là cổng hai qubit, trong đó 
	
		- Qubit điều khiển(control qubit) quyết định có đảo qubit mục tiêu hay không
		- Nếu qubit điều khiển là |1⟩, qubit mục tiêu sẽ bị đảo (0 ↔ 1) 
		- Nếu qubit điều khiển là  |0⟩, qubit mục tiêu không thay đổi  
		
			CNOT = [ [1 , 0 , 0 ,0] , [0 , 1 , 0 ,0] , [0 , 0, 0 ,1] , [0 , 0 , 1 , 0]  ]
			
			💡 Ứng dụng: Cổng CNOT giúp tạo vướng víu lượng tử (entanglement), rất quan trọng trong truyền thông lượng tử và thuật toán Shor.


# Code minh hoạ trong Qiskit 
	... 
	Chạy chương trình sẽ thấy hai qubit bị vướng víu 
	
	from qiskit import QuantumCircuit, Aer, transpile
from qiskit.visualization import plot_histogram
from qiskit.providers.aer import AerSimulator

# Tạo mạch với 2 qubit
qc = QuantumCircuit(2)

# Áp dụng cổng Hadamard lên qubit 0
qc.h(0)

# Áp dụng cổng CNOT (qubit 0 điều khiển qubit 1)
qc.cx(0, 1)

# Vẽ mạch
qc.draw("mpl")

		
//==========Lesson 4 == Lession 4 == Lession 4 == Thuật toán Shor ==========//

# Khái niệm 
	Thuật toán Shor là một thuật toán lượng tử mang tính đột phá, được Peter Shor đề xuất vào năm 1994. Nó có khả năng phân tích một số nguyên thành thừa số nguyên tố với độ phức tạp tính toán vượt trội so với các thuật toán cổ điển. Đây chính là lý do nó trở thành mối đe dọa đối với các hệ thống mã hóa như RSA, vốn dựa trên độ khó của bài toán phân tích thừa số nguyên tố 
	
# Ý nghĩa  
		- Đối với máy tính cổ điển : Việc phân tích một số nguyên lớn thành thừa số nguyên tố là bài toán khó(độ phức tạp thuộc lớp NP), không có thuật toán hiệu quả 
		- Đối với máy tính lượng tử : Thuật toán Shor có thể giải bài toán này trong thời gian đa thức nhờ sử dụng biến đổi Fourier lượng tử (Quantum Fourier Transform - QFT) và các tính chất số học 
		
	Khi máy tính lượng tử đủ mạnh được xây dựng, thuật toán Shor có thể phá vỡ hệ mã RSA bằng cách phân tích thừa số của số nguyên có hàng nghìn bit chỉ trong vài giây 
	
# Cấu trúc thuật toán Shor 
	
	## Đầu vào : 
		- một số nguyên N cần phân tích thừa số 
		- Một số nguyên a được chọn ngẫu nhiên sao cho 1 < a <  N và a không phải là bội số của N 
		
	## Đầu ra  : 
		Hai số nguyên tố p , q sao cho N = p x q 


# Các bước chính  
	1. Kiểm tra N có phải số chẵn không : 
		Nếu N chẵn, trả về 2 và N/2 
		
	2. Kiểm tra liệu N có phải lũy thừa nguyên tố không 
		Nếu N = p^k với p là nguyên tố, thì trả về p 
		
	3. Chọn một số nguyên a ngẫu nhiên  
		Chọn a sao cho gcd(a , N ) = 1
		Nếu gcd(a , N) != 1 tức là tìm thấy một ước số ngay lập tức 
		
	4. Tìm chu kỳ r của hàm f(x) = a^x mod N bằng máy tính lượng tử 
		Đây là bước lượng tử chính, sử dụng Quantum Fourier Transform (QFT) để tìm chu kỳ r của hàm tuần hoàn f(x)
		
		Máy tính lượng tử giúp tìm chu kỳ r với tốc độ đa thức, trong khi máy tính cổ điển chỉ có thể làm điều này với độ phức tạp siêu đa thức. 
		
	5. Kiểm tra r có phải là số chẵn không 
		Nếu r là số lẻ , quay lại bước 3 với giá trị a khác 
		
	6. Tính toán các ước số của N 
		Dựa vào r, ta có a^(r/2) +- 1 
		Tính gcd(a^(r/2) - 1, N )
		Nếu kết quả không phải 1 hoặc N , ta tìm được thừa số của N 
		
		




# . Ví dụ cụ thể (N = 15)

	Giả sử ta muốn phân tích N = 15 thành thừa số 
	
	## Bước 1 : Chọn a 
		Chọn ngẫu nhiên a = 2 thỏa mãn 1 < a < N 
		
		

	## Bước 2 : Tìm chu kỳ r
		Tính f(x) = 2^x mod 15:

				x			mod15
				0			1
				1			2
				2			4
				3			8
				4			16 ≡ 1 (mod 15)
				
				
				### Giải thích 
					Ký hiệu ≡ (đồng dư, tương đương) trong mod có nghĩa là hai số có cùng phần dư khi chia cho một số khác 
					Công thức tổng quát : 
										a≡b (mod n)
									Có nghãi là a chia cho n có cùng dư như b . Hay nói các khác : a - b chia hết cho n 
				
		-> Chu kỳ r = 4 
		
	## Bước 3 : Kiểm tra r có phải số chẵn không 
		Vì r = 4 (số chẵn), ta tiếp tục 
		
		
	

	## Bước 4 : Tính ước số 
		Tính gcd (2 ^(4/2)  - 1.15 ) = gcd( 4 - 1,15) = gcd(3 , 15) = 3
		
		Tương tự, tính gcd( 2^(4/2) + 1.15) = gcd(4  + 1.15) = gcd(5 , 15) = 5
		Kết quả 15 = 3 x 5 -> Phân tích thành công 
		
		
# Thành phần lượng tử trong thuật toán Shor 

	Phần cốt lõi giúp thuật toán này nhanh hơn máy tính cổ điển chính là biến đổi Fourier lượng tử (QFT): 
		- Máy tính lượng tử tạo ra trạng thái chồng chất của nhiều giá trị x 
		- QFT giúp tìm ra chu kỳ r nhanh chóng 
		- Kết hợp với thuật toán cổ điển Euclid để tìm thừa số của N  
		
	


	## Mạch lượng tử chính của thuật tón Shor gồm : 
		1. Đăng ký lượng tử đầu vào (chuẩn bị trạng thái chồng chất )
		2. Tính toán phép lũy thừa  a^x mod N bằng lượng tử 
		3. Áp dụng biển đổi Fourier lượng tử (QFT) để tìm chu kỳ r
		4. Đo và xử lý kết quả bằng máy tính cổ điển 
		
		
# Độ phức tạp của thuật toán Shor
	- Máy tính cổ điển : Phân tích thừa số nguyên tố có độ phức tạp siêu đa thức (O(eclogN​))) 
	- Máy tính lượng tử : Thuật toán Shor có độ phức tạp đa thức “(O((log⁡N)^3))” nhanh hơn đáng kể 


# Ứng dụng và tác động  
	- Đe dọa hệ mã hóa RSA : RSA dựa trên độ khó của việc phân tích số nguyên lớn thành thừa số. nếu máy tính lượng tử mạnh mẽ được chế tạo, toàn bộ hệ thống mã hóa sẽ bị phá vỡ 
	- Thúc đẩy mã hóa lượng tử : Do nguy cơ từ thuật toán Shor, người ta đã nghiên cứu mã hóa hậu lượng tử (Post-Quantum Cryptography) nhuw lattice-based cryptography. 
	
7. Tổng kết
✅ Thuật toán Shor là một ứng dụng mạnh mẽ của máy tính lượng tử, cho phép phân tích số nguyên thành thừa số trong thời gian đa thức.
✅ Biến đổi Fourier lượng tử (QFT) là yếu tố then chốt giúp thuật toán này vượt trội hơn so với thuật toán cổ điển.
✅ Nó đặt ra thách thức lớn cho các hệ thống mã hóa hiện tại như RSA, thúc đẩy sự phát triển của mật mã hậu lượng tử.	
	


// Ví dụ 
		ShorAlgorithmsExample.ipynb


//==========Lesson 5 == Lession 5 == Lession 5 == Thừa số , siêu đa thức, tốc độ đa thưc , gcd(a , N) ==========//


#---------------------------- Thừa số 
	# Định nghĩa 
		Thừa số của một số N là một số nguyên chia hết cho N mà không dư 
			ví dụ : 
				15=3×5 → 3, 5 là thừa số của 15
			
			
	# Liên quan đến lập trình lượng tử 
		Bài toán phân tích thừa số : Tìm các thừa số nguyên tố của một số N 
		Đây là nền tảng của RSA, vì RSA dựa trên giả định rằng phân tích thừa số của một số rất lớn là cực kỳ khó khăn đối với máy tính cổ điển 
		
		
	🔹 Máy tính lượng tử với thuật toán Shor có thể phá vỡ RSA bằng các phân tích thừa số của một số rất lớn nhanh chóng 
	
	
#------------------- Siêu đa thức (Superpolynomial)
# Định nghĩa 
	Một thuật toán có tốc độ đa thức (Polynomial Time) nếu thời gian chạy của nó có dạng O(n^k) với k là hằng số 
	
	Ví dụ :
		
		- O(n) -> Tuyến tính (Linear)
		- O(n^2) -> Bậc hai (Quadratic)
		- O(n^3) -> Bậc ba (Cubic)
		
		So sánh với tốc đọ mũ O(2^n) thì tốc độ đa thức nhanh hơn rất nhiều 
		
		Liên quan đến lập trình lượng tử 
			- Thuật toán Shor chạy trong đa thức O ((logN)^3), tức là nhanh hơn đáng kể so với thuật toán cổ điển phân tích thừa số(siêu đa thức)
			- Điều này có nghĩa là máy tính lượng tử có thể phá vỡ RSA trong thời gian thực tế 
			
	

#--------------------- GCD(a,N) -  Ước số chung lớn nhất 

# Định nghĩa 
	GCD(Greatest Common Divisor) của hai số a và N là ước số chung lớn nhất của chúng 
	
		GCD(12,18) = 6 vì 6 là số lớn nhất chia hết cả 12 và 18
		GCD(17,19) = 1 vì 17 , 19 là số nguyên tố, không có ước chung nào ngoài 1 
		
		
# Liên quan đến thuật toán Shor 
	Thuật toán Shor dùng GCD để tìm thừa số của N: 
		 1. Chọn một số a ngẫu nhiên sao cho gcd(a , N) = 1
		 2. Tìm chu kỳ của dãy số a^x mod N 
		 3. Dùng chu kỳ này để tính thừa số của N 
		 
		 
















		
</pre><a id='backBottom' href='../quantum-computing-learning-list.html' style='display:none;'>🔙 Quay lại danh sách</a><br><button onclick='toggleTheme()'>🌙 Chuyển giao diện</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>