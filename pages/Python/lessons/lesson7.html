<html><head><title>Lesson 6 ==  ==  == Kiểu dữ liệu chuỗi ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../python-learning-list.html'>🔙 Quay lại danh sách</a><br><h1>Lesson 6 --  --  -- Kiểu dữ liệu chuỗi -//</h1><pre>
# nháy đơn 
'' 

# nháy kép 
"" 
# Viết nhiều dòng mà không cần nối thì sử dụng 3 nháy , và cái nào xuống dòng thì khi in ra nó cũng sẽ là xuống dòng 
# Thường sử dụng để làm Doc String (Ghi chú tài liệu nhiều dòng và được Quy ước và thường được sử dụng như comment )

# Comment 
''' I 
AM 
Iron Man
'''

#Chuỗi 
a = """ Import
AM
 IRON MAN"""
 
 
 Escape Sequence  : \n ,  \t , \" , \' , \\  , \a , \b 
 
 
// Đường dẫn , regular expresion , các thứ không được complier , chuỗi trần 
# thêm r vào để báo nó là chuỗi không được sử dụng các Escape Sequence 
print(r'D:\BAO\FILE')  -> D:\BAO\FILE
print(r'D:\nAO\FILE')  -> D:\nAO\FILE

// toán tử *  chuỗi    , nhân chuỗi với số NGUYÊN 
strA = "String"
count = 5
print(strA * 5)  //StringStringStringStringString 

// toán tử in -> kiểm tra một chuỗi có nằm bên trong chuỗi khác hay không , trả về true or false  , giống equals 
strA = "String"
strB = "i"
c = strB in strA // kiểm tra chuỗi strB có nằm bên trong chuỗi strA hay không 


// Indexing trong chuỗi  ,  được đánh số char từ  0  đến n-1
print(strA[0])  // in ra chữ S 
print(strA[-1])  //in ra chữ cuối cùng , đi ngược lại 

// hàm lấy ra độ dài của chuỗi 
print(len(strA)) // -> 7

// Hàm cắt chuỗi sử dụng str[startIdx : endIndex]    , cắt từ TRÁI qua PHẢI 
print(strA[0:5]) // lấy ra vị trí index từ đầu đến vị trí thứ 5
print (strA[0:None])  // lấy từ đầu đến cuối 
print (strA[None:5]) // lấy từ đầu đến vị trí thứ 5 
print (strA[:]) ,  print (strA[None:None]) // Lấy toàn bộ  

// Hàm cắt chuỗi sử dụng str[startIdx : endIndex :Step ]    , cắt từ PHẢI qua TRÁI
 print (strA[None:5:-1]) // Cắt ngược từ phải qua trái theo bước là -1 
nếu như bước là 1 là mặc định thì k cần khai báo , còn đâu nếu muốn cắt theo bước nhảy thì khai báo thêm :Step 
 -> tức là nó sẽ dịch thêm n index để lấy giá trị 
 
 // Ép kiểu Chuỗi thành số 
 int("69")  // -> ép thành số 
 float("6.9")  // -> ép thành số 
 float("69")  // -> ép thành số 69.0
 int(6.9)     // -> 6  , lấy phần nguyên 
 
  // Ép kiểu số thành chuỗi 
	str(69)		// -> ép thành chuỗi "69"
	
  // Sửa giá trị indexing 
  strA = "String"
  strA = strA[0:1] + "0" + strA[2:None]   // sửa lại phần tử ở vị trí số 1 thành số 0 
  
  sử dụng Hash 
  print(hash(strA))  // Chuỗi hash là một chuỗi giữ giá trị của biến , thay đổi theo mỗi lần chạy lại chương trình 
  
  
// String format 
	
1. toán tử % 
	Cú pháp: <chuỗi> % (giá trị thứ 1, giá trị thứ 2, .., giá trị thứ n – 1, giá trị thứ n)
	Không hề có dấu ,tách phần chuỗi và phần giá trị cần định dạng 
	// Nó sẽ thay thế các vị trí phần tử vào các chỗ có %s , %d theo thứ tự 
	e.g 1
		s  = 'I am %s IN %d' %('Iron Man ' , 1)  // -> I am Iron Man IN 1
	- BẮT BUỘC PHẢI TRUYỀN VÀO ĐẦY ĐỦ SỐ LƯỢNG THAM SỐ 	
	
	e.g 2  
	s = '%s %s'
	s = s%('1' , 2) // 1 2
	
	e.g 3  
	s = '%s %s'
	result = s%('1' , 2)	// 1 2


		
		
	- %s                                 : giá trị của phương thức __str__ của đối tượng đó
	- %r                                 : giá trị của phương thức __repr__ của đối tượng đó 
	- %d                              	 : giá trị của một số - Nếu là số thực sẽ chỉ lấy phần nguyên ,(chuyển sang số nguyên )
	- %.<số chữ số phần thập phân >f      : Giá trị của một số - nếu là số sẽ chuyển sang số thực 
										fNum = 3.8899999
										a = '%.20f ' %(fNum) // -> 3.88999989999999984391   lấy ra 20 số sau dấu . 
						
	
	
	-  __str__     : Được sử dụng để trả về một chuỗi "đọc dễ dàng" và thân thiện với người dùng. 
						Mục đích của __str__() là cung cấp một biểu diễn chuỗi của đối tượng để con người dễ đọc 
				   
	- __repr__     : Được sử dụng để trả về một chuỗi "chính xác" hơn, mô tả đối tượng một cách chi tiết hơn, thường dành cho lập trình viên.
						Mục đích của __repr__() là trả về một chuỗi mà từ đó ta có thể tạo lại đối tượng nếu có thể 
	
	
	-  CÁC ĐỐI TƯỢNG BÊN TRONG PYTHON LUÔN LUÔN PHẢI CÓ 2 PHƯƠNG THỨC  __str__ VÀ  __repr__
	
class MyClass:
	def __str__(self):
		return "Đây là chuỗi thân thiện với người dùng(str) " 

	def __repr__(self) : 
		return "MyClass() - Đây là biểu diễn cho lập trình viên(repr)"


obj = MyClass()

print("Sử dụng %%s : %s" % obj)  // Sử dụng %s : Đây là chuỗi thân thiện với người dùng(str) 
print("Sử dụng %%r : %r" % obj)  // Sử dụng %r : <__main__.MyClass object at 0x000001A4EB396900>




2. Định dạng bằng chuỗi f (f-string)
   Cú pháp :  f 'giá trị trong chuỗi'
   
   e.g 1 
	var = 'string'
	print(f'This is a {var} .')		// This is a string .
	print('This is a {var} .')		// This is a {var} .
	
	
	e.g 2
	var = 'three'
	print(f'1 : {{one}} , 2 : {{two}}' , 3{var}) // 	1 : {one} , 2 : {two} , 3 : three
		-> Nếu muốn in ra dấu {} trong khi đang sử dụng f String thì ta cần thêm giống như escape sequence {{}} thì sẽ in ra MỘT cặp {}
	

	e.g 3
		v = 1 
		t = 2 
		print(f'Two variable {v= } AND {t : }');   // Two variable v= 1 AND  2  -> tức là chỉ nhận dấu  = là trường hợp đặc biệt thôi 


	e.g 4		// Vẫn cho phép sử dụng toán tử := để bắt giá trị 
		print(f'Using operator := with c = {(c:=3)}')	// Using operator := with c = 3
		print(c)										// 3
		

3. Định dạng bằng phương thức format    .format(args...)
	// Cách định dạng này cho phép Python định dạng chuỗi một cách tuyệt vời, không chỉ tốt về mặt nội dung mà còn về thẩm mĩ.
	e.g 1  
	a = 'a : {} , b : {} , c: {}'.format(1,2,3)		// a : 1 , b : 2 , c: 3
	a = 'a : {} , b : {} , c: {}'.format("ONE","TWO","THREE")	// a : ONE , b : TWO , c: THREE
	
	e.g 2  // Có thể thêm thừa args mà không gây ra lỗi 
	‘only one value: {0}’.format(1, 2) // ‘only one value: 1’

	e.g 3 // Chỉ đích danh giá trị cần gán 
	‘1: {one}, 2: {two}’.format(one=111, two=222) // ‘1: 111, 2: 222’
	
	e.g 4 // Căn lề  
		c : là ký tự muốn thay thế vào chỗ trống , mặc định sẽ là khoảng trắng 
		n : là số ký tự chèn vào căn lề 
		
		{:(c) < n}  : Căn lề trái 
		{:(c) > n}	: Căn lề phải 
		{:(c) ^ n}	: Căn giữa 
			 ‘{:^10}’.format(‘aaaa’)  # căn giữa
			'   aaaa   '
			
			 '{:<10}'.format('aaaa') # căn lề trái
			'aaaa      '
			
			 '{:>10}'.format('aaaa') # căn lề phải
			'      aaaa'
			
			 '{:*>10}'.format('aaaa') # căn lề trái, thay thế khoảng trắng bằng kí tự *
			'******aaaa'
			
			 '{:*<10}'.format('aaaa') # căn lề phải, thay thế khoảng trắng bằng kí tự *
			'aaaa******'
			
			 '{:*^10}'.format('aaaa') # căn giữa, thay thế khoảng trắng bằng kí tự *
			'***aaaa***'
	
3.	// Các hàm chuỗi trong python 
	https://docs.python.org/3/library/stdtypes.html#string-methods
	
	
// Các phương thức biến đổi
	s = "str"
	
	- .capitalize()  	// trả  về một chuỗi viết hoa ký tự đầu -> Chuyển hết thành lower rồi viết hoa chữ đầu , sử dụng để fix

	- .upper() 			// trả về chuỗi in hoa
	
	- .lower() 			// trả về chuỗi in thường 
	
	- .swapcase()		// trả về chuỗi được chuyển , viết HOA -> THƯỜNG , và THƯỜNG -> HOA
	
	- .title() 			// trả về một chuỗi viết định dạng tiêu đề , Tức là viết hoa chữ cái đầu tiên còn lại viết thường 
	
		
// Các phương thức định dạng 	
		width = 10
		fillchar = '*'

	-  .center(width,fillchar)    // trả về một chuỗi được căn giữa với chiều rộng width 
									// Nếu fillchar là None(hoặc không được nhập vào) thì mặc định sẽ dùng ký tự space để căn , nếu có nhập thì dùng ký tự đó để căn 
									// độ dài mỗi ký tự fillchar là 1 
									
	
	-  .rjust(width,fillchar)   //  Căn lề phải 


	-  .ljust(width,fillchar)   //  Căn lề trái  	
	
	
//    Các phương thức xử lí
		
		-  .encode(encoding='utf-8' , error='strict')  // phương thức để mã hóa về utf-8 , còn error mặc định sẽ là strict có nghĩa là sẽ có thông báo lỗi hiện lên nếu có vấn đề xuất hiện trong quá trình encode chuỗi , 
													 // strict , ignore,replace , xmlcharrefreplace
													print( 'ố ồ'.encode(encoding='utf-8', errors='strict'))
		
		-  .decode(encoding='utf-8', errors='strict')	// giải mã các phương thức đã được mã hóa bằng encode 


		
		- .join(<iterable>)						// nối chuỗi  , trả về một chuỗi bằng cách nối các phần tử trong iterable bằng ký tự nối, 
												// Một iterable có thể là một tuple , list ... iterator 
												// CÁC PHẦN TỬ TRONG ITERABLE BẮT BUỘC PHẢI LÀ LỚP STRING 
												// tức là trả về một giá trị được CHÈN (join) vào vị trí giữa các phần tử iterator  
								e.g 
									i = ['1' , '2' , '3'] , strV = 'str' 
									print(strV.join(i)) 	// 1str2str3
									
		
		- .replace(old , new , [count]) 	// thay thế chuỗi old = new  , 
											// count là số lượng số chuỗi thay thế bắt đầu từ 0 
											// nếu k truyền count tức là sẽ replace toàn bộ cái nào thỏa mãn 
										e.g 
										strV = 'str str str'
										print(strV.replace("s" , 'S' , 2))  // Str Str str 
										print(strV.replace("s" , 'S' ))		// Str Str Str
				

		- .strip([chars])			// trả về một chuỗi với phần đầu và phân đuôi các ký tự char , 
									// nếu k truyền vào gì thì sẽ bỏ khoảng trắng đầu và đuôi 
									// giống với trim() nhưng cải tiến hơn có thể chỉ định bỏ ký tự 
									// nó duyệt từng ký tự chứ không phải bắt buộc giống 
									// nhưng nó mà gặp phần tử còn lại sau khi xóa mà vẫn giống với thứ cần xóa thì nó sẽ xóa hết đến khi nào k gặp nữa thì mới return 
							e.g 	
							strV = 'sstr str strr'		
							print(strV.strip("sr")) 		// tr str st  , nó kiểm tra ký tự đầu và cuối có tồn tại trong char[] truyền vào hay không , chứ k phải so sánh toàn bộ chuỗi (in =  equals )
											
		-  .lstrip([chars]))		// giống như trên nhưng sẽ chỉ xóa mỗi bên trái 


		-  .rstrip([chars]))			// giống như trên nhưng sẽ chỉ xóa mỗi bên phải 
		
		
		
		-  removeprefix([prefix])	// Giống strip nhưng chỉ bỏ các ký tự được truyền GIỐNG Y SÌ bên trong prefix , tức là không xóa ký tự còn lại cho dù nó có giống 
									// Chỉ xóa phần đầu(bên trái )
									
		-  removesuffix([prefix])	// Giống strip nhưng chỉ bỏ các ký tự được truyền GIỐNG Y SÌ bên trong prefix , tức là không xóa ký tự còn lại cho dù nó có giống 
									// Chỉ xóa phần cuối(bên phải )		

				e.g 	
						strV = 'sssstr str  strrrr'	
			print(strV.removeprefix("sss"))	 // str str  strrrr
			print(strV.removesuffix("rrr"))  // sssstr str  str
			
//    Các phương thức tách chuỗi

		- .split(sep=None , maxsplit=-1)   // Trả về một list bằng cách chia các phần tử bằng seperator , default None thì sẽ cắt bằng khoảng trắng 
											// nếu maxsplit được bằng định bằng -1 , Python sẽ không giới hạn việc tách , tách hết , còn nếu truyền vào số nguyên thì sẽ tách từng đó số lần , và chuỗi còn lại sẽ để nguyên rồi truyền vào phần tử cuối cùng 
											// str.split()  // mặc định tách hết 
											// tách từ trái sang phải 
									print(a.split(sep='t',maxsplit=1)) // ['ssss', 'r str  strrrr']
		
		- .rsplit(sep=None , maxsplit=-1)	// Tách từ phải sang trái 
									print(a.rsplit(sep='t',maxsplit=1))		//['sssstr str  s', 'rrrr']
		
		
										str = 'a\nb\nc\nd\ne'
		- .splitlines(keppends=False)	// Giống với split nhưng các phần tử được chia tách bằng \n(xuống dòng ) , nếu keppends=True , các phần tử được phân tách sẽ có thêm \n ở sau 
										// Mặc định là False str.splitlines() == a.splitlines(False )
									
									print(a.splitlines(True))	// ['a\n', 'b\n', 'c\n', 'd\n', 'e']
									
									
									str = = "sssstr str  strrrr"
		- .partition(sep)			// Trả về một TUPLE với 3 phần tử , các phần tử đó lần lượt là , trước chuỗi sep ,chuỗi sep,sau chuỗi sep
									// Lấy từ trái sang phải gặp chuỗi sep đầu tiên sẽ thực hiện 
									
									print(str.partition(' '))   // ('sssstr', ' ', 'str  strrrr')
									
		
		- .rpartition(sep)			// tương tự partition nhưng lấy từ bên phải qua trái 
									


//   	Các phương thức tiện ích       str = = "sssstr str  strrrr"



		-	.count(sub[,start[,end]])	// trả về một số nguyên chính là số lần xuất hiện của chuỗi sub xuất hiện bên trong chuỗi 
										print(a.count('s',2,4))  	 // 2
										print(a.count('s'))			// 6 
										print(a.count('s',5))		// 2
		
		
		-   .startswith (prefix  [,start[,end]])	// trả về giá trị True nếu chuỗi đó bắt đầu bằng prefix và ngược lại k có là True 
													// Nếu truyền vào start và end thì sẽ slicing từ start và end truyền vào 
													
													 print(a.startswith('str',3))  // True
													print(a.startswith('str',3,4))   // False
		
		-	.endswith(suffix [,start[,end]])		// trả về nếu chuỗi đó kết thúc bằng chuỗi suffix truyền vào 
														print(a.endswith('s',3,4))  // True
														print(a.endswith('r'))		// True 
		
		
		- 	.find(sub,[,start[,end]])				// trả về index của chuỗi sub ĐẦU TIÊN  được tìm thấy từ trái sang phải bên trong start và end nếu có , nếu k có thì sẽ tìm cả chuỗi được gọi 
													// NẾU KHÔNG TÌM THẤY TRẢ VỀ  -1 
														print(a.find('r'))  // 5
														print(a.find('r', 1,6))   // 5
												
		
		- 	.rfind(sub,[,start[,end]])				// PHẢI - > TRÁI  trả về index của chuỗi sub ĐẦU TIÊN  được tìm thấy từ Phải sang trái  bên trong start và end nếu có , nếu k có thì sẽ tìm cả chuỗi được gọi 
															// NẾU KHÔNG TÌM THẤY TRẢ VỀ  -1 
													// print(a.rfind('r')) // 17 
				
		
		- 	.index(sub,[,start[,end]])				// Giống find NHƯNG NẾU KHÔNG TÌM THẤY TRẢ VỀ  lỖI 
													print(a.index('t'))  //   4
													
													
		- 	.rindex(sub,[,start[,end]])				// Giống rfind   NHƯNG NẾU KHÔNG TÌM THẤY TRẢ VỀ  lỖI 											
													print(a.rindex('t'))


//			 Các phương thức xác thực				   strA = = "sssstr str  strrrr"


		-  .islower()							// Trả về true nếu TẤT CẢ CÁC KÝ TỰ  đều viết THƯỜNG  trong chuỗi 
												print(strA.islower())  // TRUE

		
		
		-  .isupper()							//  Trả về true nếu TẤT CẢ CÁC KÝ TỰ  đều viết HOA trong chuỗi 
													print(strA.isupper())	// False
		
		
		
		-   .istitle()							// Trả về true nếu chuỗi đó là một dạng Title , và ngược lại 
												// Title là chuỗi mà trong đó tất cả các từ của chúng đều phải viết hoa chữ cái đầu 
												
												print("Sssstr Str Strrrr".istitle())		// True
												print("Sssstr Str trrrr".istitle())			// False
		
		-   .isidentifier()						// Dùng để xác định một chuỗi có phải là một định danh hay ko 
												// Phải thỏa mãn 3 điều kiện thì mới là một định danh đối tượng (class)
												// 1. Chuỗi phải được bắt đầu bằng dấu _ hoặc các ký tự chữ cái 
												// 2. chuỗi không được chứa bất kỳ khoảng trắng nào 
												// 3. Chuỗi không được chứ bất kỳ ký tự đặc biệt nào (. , $ ...) ngoại trừ ký tự _ 
												'_Client'.isidentifier()  // True 
												'code'.isidentifier()	// True 
												'@ads'.isidentifier()    // False 
												'25%'.isidentifier()     // False 
		
		- 	.isdigit()							// Trả về True nếu tất cả đều là các con số từ  0  đến 9 (số dương , âm cũng ko đc)
												// giống với isnumeric()
												'0123'.isdigit() // True 
												 '-123'.isdigit()  // False 
		
		-	.isspace()							// trả về TRUE nếu TẤT CẢ CÁC KÝ TỰ BÊN TRONG CHUỖI LÀ SPACE , TAB 
												'      '.isspace()  // True
												'   d  '.isspace()	// False 
												
			import keyword											
		-	keyword.iskeyword('strA')			// PHẢI  import keyword
												// Trả về True nếu chuỗi đó tương ứng với một từ khóa.
												 keyword.iskeyword('def')   		// True
												 keyword.iskeyword('class')  	//True
												 keyword.iskeyword('clas')		//False
												 
</pre><a id='backBottom' href='../python-learning-list.html' style='display:none;'>🔙 Quay lại danh sách</a><br><button onclick='toggleTheme()'>🌙 Chuyển giao diện</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>