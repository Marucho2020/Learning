<html><head><title>Lesson 9 == Async ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../NodeJS-learning.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 9 -- Async -//</h1><pre>

# T·ªïng Quan Ph·∫ßn "Node.js Asynchronous Programming"

	M·ª•c ti√™u: Hi·ªÉu c√°ch vi·∫øt code b·∫•t ƒë·ªìng b·ªô trong Node.js, bao g·ªìm:


		- Asynchronous l√† g√¨? C√°ch Node.js x·ª≠ l√Ω c√°c t√°c v·ª• I/O (nh∆∞ ƒë·ªçc file, request m·∫°ng) m√† kh√¥ng ch·∫∑n lu·ªìng ch√≠nh.
		- Sync vs Async: So s√°nh synchronous (ƒë·ªìng b·ªô) v√† asynchronous (b·∫•t ƒë·ªìng b·ªô).
		- Callback Hell: V·∫•n ƒë·ªÅ c·ªßa callback l·ªìng nhau v√† c√°ch gi·∫£i quy·∫øt b·∫±ng Promises/async/await.
		- Modern Async Patterns: S·ª≠ d·ª•ng Promises v√† async/await ƒë·ªÉ vi·∫øt code d·ªÖ ƒë·ªçc, hi·ªáu qu·∫£.
		- Best Practices: C√°ch vi·∫øt code b·∫•t ƒë·ªìng b·ªô ƒë√∫ng c√°ch.
		- T·∫°i sao c·∫ßn? Gi·∫£i th√≠ch l·ª£i √≠ch c·ªßa b·∫•t ƒë·ªìng b·ªô trong vi·ªác x·ª≠ l√Ω nhi·ªÅu k·∫øt n·ªëi.



	T·∫°i sao quan tr·ªçng? Node.js ƒë∆∞·ª£c thi·∫øt k·∫ø cho c√°c t√°c v·ª• I/O-heavy (nh∆∞ server API, streaming), v√† b·∫•t ƒë·ªìng b·ªô l√† ch√¨a kh√≥a ƒë·ªÉ ƒë·∫°t hi·ªáu su·∫•t cao. Hi·ªÉu c√°c pattern n√†y gi√∫p b·∫°n vi·∫øt code kh√¥ng ch·∫∑n event loop, d·ªÖ maintain, v√† x·ª≠ l√Ω l·ªói t·ªët h∆°n.



# 1. What is Asynchronous Programming?

	Asynchronous operations cho ph√©p ch∆∞∆°ng tr√¨nh l√†m vi·ªác kh√°c trong khi ch·ªù c√°c t√°c v·ª• nh∆∞ file I/O ho·∫∑c network requests ho√†n t·∫•t.
	
	M√¥ h√¨nh non-blocking n√†y gi√∫p Node.js x·ª≠ l√Ω h√†ng ngh√¨n k·∫øt n·ªëi ƒë·ªìng th·ªùi hi·ªáu qu·∫£.

	## Gi·∫£i th√≠ch chi ti·∫øt:

		Asynchronous l√† g√¨? Trong Node.js, c√°c t√°c v·ª• nh∆∞ ƒë·ªçc file, query database, ho·∫∑c g·ª≠i HTTP request c√≥ th·ªÉ m·∫•t th·ªùi gian (I/O-bound). Thay v√¨ ch·ªù, Node.js giao vi·ªác cho h·ªá th·ªëng (qua Libuv) v√† ti·∫øp t·ª•c x·ª≠ l√Ω t√°c v·ª• kh√°c. Khi I/O ho√†n t·∫•t, callback/Promise ƒë∆∞·ª£c g·ªçi ƒë·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£.

		Non-blocking: Event loop (ƒë√£ h·ªçc ·ªü ph·∫ßn tr∆∞·ªõc) ƒë·∫£m b·∫£o lu·ªìng ch√≠nh kh√¥ng b·ªã ch·∫∑n, gi√∫p server ti·∫øp t·ª•c nh·∫≠n request m·ªõi.

		V√≠ d·ª• th·ª±c t·∫ø: M·ªôt server API Node.js c√≥ th·ªÉ tr·∫£ response cho client A trong khi ch·ªù database tr·∫£ d·ªØ li·ªáu cho client B.

		Ng·ªØ c·∫£nh: B·∫•t ƒë·ªìng b·ªô l√† c·ªët l√µi c·ªßa c√°c ·ª©ng d·ª•ng nh∆∞ chat (WebSocket), streaming video, ho·∫∑c REST API.
		
		
		
		
		Synchronous: ƒê·ª£i ƒë·ªçc file xong m·ªõi ch·∫°y d√≤ng code ti·∫øp theo ‚Üí Ch·∫≠m n·∫øu file l·ªõn.
		
		Asynchronous: G·ª≠i l·ªánh ƒë·ªçc file, ti·∫øp t·ª•c ch·∫°y code kh√°c, x·ª≠ l√Ω k·∫øt qu·∫£ sau ‚Üí Nhanh, hi·ªáu qu·∫£.		
		
		
		
# 2. Sync vs Async: Key Differences		
		
	## Synchronous:	
		- Ch·∫∑n th·ª±c thi cho ƒë·∫øn khi ho√†n t·∫•t.
		- D·ªÖ hi·ªÉu, nh∆∞ng g√¢y ch·∫≠m tr·ªÖ.
		- V√≠ d·ª•: fs.readFileSync.		
		
		
		
	## 	Asynchronous:
		
Kh√¥ng ch·∫∑n, hi·ªáu su·∫•t cao.
Ph·ª©c t·∫°p h∆°n, c·∫ßn x·ª≠ l√Ω callback/Promise.
V√≠ d·ª•: fs.readFile.		
		
		
		
	## 	2.1. Synchronous File Read
	
const fs = require('fs');

console.log('1. Starting sync read...');
const data = fs.readFileSync('myfile.txt', 'utf8');
console.log('2. File contents:', data);
console.log('3. Done reading file');	
	
1. Starting sync read...
2. File contents: Hello!
3. Done reading file
	
	
	
	
	## 	2.2. Asynchronous File Read
	
const fs = require('fs');

console.log('1. Starting async read...');
fs.readFile('myfile.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log('2. File contents:', data);
});
console.log('3. Done starting read operation');	
	
	
	fs.readFile: H√†m b·∫•t ƒë·ªìng b·ªô, giao vi·ªác ƒë·ªçc file cho Thread Pool (Libuv), kh√¥ng ch·∫∑n main thread.
	
	Lu·ªìng th·ª±c thi:
	
		- In 1.
		- fs.readFile g·ª≠i l·ªánh ƒë·ªçc file, callback ƒë∆∞·ª£c x·∫øp v√†o Callback Queue.
		- In 3 ngay l·∫≠p t·ª©c.
		- Khi file ƒë·ªçc xong, event loop ch·∫°y callback, in 2.	
	
	∆Øu ƒëi·ªÉm: Main thread ti·∫øp t·ª•c x·ª≠ l√Ω request kh√°c, l√Ω t∆∞·ªüng cho server.
	Ng·ªØ c·∫£nh: D√πng fs.readFile trong API ƒë·ªÉ ƒë·ªçc file m√† kh√¥ng l√†m ch·∫≠m response
	
	
		
# 3. Avoiding Callback Hell

	## 3.1. Problem: Nested Callbacks (Callback Hell)

getUser(userId, (err, user) => {
  if (err) return handleError(err);
  getOrders(user.id, (err, orders) => {
    if (err) return handleError(err);
    processOrders(orders, (err) => {
      if (err) return handleError(err);
      console.log('All done!');
    });
  });
});

	Callback Hell: C√°c callback l·ªìng nhau (nested callbacks) khi·∫øn code kh√≥ ƒë·ªçc, kh√≥ b·∫£o tr√¨, v√† d·ªÖ l·ªói (nh∆∞ b·ªè s√≥t x·ª≠ l√Ω l·ªói).

		- L·ªìng nhi·ªÅu c·∫•p (·ªü ƒë√¢y l√† 3 c·∫•p).
		- X·ª≠ l√Ω l·ªói l·∫∑p l·∫°i ·ªü m·ªói callback.
		- Kh√≥ debug n·∫øu c√≥ l·ªói ·ªü c·∫•p trong c√πng.

	Ng·ªØ c·∫£nh: Th∆∞·ªùng g·∫∑p khi g·ªçi API, query database li√™n ti·∫øp (nh∆∞ l·∫•y user, r·ªìi orders, r·ªìi x·ª≠ l√Ω).


	## 3.2. Solution: Use Promises 


getUser(userId)
  .then(user => getOrders(user.id))
  .then(orders => processOrders(orders))
  .then(() => console.log('All done!'))
  .catch(handleError);


		Promises: Chuy·ªÉn callback th√†nh chu·ªói .then(), d·ªÖ ƒë·ªçc h∆°n. M·ªôt .catch() x·ª≠ l√Ω l·ªói cho to√†n chu·ªói.

			- getUser(userId) tr·∫£ v·ªÅ Promise.
			- Khi resolve, g·ªçi getOrders(user.id).
			- Ti·∫øp t·ª•c v·ªõi processOrders(orders).
			- In All done! ho·∫∑c x·ª≠ l√Ω l·ªói trong .catch.

			∆Øu ƒëi·ªÉm: Code tuy·∫øn t√≠nh, x·ª≠ l√Ω l·ªói t·∫≠p trung.
			Ng·ªØ c·∫£nh: D√πng trong API hi·ªán ƒë·∫°i (nh∆∞ fetch, mongoose).


		## 3.3. Even Better: Async/Await
		
async function processUser(userId) {
  try {
    const user = await getUser(userId);
    const orders = await getOrders(user.id);
    await processOrders(orders);
    console.log('All done!');
  } catch (err) {
    handleError(err);
  }
}		
		
		
		H√†m async tr·∫£ v·ªÅ Promise.
		await t·∫°m d·ª´ng cho ƒë·∫øn khi Promise resolve, nh∆∞ng kh√¥ng ch·∫∑n event loop.
		try/catch x·ª≠ l√Ω l·ªói t∆∞∆°ng t·ª± .catch.		
		
		∆Øu ƒëi·ªÉm: Code r√µ r√†ng nh∆∞ synchronous, d·ªÖ maintain.
		Ng·ªØ c·∫£nh: Chu·∫©n hi·ªán ƒë·∫°i cho Node.js, d√πng trong Express.js, database queries		
		
const getUser = (id) => Promise.resolve({ id, name: 'Alice' });
const getOrders = (userId) => Promise.resolve([{ id: 1, item: 'Book' }]);
const processOrders = (orders) => Promise.resolve(orders);
const handleError = (err) => console.error('Error:', err);

async function processUser(userId) {
  try {
    const user = await getUser(userId);
    const orders = await getOrders(user.id);
    await processOrders(orders);
    console.log('All done!');
  } catch (err) {
    handleError(err);
  }
}
processUser(1);



# 4. Modern Async Patterns

	## 4.1. Promises

const fs = require('fs').promises;

console.log('1. Reading file...');
fs.readFile('myfile.txt', 'utf8')
  .then(data => {
    console.log('3. File content:', data);
  })
  .catch(err => console.error('Error:', err));
console.log('2. This runs before file is read!');


1. Reading file...
2. This runs before file is read!
3. File content: Hello!


	- fs.promises: Phi√™n b·∫£n Promise c·ªßa module fs, thay v√¨ callback truy·ªÅn th·ªëng.
	- Lu·ªìng: fs.readFile tr·∫£ v·ªÅ Promise, .then x·ª≠ l√Ω d·ªØ li·ªáu, .catch x·ª≠ l√Ω l·ªói.
	- ∆Øu ƒëi·ªÉm: Tr√°nh callback, code r√µ r√†ng h∆°n.
	- Ng·ªØ c·∫£nh: D√πng khi l√†m vi·ªác v·ªõi API Promise-based (nh∆∞ fetch, fs.promises)


	## 4.2. Async/Await (Recommended)

const fs = require('fs').promises;

async function readFiles() {
  try {
    console.log('1. Starting to read files...');
    const data1 = await fs.readFile('file1.txt', 'utf8');
    const data2 = await fs.readFile('file2.txt', 'utf8');
    console.log('2. Files read successfully!');
    return { data1, data2 };
  } catch (error) {
    console.error('Error reading files:', error);
  }
}
readFiles();		


	- Async/Await: D√πng fs.promises ƒë·ªÉ ƒë·ªçc file tu·∫ßn t·ª±, try/catch x·ª≠ l√Ω l·ªói.
	- Lu·ªìng: await ch·ªù t·ª´ng file, nh∆∞ng kh√¥ng ch·∫∑n event loop. K·∫øt qu·∫£ ƒë∆∞·ª£c tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng object.
	- ∆Øu ƒëi·ªÉm: Code d·ªÖ ƒë·ªçc, gi·ªëng synchronous, ph√π h·ª£p cho flow ph·ª©c t·∫°p.
	- Ng·ªØ c·∫£nh: Chu·∫©n cho ·ª©ng d·ª•ng hi·ªán ƒë·∫°i (nh∆∞ Express.js v·ªõi MongoDB).	




# 5. Best Practices


async function getUserData(userId) {
  try {
    const user = await User.findById(userId);
    const orders = await Order.find({ userId });
    return { user, orders };
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    throw error;
  }
}

	Not This:

User.findById(userId, (err, user) => {
  if (err) return console.error(err);
  Order.find({ userId }, (err, orders) => {
    if (err) return console.error(err);
    // Process orders...
  });
});



	‚úÖ D√πng async/await ƒë·ªÉ code d·ªÖ ƒë·ªçc.
	‚úÖ Lu√¥n x·ª≠ l√Ω l·ªói v·ªõi try/catch.
	‚úÖ D√πng Promise.all cho t√°c v·ª• song song.
	‚ùå Tr√°nh mix sync v√† async code.
	‚ùå Kh√¥ng qu√™n await v·ªõi Promise.


	## Example: Parallel Execution

async function fetchAllData() {
  try {
    const [users, products, orders] = await Promise.all([
      User.find(),
      Product.find(),
      Order.find()
    ]);
    return { users, products, orders };
  } catch (error) {
    console.error('Error fetching data:', error);
    throw error;
  }
}


	- Promise.all: Ch·∫°y nhi·ªÅu Promise song song, tr·∫£ v·ªÅ m·∫£ng k·∫øt qu·∫£ khi t·∫•t c·∫£ ho√†n t·∫•t.
	- ∆Øu ƒëi·ªÉm: TƒÉng t·ªëc ƒë·ªô v√¨ kh√¥ng ch·ªù t·ª´ng Promise tu·∫ßn t·ª±.
	- Ng·ªØ c·∫£nh: D√πng khi l·∫•y d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn (nh∆∞ database queries).



# 	7. Summary

	- Node.js d√πng event loop cho non-blocking I/O.
	- D√πng async/await v·ªõi Promises ƒë·ªÉ code hi·ªán ƒë·∫°i.
	- Lu√¥n x·ª≠ l√Ω l·ªói trong async code.
	- D√πng Promise.all cho t√°c v·ª• song song.
	- Tr√°nh callback hell b·∫±ng Promises/async/await.	



	- Event Loop: ƒê·∫£m b·∫£o non-blocking, c·ªët l√µi c·ªßa asynchronous.
	- Async/Await: Chu·∫©n hi·ªán ƒë·∫°i, d·ªÖ ƒë·ªçc, d·ªÖ maintain.
	- L·ªói: try/catch ho·∫∑c .catch l√† b·∫Øt bu·ªôc ƒë·ªÉ tr√°nh crash.
	- Song song: Promise.all t·ªëi ∆∞u khi c·∫ßn ch·∫°y nhi·ªÅu t√°c v·ª• c√πng l√∫c.



https://www.w3schools.com/nodejs/nodejs_promises.asp
</pre><a id='backBottom' href='../NodeJS-learning.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>