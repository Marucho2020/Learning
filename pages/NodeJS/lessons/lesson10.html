<html><head><title>Lesson 10 == Promises ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../NodeJS-learning.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 10 -- Promises -//</h1><pre>
# T·ªïng Quan Ph·∫ßn "Node.js Promises"

	M·ª•c ti√™u: Hi·ªÉu Promises trong Node.js, bao g·ªìm:


		- Promises l√† g√¨? M·ªôt c∆° ch·∫ø ƒë·ªÉ x·ª≠ l√Ω b·∫•t ƒë·ªìng b·ªô, ƒë·∫°i di·ªán cho k·∫øt qu·∫£ c·ªßa m·ªôt t√°c v·ª• (th√†nh c√¥ng ho·∫∑c th·∫•t b·∫°i).
		- L·ª£i √≠ch: So s√°nh v·ªõi callback, tr√°nh callback hell, x·ª≠ l√Ω l·ªói d·ªÖ h∆°n.
		- C√°ch t·∫°o v√† s·ª≠ d·ª•ng: S·ª≠ d·ª•ng Promise constructor, then, catch, finally.
		- Promise Methods: C√°c ph∆∞∆°ng th·ª©c nh∆∞ Promise.all, Promise.race, Promise.allSettled.
		- X·ª≠ l√Ω l·ªói: C√°ch ƒë·∫£m b·∫£o kh√¥ng b·ªè s√≥t l·ªói trong Promises.
		- T·∫°i sao quan tr·ªçng? Promises l√† b∆∞·ªõc ƒë·ªám ƒë·ªÉ hi·ªÉu async/await v√† l√† chu·∫©n cho c√°c th∆∞ vi·ªán Node.js hi·ªán ƒë·∫°i.

		T·∫°i sao quan tr·ªçng? Promises gi√∫p vi·∫øt code b·∫•t ƒë·ªìng b·ªô d·ªÖ ƒë·ªçc, d·ªÖ debug, v√† x·ª≠ l√Ω l·ªói t·∫≠p trung. Ch√∫ng l√† n·ªÅn t·∫£ng cho c√°c API nh∆∞ fs.promises, fetch, v√† c√°c th∆∞ vi·ªán nh∆∞ mongoose, ƒë·ªìng th·ªùi l√† b∆∞·ªõc chuy·ªÉn ti·∫øp sang async/await.


# 1. Introduction to Promises

	- Promises cung c·∫•p c√°ch x·ª≠ l√Ω b·∫•t ƒë·ªìng b·ªô s·∫°ch h∆°n so v·ªõi callback.
	- Promises ƒë·∫°i di·ªán cho s·ª± ho√†n th√†nh (ho·∫∑c th·∫•t b·∫°i) c·ªßa m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô.


	## Promise States 
		
		- Pending: T√°c v·ª• ch∆∞a ho√†n th√†nh.
		- Fulfilled: T√°c v·ª• th√†nh c√¥ng.
		- Rejected: T√°c v·ª• th·∫•t b·∫°i.

		M·ªôt khi Promise "settled" (fulfilled ho·∫∑c rejected), tr·∫°ng th√°i kh√¥ng th·ªÉ thay ƒë·ªïi.



	## Gi·∫£i th√≠ch chi ti·∫øt:

		- Promises l√† g√¨? Promise l√† m·ªôt object JavaScript ƒë·∫°i di·ªán cho k·∫øt qu·∫£ t∆∞∆°ng lai c·ªßa m·ªôt t√°c v·ª• b·∫•t ƒë·ªìng b·ªô. N√≥ cho ph√©p b·∫°n g·∫Øn callback (then, catch) ƒë·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£ ho·∫∑c l·ªói khi t√°c v·ª• ho√†n t·∫•t.
		
		- So v·ªõi callback: Callback truy·ªÅn th·ªëng d·∫´n ƒë·∫øn code l·ªìng nhau (callback hell). Promises cho ph√©p vi·∫øt code tuy·∫øn t√≠nh, d·ªÖ ƒë·ªçc h∆°n.


	## Promise States:
	
		- Pending: Khi Promise ƒë∆∞·ª£c t·∫°o, v√≠ d·ª•: ƒëang ƒë·ªçc file.
		- Fulfilled: T√°c v·ª• th√†nh c√¥ng, v√≠ d·ª•: file ƒë·ªçc xong v√† tr·∫£ d·ªØ li·ªáu.
		- Rejected: T√°c v·ª• th·∫•t b·∫°i, v√≠ d·ª•: file kh√¥ng t·ªìn t·∫°i.	
	
		T√≠nh b·∫•t bi·∫øn: M·ªôt Promise ch·ªâ settle m·ªôt l·∫ßn, kh√¥ng th·ªÉ chuy·ªÉn t·ª´ fulfilled sang rejected ho·∫∑c ng∆∞·ª£c l·∫°i.
		Ng·ªØ c·∫£nh: Promises ƒë∆∞·ª£c d√πng trong c√°c API nh∆∞ fs.promises.readFile, fetch, ho·∫∑c query database v·ªõi mongoose.
	
		M·ªôt Promise nh∆∞ fs.promises.readFile('data.txt') b·∫Øt ƒë·∫ßu ·ªü tr·∫°ng th√°i Pending, sau ƒë√≥ chuy·ªÉn sang Fulfilled (tr·∫£ n·ªôi dung file) ho·∫∑c Rejected (l·ªói n·∫øu file kh√¥ng t·ªìn t·∫°i).
	
	
	
	
# 	2. Benefits of Using Promises
	
	
	## With Callbacks:
	
getUser(id, (err, user) => {
  if (err) return handleError(err);
  getOrders(user.id, (err, orders) => {
    if (err) return handleError(err);
    // Process orders...
  });
});	
	
	
	## 	
	
getUser(id)
  .then(user => getOrders(user.id))
  .then(orders => processOrders(orders))
  .catch(handleError);


	## Key Advantages:

	- C·∫•u tr√∫c code ph·∫≥ng (flatter), tr√°nh callback hell.
	- X·ª≠ l√Ω l·ªói t·∫≠p trung v·ªõi m·ªôt .catch().
	- D·ªÖ d√†ng chain c√°c t√°c v·ª• b·∫•t ƒë·ªìng b·ªô.
	- H·ªó tr·ª£ ch·∫°y song song (parallel) v·ªõi Promise.all.


	Callback Hell: Code callback l·ªìng nhau kh√≥ ƒë·ªçc, kh√≥ debug, v√† ph·∫£i x·ª≠ l√Ω l·ªói ·ªü m·ªói c·∫•p.

		- Code tuy·∫øn t√≠nh: M·ªói .then() nh·∫≠n k·∫øt qu·∫£ t·ª´ b∆∞·ªõc tr∆∞·ªõc.
		- X·ª≠ l√Ω l·ªói: M·ªôt .catch() b·∫Øt l·ªói cho to√†n chu·ªói.
		- Chain: C√≥ th·ªÉ n·ªëi nhi·ªÅu t√°c v·ª• (nh∆∞ l·∫•y user, r·ªìi orders, r·ªìi x·ª≠ l√Ω).
		- Song song: Promise.all cho ph√©p ch·∫°y nhi·ªÅu t√°c v·ª• c√πng l√∫c.

	V√≠ d·ª• th·ª±c t·∫ø: Trong m·ªôt API, b·∫°n l·∫•y th√¥ng tin user, sau ƒë√≥ l·∫•y orders c·ªßa user, v√† x·ª≠ l√Ω d·ªØ li·ªáu. Promises l√†m flow n√†y r√µ r√†ng h∆°n callback.



#	3. Creating and Using Promises

	## 3.1. Basic Promise Creation

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = Math.random() > 0.5;
    if (success) {
      resolve('Operation completed successfully');
    } else {
      reject(new Error('Operation failed'));
    }
  }, 1000);
});

myPromise
  .then(result => console.log('Success:', result))
  .catch(error => console.error('Error:', error.message));



# 3.2. Reading a File with Promises


const fs = require('fs').promises;

const promise1 = Promise.resolve('First result');
const promise2 = new Promise((resolve) => setTimeout(() => resolve('Second result'), 1000));
const promise3 = fs.readFile('myfile.txt', 'utf8');

Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log('Results:', results);
  })
  .catch(error => {
    console.error('Error in one of the promises:', error);
  });


	fs.promises: Phi√™n b·∫£n Promise c·ªßa module fs, tr·∫£ v·ªÅ Promise thay v√¨ callback.
	Promise.all: Ch·∫°y song song nhi·ªÅu Promise, tr·∫£ v·ªÅ m·∫£ng k·∫øt qu·∫£ khi t·∫•t c·∫£ fulfilled.

	Results: ['First result', 'Second result', 'Hello!']
	
	

# 4. Promise Chaining


function getUser(userId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: userId, name: 'John' }), 1000);
  });
}

function getUserPosts(user) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(['Post 1', 'Post 2', 'Post 3']), 1000);
  });
}

getUser(123)
  .then(user => {
    console.log('User:', user);
    return getUserPosts(user);
  })
  .then(posts => {
    console.log('Posts:', posts);
  })
  .catch(error => {
    console.error('Error:', error);
  });


	Promise Chaining: M·ªói .then nh·∫≠n k·∫øt qu·∫£ t·ª´ Promise tr∆∞·ªõc v√† tr·∫£ v·ªÅ m·ªôt Promise m·ªõi.

		getUser(123) tr·∫£ v·ªÅ Promise, resolve sau 1s v·ªõi { id: 123, name: 'John' }.
		.then ƒë·∫ßu ti√™n in User v√† g·ªçi getUserPosts, tr·∫£ v·ªÅ Promise m·ªõi.
		.then th·ª© hai nh·∫≠n k·∫øt qu·∫£ t·ª´ getUserPosts, in Posts.
		.catch x·ª≠ l√Ω l·ªói cho to√†n chu·ªói

	Ng·ªØ c·∫£nh: D√πng ƒë·ªÉ x·ª≠ l√Ω c√°c t√°c v·ª• tu·∫ßn t·ª±, nh∆∞ l·∫•y user r·ªìi l·∫•y posts t·ª´ database.

# 5. Promise Methods

	## Instance Methods:
		
		then(onFulfilled, onRejected): X·ª≠ l√Ω fulfilled ho·∫∑c rejected.
		catch(onRejected): X·ª≠ l√Ω rejected, t∆∞∆°ng ƒë∆∞∆°ng then(null, onRejected).
		finally(onFinally): Ch·∫°y b·∫•t k·ªÉ fulfilled hay rejected.
		
		
			- then: X·ª≠ l√Ω k·∫øt qu·∫£ ho·∫∑c l·ªói. C√≥ th·ªÉ nh·∫≠n hai callback, nh∆∞ng th∆∞·ªùng d√πng .catch ri√™ng.
			- catch: Ch·ªâ x·ª≠ l√Ω l·ªói, g·ªçn h∆°n.
			- finally: D√πng ƒë·ªÉ cleanup (nh∆∞ ƒë√≥ng k·∫øt n·ªëi) sau khi Promise settle.		

	## Static Methods:

		Promise.all(iterable): Ch·ªù t·∫•t c·∫£ Promise resolve.
		Promise.race(iterable): L·∫•y Promise settle ƒë·∫ßu ti√™n.
		Promise.allSettled(iterable): Ch·ªù t·∫•t c·∫£ Promise settle (fulfilled ho·∫∑c rejected).
		Promise.resolve(value): T·∫°o Promise fulfilled ngay.
		Promise.reject(reason): T·∫°o Promise rejected ngay.

			- Promise.all: Ch·∫°y song song, reject ngay n·∫øu m·ªôt Promise reject.
			- Promise.race: L·∫•y k·∫øt qu·∫£ c·ªßa Promise nhanh nh·∫•t (d√πng cho timeout).
			- Promise.allSettled: Tr·∫£ m·∫£ng tr·∫°ng th√°i c·ªßa t·∫•t c·∫£ Promise, k·ªÉ c·∫£ rejected.
			- Promise.resolve/reject: T·∫°o Promise v·ªõi tr·∫°ng th√°i c·ªë ƒë·ªãnh, h·ªØu √≠ch ƒë·ªÉ test ho·∫∑c chu·∫©n h√≥a flow.

		Ng·ªØ c·∫£nh: Promise.all d√πng khi c·∫ßn d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn (nh∆∞ API calls). Promise.race d√πng ƒë·ªÉ set timeout cho t√°c v·ª•.



# 6. Promise.then()

myPromise
  .then(
    result => console.log(result),
    error => console.error(error)
  );

	then: Nh·∫≠n hai callback:

		onFulfilled: Ch·∫°y khi Promise fulfilled.
		onRejected: Ch·∫°y khi Promise rejected (√≠t d√πng, n√™n thay b·∫±ng .catch).

	Ng·ªØ c·∫£nh: D√πng khi b·∫°n mu·ªën x·ª≠ l√Ω c·∫£ th√†nh c√¥ng v√† l·ªói trong m·ªôt method.



const myPromise = new Promise((resolve) => resolve('Success'));
myPromise.then(
  result => console.log(result),
  error => console.error(error)
);




# 7. Promise.catch()

myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error));


	catch: Chuy√™n x·ª≠ l√Ω l·ªói, g·ªçn h∆°n then(null, errorHandler).
	T·∫°i sao c·∫ßn? N·∫øu kh√¥ng c√≥ .catch, l·ªói unhandled c√≥ th·ªÉ l√†m crash ·ª©ng d·ª•ng.
	Ng·ªØ c·∫£nh: D√πng sau chu·ªói .then ƒë·ªÉ b·∫Øt l·ªói t·ª´ b·∫•t k·ª≥ b∆∞·ªõc n√†o.


const myPromise = new Promise((_, reject) => reject(new Error('Fail')));
myPromise.then(result => console.log(result)).catch(error => console.error(error.message));



# 8. Promise.finally()

myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error))
  .finally(() => console.log('Operation completed'));


		finally: Ch·∫°y b·∫•t k·ªÉ Promise fulfilled hay rejected.
		Ng·ªØ c·∫£nh: D√πng ƒë·ªÉ cleanup (nh∆∞ ƒë√≥ng file, gi·∫£i ph√≥ng t√†i nguy√™n).
		L∆∞u √Ω: Kh√¥ng nh·∫≠n k·∫øt qu·∫£ hay l·ªói, ch·ªâ ch·∫°y logic c·ªë ƒë·ªãnh.
		
	Th√™m finally v√†o code error.js t·ª´ tr√™n, ki·ªÉm tra output.



# 9. Promise.all() for Parallel Execution

const fs = require('fs').promises;

const promise1 = Promise.resolve('First result');
const promise2 = new Promise((resolve) => setTimeout(() => resolve('Second result'), 1000));
const promise3 = fs.readFile('data.txt', 'utf8');

Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log('Results:', results);
  })
  .catch(error => {
    console.error('Error in one of the promises:', error);
  });



	Promise.all: Ch·∫°y song song t·∫•t c·∫£ Promise, tr·∫£ m·∫£ng k·∫øt qu·∫£ khi t·∫•t c·∫£ fulfilled.
	Fail-fast: N·∫øu m·ªôt Promise reject, .catch ch·∫°y ngay, b·ªè qua c√°c Promise kh√°c.
	Ng·ªØ c·∫£nh: D√πng khi c·∫ßn l·∫•y d·ªØ li·ªáu t·ª´ nhi·ªÅu ngu·ªìn (nh∆∞ ƒë·ªçc nhi·ªÅu file, g·ªçi nhi·ªÅu API).




# 10. Promise.race() for First Result

const promise1 = new Promise(resolve => setTimeout(() => resolve('First result'), 1000));
const promise2 = new Promise(resolve => setTimeout(() => resolve('Second result'), 500));

Promise.race([promise1, promise2])
  .then(result => {
    console.log('Fastest result:', result);
  });

	Fastest result: Second result
	
	

	Promise.race: Tr·∫£ k·∫øt qu·∫£ c·ªßa Promise settle ƒë·∫ßu ti√™n (fulfilled ho·∫∑c rejected).
	Ng·ªØ c·∫£nh: D√πng cho timeout (nh∆∞ ch·ªù API 5s, n·∫øu kh√¥ng tr·∫£ th√¨ b√°o l·ªói).
	V√≠ d·ª• th·ª±c t·∫ø: G·ªçi API, n·∫øu ch·∫≠m th√¨ tr·∫£ v·ªÅ cached data.

const timeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 700));
Promise.race([promise1, promise2, timeout]).then(...).catch(...);




# 11. Error Handling in Promises

function fetchData() {
  return new Promise((_, reject) => {
    reject(new Error('Network error'));
  });
}

fetchData()
  .then(data => console.log('Data:', data))
  .catch(error => console.log('Error handled in catch:', error.message));
function fetchData() {
  return new Promise((_, reject) => {
    reject(new Error('Network error'));
  });
}

fetchData()
  .then(data => console.log('Data:', data))
  .catch(error => console.log('Error handled in catch:', error.message));

Error handled in catch: Network error


T·∫ßm quan tr·ªçng: Kh√¥ng x·ª≠ l√Ω l·ªói c√≥ th·ªÉ g√¢y crash ho·∫∑c memory leak.
C√°ch x·ª≠ l√Ω:

	D√πng .catch sau chu·ªói .then.
	C√≥ th·ªÉ d√πng try/catch v·ªõi async/await (ph·∫ßn sau).
	Best Practice: Lu√¥n th√™m .catch ƒë·ªÉ b·∫Øt l·ªói unhandled.
	



</pre><a id='backBottom' href='../NodeJS-learning.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>