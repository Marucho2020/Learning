<html><head><title>Lesson 27 == Stream ==========//</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px;       white-space: pre-wrap; word-wrap: break-word;       overflow-x: auto; max-width: 100%;       transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 2em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 1.5em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../NodeJS-learning.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lesson 27 -- Stream -//</h1><pre>

# 1. Streams L√† G√¨? (What are Streams?)
	ƒê·ªãnh nghƒ©a: Streams l√† c√°ch x·ª≠ l√Ω d·ªØ li·ªáu theo chunks (mi·∫øng nh·ªè), thay v√¨ load to√†n b·ªô v√†o memory. Gi·ªëng nh∆∞ d√≤ng ch·∫£y d·ªØ li·ªáu: ƒë·ªçc/ghi d·∫ßn d·∫ßn, kh√¥ng ch·ªù h·∫øt. Kh√¥ng ph·∫£i array/buffer l·ªõn, m√† l√† sequence of data over time.


	## T·∫°i Sao D√πng Streams? (Why Use Streams?)
		- Memory Efficiency: X·ª≠ l√Ω file 10GB tr√™n server 1GB RAM ‚Äì ch·ªâ load chunk 64KB/l·∫ßn.
		- Time Efficiency: B·∫Øt ƒë·∫ßu process ngay (e.g., stream video: xem ngay kh√¥ng ch·ªù download h·∫øt).
		- Composability: K·∫øt n·ªëi streams th√†nh pipeline (e.g., read file ‚Üí compress ‚Üí write).
		- Better UX: Real-time data (e.g., HTTP streaming responses).	

	S√¢u s·∫Øc: Trong production (e.g., Netflix-like apps), streams gi·∫£m latency v√† CPU. NƒÉm 2025, v·ªõi edge computing (Vercel/Cloudflare), streams t√≠ch h·ª£p t·ªët v·ªõi Web APIs cho serverless.

	V√≠ d·ª• Basic (copy file d√πng streams):

const fs = require('fs');
const readable = fs.createReadStream('input.txt', 'utf8');
const writable = fs.createWriteStream('output.txt');
readable.pipe(writable);  // Magic: t·ª± ƒë·ªông copy!
writable.on('finish', () => console.log('Done!'));
readable.on('error', err => console.error(err));
writable.on('error', err => console.error(err));


# 2. Core Stream Types
	Node.js c√≥ 4 lo·∫°i streams ch√≠nh, t·∫•t c·∫£ k·∫ø th·ª´a EventEmitter:

Type,M√¥ t·∫£,Examples
Readable,ƒê·ªçc data t·ª´ source (push data ra),"fs.createReadStream, process.stdin, http.IncomingMessage"
Writable,Ghi data v√†o destination (pull data v√†o),"fs.createWriteStream, process.stdout, http.ServerResponse"
Duplex,C·∫£ read & write (two-way),"net.Socket (TCP), zlib (compress/decompress)"
Transform,"Duplex nh∆∞ng transform data (e.g., compress)","zlib.createGzip, crypto.createCipher"

	S√¢u: Readable/Writable l√† base; Duplex/Transform l√† specialized. NƒÉm 2025, d√πng pipeline() (t·ª´ stream.promises) cho async handling.



# 3. Events Trong Streams
	Streams emit events ƒë·ªÉ control flow:


Event,Type,M√¥ t·∫£
'data',Readable,Chunk m·ªõi s·∫µn s√†ng (pause/resume flow)
'end',Readable,H·∫øt data
'error',All,L·ªói x·∫£y ra
'finish',Writable,ƒê√£ ghi h·∫øt
'drain',Writable,"Buffer empty, c√≥ th·ªÉ write ti·∫øp"
'pipe',Readable,ƒê∆∞·ª£c pipe v√†o writable


	## V√≠ d·ª• Readable:

const fs = require('fs');
const stream = fs.createReadStream('file.txt');
stream.on('data', chunk => console.log(chunk.toString()));  // Chunk l√† Buffer
stream.on('end', () => console.log('Done'));
stream.on('error', err => console.error(err));

	Backpressure: N·∫øu writable ch·∫≠m, readable pause t·ª± ƒë·ªông ‚Äì tr√°nh overflow.



# 4. Piping Streams
	pipe(): K·∫øt n·ªëi readable ‚Üí writable, t·ª± handle flow/backpressure.
	
	readable.pipe(transform).pipe(writable);  // Pipeline: read ‚Üí transform ‚Üí write

	## V√≠ d·ª• Compress File: 
	
const fs = require('fs');
const zlib = require('zlib');
fs.createReadStream('input.txt')
  .pipe(zlib.createGzip())  // Transform: compress
  .pipe(fs.createWriteStream('input.txt.gz'));
  
  
	## Async Pipeline (Node 15+): 
const { pipeline } = require('stream/promises');
await pipeline(readable, transform, writable);  // Handle errors cleanly	
	
	S√¢u: Pipeline t·ªët cho ETL (Extract-Transform-Load) nh∆∞ process logs: read ‚Üí filter ‚Üí write DB.
	
	
# 	5. Custom Streams (Advanced)
	T·∫°o Readable/Writable custom b·∫±ng extend class.
	Custom Readable (push data manually):

const { Readable } = require('stream');
class RandomNumberStream extends Readable {
  constructor(options) {
    super(options);
    this._max = 10;
    this._index = 0;
  }
  _read(size) {
    if (this._index++ < this._max) {
      this.push(Math.random().toString());
    } else {
      this.push(null);  // End stream
    }
  }
}
const stream = new RandomNumberStream();
stream.on('data', num => console.log(num));



	##	Custom Transform (upper case text):
	
const { Transform } = require('stream');
class UpperCaseTransform extends Transform {
  _transform(chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
}
process.stdin.pipe(new UpperCaseTransform()).pipe(process.stdout);

	S√¢u: D√πng cho custom pipelines (e.g., real-time data processing trong IoT).




# 6. Real-World Examples

	## HTTP Streaming (video server):
	
	
const http = require('http');
const fs = require('fs');
http.createServer((req, res) => {
  const stat = fs.statSync('video.mp4');
  res.writeHead(200, { 'Content-Length': stat.size, 'Content-Type': 'video/mp4' });
  fs.createReadStream('video.mp4').pipe(res);  // Stream tr·ª±c ti·∫øp
}).listen(3000);


	## Processing Large CSV (d√πng csv-parser):
	
const fs = require('fs');
const csv = require('csv-parser');  // npm i csv-parser
const results = [];
fs.createReadStream('large.csv')
  .pipe(csv())
  .on('data', row => results.push(row))
  .on('end', () => console.log(results.length));
	
	
# 	7. Best Practices
	
	- Error Handling: Lu√¥n on('error') cho t·∫•t c·∫£ streams.
	- D√πng pipeline(): T·ª± cleanup n·∫øu error.
	- Backpressure: Ki·ªÉm tra writable.write() return false ‚Üí ch·ªù 'drain'.
	- End Streams: G·ªçi end() cho writable khi done.
	- Avoid Sync: Kh√¥ng sync ops trong handlers (block Event Loop).
	- Buffer Size: Set highWaterMark cho custom (default 64KB readable, 16KB writable).
	- Warning: Kh√¥ng handle 'error' ‚Üí crash app. Memory leaks n·∫øu kh√¥ng destroy streams.Common Pitfalls: Qu√™n pause/resume ‚Üí overflow; pipe multiple writables ‚Üí data duplicate.	
	
	
	
https://www.w3schools.com/nodejs/nodejs_buffer.asp
	
</pre><a id='backBottom' href='../NodeJS-learning.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {   let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';   document.body.className = mode; localStorage.setItem('theme', mode);   syncTheme();}function applyTheme() {   let savedTheme = localStorage.getItem('theme') || 'dark-mode';   document.body.className = savedTheme;   syncTheme();}function syncTheme() {   let preElement = document.querySelector('pre');   if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }   else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {   let contentHeight = document.body.scrollHeight;   let windowHeight = window.innerHeight;   if (contentHeight > windowHeight * 1.2) {       document.getElementById('backBottom').style.display = 'block';   } else {       document.getElementById('backBottom').style.display = 'none';   }}</script></body></html>