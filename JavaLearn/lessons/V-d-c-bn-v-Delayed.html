<html><head><title>Ví dụ cơ bản về Delayed</title></head><body><h1>Ví dụ cơ bản về Delayed</h1><pre>	Giả sử bạn đang lập trình một hệ thống nhắn tin, nơi một tin nhắn sẽ chỉ được xử lý sau một khoảng thời gian nhất định 
		import java.util.concurrent.TimeUnit;
		import java.util.concurrent.Delayed;
		
		class DelayedMessage implements Delayed {
			private String message;
			private long startTime;
		
			public DelayedMessage(String message, long delayInMillis) {
				this.message = message;
				this.startTime = System.currentTimeMillis() + delayInMillis;
			}
		
			@Override
			public long getDelay(TimeUnit unit) {
				long diff = startTime - System.currentTimeMillis();
				return unit.convert(diff, TimeUnit.MILLISECONDS);
			}
		
			@Override
			public int compareTo(Delayed other) {
				return Long.compare(this.getDelay(TimeUnit.MILLISECONDS), other.getDelay(TimeUnit.MILLISECONDS));
			}
		
			public String getMessage() {
				return message;
			}
		}


		import java.util.concurrent.DelayQueue;
		
		public class DelayedQueueExample {
			public static void main(String[] args) throws InterruptedException {
				DelayQueue<DelayedMessage> queue = new DelayQueue<>();
		
				queue.put(new DelayedMessage("Tin nhắn 1 sau 3 giây", 3000));
				queue.put(new DelayedMessage("Tin nhắn 2 sau 5 giây", 5000));
				queue.put(new DelayedMessage("Tin nhắn 3 sau 1 giây", 1000));
		
				while (!queue.isEmpty()) {
					DelayedMessage msg = queue.take(); // take() sẽ chờ đến khi phần tử có thể lấy ra
					System.out.println("Đã nhận được: " + msg.getMessage());
				}
			}
		}

		
	## Ứng dụng nâng cao : Caching với thời gian hết hạn  
		import java.util.concurrent.DelayQueue;
		import java.util.concurrent.TimeUnit;
		
		class CacheItem implements Delayed {
			private String key;
			private long expireTime;
		
			public CacheItem(String key, long ttl) {
				this.key = key;
				this.expireTime = System.currentTimeMillis() + ttl;
			}
		
			@Override
			public long getDelay(TimeUnit unit) {
				long remainingTime = expireTime - System.currentTimeMillis();
				return unit.convert(remainingTime, TimeUnit.MILLISECONDS);
			}
		
			@Override
			public int compareTo(Delayed other) {
				return Long.compare(this.getDelay(TimeUnit.MILLISECONDS), other.getDelay(TimeUnit.MILLISECONDS));
			}
		
			public String getKey() {
				return key;
			}
		}
		
		public class ExpiringCache {
			private static final DelayQueue<CacheItem> cacheQueue = new DelayQueue<>();
		
			public static void main(String[] args) throws InterruptedException {
				cacheQueue.put(new CacheItem("session_123", 4000));
				cacheQueue.put(new CacheItem("session_456", 2000));
		
				while (!cacheQueue.isEmpty()) {
					CacheItem expiredItem = cacheQueue.take();
					System.out.println("Xóa khỏi cache: " + expiredItem.getKey());
				}
			}
		}
		
		
		CacheItem là một đối tượng có thời gian tồn tại (TTL - Time To Live).
		Sau khi thời gian TTL hết hạn, mục cache sẽ tự động bị loại bỏ.
		DelayQueue đảm bảo rằng chỉ những mục hết hạn mới bị xóa.

</pre></body></html>