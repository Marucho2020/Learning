<html><head><title>Các vấn đề gặp phải khi giao tiếp qua mạng .</title></head><body><h1>Các vấn đề gặp phải khi giao tiếp qua mạng .</h1><pre>
			✅ Các vấn đề gặp phải khi giao tiếp qua mạng:
				Firewall ngăn chặn cổng RMI.
				Địa chỉ IP thay đổi gây lỗi java.rmi.ConnectException.
				Security Policy hạn chế việc tải lớp từ xa.
				Tường lửa NAT không cho phép kết nối hai chiều.



//----------------------------✅ Security Policy trong RMI

	# Khái niệm 
		Java RMI chạy trên môi trường phân tán nên cần bảo mật để tránh bị khai thác 
		
	# Các rủi ro bảo mật 
		
		- Kẻ tấn công gửi mã độc đến server hoặc client 
		- Giao tiếp giữa client-server có thể bị nghe lén  
		- Tải code từ xa có thể bị kẻ xấu lợi  
		
		
	# Security Manager & Policy File 
		
		## Java yêu cầu cài đặt một Security Manager để kiếm soát quyền truy cập 
			
			
			### Bước 1 
			if (System.getSecurityManager() == null) {
				System.setSecurityManager(new SecurityManager());
			}

			### Bước 2  Ta cần một file policy để cấp quyền cho ứng dụng 
				grant {
					permission java.net.SocketPermission "*:1024-65535", "connect,accept";
					permission java.io.FilePermission "/path/to/files/-", "read,write";
					permission java.lang.RuntimePermission "createClassLoader";
				};

			### Bước 3 : Sau đó chạy java với 
				java -Djava.security.policy=policy.txt Server

	
	# Cách hạn chế rủi ro 
		- Không tải mã nguồn từ nguồn không đáng tin cậy 
		- Dùng SSL/TLS để mã hóa giao tiếp RMI 
		- Giới hạn quyền truy cập trong Security Policy 
		- Sử dụng xác thực (Authentication) nếu cần 


//-------------------------✅ RMI Callback (Client gọi ngược lại Server)
	# Khái niệm 
		Mô hình chuẩn của RMI là Client gọi server , nhưng có trường hợp Server cần gọi lại Client  
		
	# Cách triển khai 
		1. Client cung cấp một Remote Interface 
		2. Server phương thức trên Remote Interface của Client 
		
	# Ví du RMI Callback 
		
		## Bước 1 : Client tạo Remote Interface để Server gọi lại 
		
				import java.rmi.*;
				public interface ClientCallback extends Remote {
					void notify(String message) throws RemoteException;
				}


		## Bước 2 : Client triển khai interface 
				import java.rmi.server.*;
	
				public class ClientImpl extends UnicastRemoteObject implements ClientCallback {
					protected ClientImpl() throws RemoteException {
						super();
					}
				
					public void notify(String message) throws RemoteException {
						System.out.println("Server callback: " + message);
					}
				}


		## Bước 3 : Server giữ danh sách Client và gọi lại 
		
				import java.util.*;
				import java.rmi.*;
				
				public class ServerImpl extends UnicastRemoteObject {
					private List<ClientCallback> clients = new ArrayList<>();
				
					protected ServerImpl() throws RemoteException {}
				
					public void registerClient(ClientCallback client) throws RemoteException {
						clients.add(client);
						System.out.println("Client registered.");
					}
				
					public void sendUpdates() throws RemoteException {
						for (ClientCallback client : clients) {
							client.notify("Server message!");
						}
					}
				}


		## Ứng dụng của RMI Callback : 
			Thông báo sự kiện từ Server về CLient(ví dụ tin nhắn mới , giá chứng khoán thay đổi )
			Hệ thống Push Notification trong ứng dụng Java phân tán 
			Mô hình pub-sub (publisher-subscriber)


//------------------------------✅ Dynamic Code Loading trong RMI

	# Khái niệm 
		Dynamic Code Loading cho phép client hoặc server tải mã(class) từ xa trong quá trình thực thi 
		
	# Cách hoạt động 
		- Khi RMI nhận được đối tượng không có trong JVM hiện tại, nó tải class từ một URL bên ngoài 
		- Điều này giúp tránh cần phải phân phối mã từ trước 
		
	# Cách kích hoạt Dynamic Code Loading 
		java -Djava.rmi.server.codebase="http://myserver/classes/" Server


	# Rủi ro bảo mật 
		- Kẻ tấn công có thể cung cấp mã độc qua class tải từ xa 
		-> Giải pháp : Chỉ cho phép tải code từ nguồn tin cậy bằng Security Policy 
		


//==========Lession 48 == gRPC ==========//
	# Khái niệm 
		gRPC là một framework giao tiếp từ xa (RPC) mã nguồn mở do Google phát triển. Nó tận dụng HTTP/2 và Protocol Bufers để tạo nên một hệ thống giao tiếp nhanh, nhẹ và hiệu quả, đặc biệt phù hợp với các hệ thống microservices và ứng dụng đa ngôn ngữ. Dưới đây là cái nhìn chi tiết từ cơ bản đến nâng cao về gRPC 
		
		## Định nghĩa 
		gRPC (g Remote Procedure Call) là một framework RPC giúp bạn gọi các hàm từ xa như thể chúng là hàm cục bộ. Nó sử dụng HTTP/2 làm giao thức và truyền tải và Protocol Buffer(protobuf) làm ngôn ngữ định nghĩa dữ liệu 
		 
		## Đặc điểm nổi bật  
			- HIệu năng cao : Sử dụng HTTP/2 với khả năng multiplexing, giảm độ trễ và tăng hiệu năng. 
			
			- TƯơng tác đa ngôn ngữ : Hỗ trợ nhiều ngôn ngữ lập trình (Java , C++ , Python, Go, ... )
			
			- Giao tiếp theo mô hình RPC : Giúp gọi hàm từ xa như các hàm nội bộ, giảm phức tạp của giao tiếp mạng 
			
			- Hỗ trợ Streaming : Có 4 kiểu giao tiếp : Unary (một-một), Server streaming , Client streaming , Bidirectional streaming 
			
			
	
	# Kiến trúc và cách thức hoạt động của gRPC 
		
		## Cấu trúc cơ bản : 
		
			### Bước 1 : Service Definition 
				Bạn định nghĩa dịch vụ và các phương thức bằng ngôn ngữ định nghĩa giao diện (IDL) của Protocol Bufer trong file .proto 
				
					syntax = "proto3";

					service Greeter {
						rpc SayHello (HelloRequest) returns (HelloResponse);
					}
					
					message HelloRequest {
						string name = 1;
					}
					
					message HelloResponse {
						string message = 1;
					}

		
			### Bước 2 : Code Generation 
				Dựa vào file .proto, công cụ protoc sẽ tạo ra các lớp stub cho cả client và server 
				
			
			## Bước 3 :  Client & Server 
				- Client : Sử dụng stub đã tạo ra để gọi các phương thức của dịch vụ như gọi hàm nội bộ 
				- Server : Triển khai các phương thức được định nghĩa trong file .proto và đăng ký dịch vụ trên server 
				

		
		## Các kiểu RPC trong gRPC 
			
			### Unary RPC 
				Client gửi một yêu cầu và nhận lại một phản hồi duy nhất 
				
			### Server Streaming RPC 
				Client gửi một yêu cầu, server trả về một luồng các phản hồi 
				
			### Client Streaming RPC : 
				Client gửi một luồng yêu cầu, server trả về một phản hồi duy nhất sau khi nhận đủ dữ liệu 
				
			### Bidirectional Streaming RPC 
				Cả Client và server đều gửi luồng dữ liệu độc lập, giao tiếp song song 
		
		
		
		
	# Cách triển khai gRPC 

		## Bước 1 : Định nghĩa dịch vụ (Service Definition )
			Tạo file greeter.proto như ví dụ ở phần trên 
			Sử dụng protoc để sinh mã cho ngôn ngữ bạn cần 
			
					protoc --java_out=. --grpc-java_out=. greeter.proto

			
			
		
		## Bước 2 : Triển khai server 
			Cài đặt các phương thức theo file.proto đã định nghĩa 
			Ví dụ Server triển khai trong Java : 
				import io.grpc.Server;
				import io.grpc.ServerBuilder;
				import io.grpc.stub.StreamObserver;
				
				public class GreeterServer {
					public static void main(String[] args) throws Exception {
						Server server = ServerBuilder.forPort(50051)
							.addService(new GreeterImpl())
							.build()
							.start();
						System.out.println("Server started on port 50051");
						server.awaitTermination();
					}
				
					static class GreeterImpl extends GreeterGrpc.GreeterImplBase {
						@Override
						public void sayHello(HelloRequest req, StreamObserver<HelloResponse> responseObserver) {
							String greeting = "Hello, " + req.getName();
							HelloResponse reply = HelloResponse.newBuilder().setMessage(greeting).build();
							responseObserver.onNext(reply);
							responseObserver.onCompleted();
						}
					}
				}

		
		
		
		## Bước 3 : Triển khai Client 
			Sử dụng Stub để gọi dịch vụ 
				import io.grpc.ManagedChannel;
				import io.grpc.ManagedChannelBuilder;
				
				public class GreeterClient {
					public static void main(String[] args) {
						ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 50051)
							.usePlaintext()
							.build();
						GreeterGrpc.GreeterBlockingStub stub = GreeterGrpc.newBlockingStub(channel);
						
						HelloRequest request = HelloRequest.newBuilder().setName("Alice").build();
						HelloResponse response = stub.sayHello(request);
						System.out.println("Greeting: " + response.getMessage());
						
						channel.shutdown();
					}
				}
				
						
		
	
	# Tính năng nâng cao của gRPC 
		
		## Interceptors 
			Định nghĩa: Các interceptor cho phép bạn chặn và xử lý các yêu cầu hoặc phản hồi, hữu ích để thêm logging, authentication hay xử lý lỗi.
			
			Ứng dụng: Thêm vào pipeline xử lý yêu cầu trên server hoặc client.
		
		

		## Deadlines và Timeouts 
			Định nghĩa: Cho phép bạn đặt thời gian tối đa cho mỗi RPC để tránh chờ đợi vô hạn.

			Cách sử dụng: 
				HelloResponse response = stub.withDeadlineAfter(3, TimeUnit.SECONDS)
					.sayHello(request);




		## Streaming nâng cao 
			Server Streaming : Xử lý các phản hồi dưới dạng luồng, phù hợp với việc truyền dữ liệu lớn 
			
			Client Streaming và Bidirectional Streaming : Tối ưu hóa giao tiếp khi cần gửi/nhận liên tục dữ liệu theo luồng .
			
			
		## Bảo mật (Security ) 
			TLS : gRPC hỗ trợ tích hợp bảo mật bằng TLS, đảm bảo dữ liệu truyền đi được mã hóa 
			
			Authentication : Có thể kết hợp với các cơ chế xác thực như OAuth2 để bảo vệ các dịch vụ 
			
			
		## Load Balancing và Service Discovery 
			gRPC có thể làm việc cùng với các hệ thống load balancing, service registry để hỗ trợ môi trường microservices quy mô lớn. 
			
			
			
</pre></body></html>