<html><head><title>4. Ví dụ sử dụng ArrayBlockingQueue</title></head><body><h1>4. Ví dụ sử dụng ArrayBlockingQueue</h1><pre>	1. Bài toán Producer-Comsumer Example 
					import java.util.concurrent.ArrayBlockingQueue;
					import java.util.concurrent.BlockingQueue;
					
					// Nhà sản xuất
					class Producer implements Runnable {
						private BlockingQueue<Integer> queue;
					
						public Producer(BlockingQueue<Integer> queue) {
							this.queue = queue;
						}
					
						@Override
						public void run() {
							try {
								for (int i = 1; i <= 10; i++) {
									System.out.println("Producer: Producing item " + i);
									queue.put(i); // Thêm phần tử vào hàng đợi (chặn nếu đầy)
									Thread.sleep(500); // Giả lập thời gian sản xuất
								}
							} catch (InterruptedException e) {
								Thread.currentThread().interrupt();
							}
						}
					}
					
					// Người tiêu dùng
					class Consumer implements Runnable {
						private BlockingQueue<Integer> queue;
					
						public Consumer(BlockingQueue<Integer> queue) {
							this.queue = queue;
						}
					
						@Override
						public void run() {
							try {
								while (true) {
									Integer item = queue.take(); // Lấy phần tử từ hàng đợi (chặn nếu rỗng)
									System.out.println("Consumer: Consuming item " + item);
									Thread.sleep(1000); // Giả lập thời gian tiêu thụ
								}
							} catch (InterruptedException e) {
								Thread.currentThread().interrupt();
							}
						}
					}
					
					public class ArrayBlockingQueueExample {
						public static void main(String[] args) {
							// Tạo hàng đợi có kích thước tối đa là 5
							BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);
					
							Thread producerThread = new Thread(new Producer(queue));
							Thread consumerThread = new Thread(new Consumer(queue));
					
							producerThread.start();
							consumerThread.start();
						}
					}

			// Giải thích ví dụ:
				Hàng đợi có kích thước cố định là 5:
				
				Nếu nhà sản xuất cố gắng thêm phần tử vào hàng đợi khi đầy, nó sẽ bị chặn.
				Nếu người tiêu dùng cố gắng lấy phần tử khi hàng đợi rỗng, nó sẽ bị chặn.
				Sự đồng bộ hóa tự động:
				
				ArrayBlockingQueue quản lý việc đồng bộ hóa giữa nhà sản xuất và người tiêu dùng, nên bạn không cần phải sử dụng từ khóa synchronized thủ công.
				Kết quả đầu ra:
				
				Nhà sản xuất thêm phần tử vào hàng đợi, người tiêu dùng lấy phần tử từ hàng đợi theo thứ tự FIFO.


</pre></body></html>