<html><head><title>Hàm static</title></head><body><h1>Hàm static</h1><pre>	5. Hạn chế khi muốn ghi đè (Override)
		Hàm static không thể bị override theo cách thông thường trong kế thừa, vì nó không liên quan đến instance mà liên quan đến class.
		Tuy nhiên, bạn có thể che giấu (hide) hàm static bằng cách khai báo hàm static cùng tên trong class con.
	
	2. Không thể sử dụng biến hoặc phương thức non-static
		Vì hàm static không thuộc bất kỳ instance nào, nên nó không thể truy cập trực tiếp đến các thành phần không tĩnh (non-static) của class.
		Nếu cần dùng biến non-static, bạn phải tạo một instance của class.
			public class Example {
				private int value = 10; // Non-static field
			
				public static void printValue() {
					// System.out.println(value); // Lỗi: Không thể truy cập biến non-static
				}
			}


//-------------------- Mảng 2 chiều  --------------------
int []i1[] = {{'1' , '2' , '3'} , {'4' , '5' , '6'}}  // tương đương với i5 = {{49, 50, 51},{52, 53, 54} }; tức '1' là khai báo giá trị biến char và lấy ra mã unicode từ char đó , 1 =  49 
													// và trong Java có thể cho phép khai báo [] i [] tức là trước và sau biến là [] để đánh dấu là mảng 2 chiều .

		
	
//-------------------- Collection --------------------
	Trong Java , Collection là một giao diện (interface) trong framework java.util , là gốc của hệ thống phân cấp các giao diện khác trong Collection Framework. Nó đại diện cho một nhóm các đối tượng, còn gọi là các phần tử(elements).
	
	Đặc điểm chính : 
		1. Giao diện tổng quát(superinterface):
			- Giao diện Collection là cha của các giao diện khác như List, Set, Queur 
			- Map không kế thừa từ Collection vì nó đại diện cho các ánh xạ cặp key-value thay vì tập hợp các phần tử  
		2. Không thể khởi tạo trực tiếp 
			- Vì Collection là một interface, bạn không thể khởi tạo trực tiếp một đối tượng từ nó. Thay vào đó, bạn sử dụng các lớp con cụ thể như ArrayList, HashSet, hoặc LinkedList 
			
	Một số phương thức quan trọng trong interface Collection  
		- boolean add(E e)                                     : Thêm phần tử vào tập hợp 
		- boolean addAll(Collection<? extends E>c )            : Thêm tất cả các phần tử từ một Collection khác 
		- void clear()                                         : Xóa tất cả các phần tử trong tập h
		- boolean contains (Object o)                          : Kiểm tra tập hợp có chứa một phần tử cụ thể hay không 
		- boolean containsAll(Collection<?> c)                 : Kiểm tra tập hợp có chứa tất cả các phần tử của một Collection khác hay không 
		- boolean isEmpty()                                    : Kiểm tra tập hợp có rỗng hay 
		- Iterator<E> iterator() 							   : Trả về một iterator để duyệt qua các phần tử 
		- boolean remove(Object o)                             : Xóa một phần tử cụ thể ra khỏi Collection 
		- boolean removeAll(Collection<?> c)                   : Xóa tất cả các phần tử của tập hợp này có trong một Collection khác 
		- int size()                                           : Trả về số lượng phần tử trong tập hợp 
		- Object[] toArray()                                   : Trả về một mảng chứa tất cả các phần tử của tập hợp 
	
	# Các Interface con của Collection 
	
	List 
		Danh sách các phần tử có thứ tự 
		Có thể chứa các phần tử trùng lặp 
		Các lớp triển khai phổ biến : ArrayList, LinkedList, Vector 
	Set 
		Tập hợp các phần tử duy nhất không trùng lặp 
		Không đảm bảo thứ tự 
		Các lớp triển khai phổ biến HashSet , LinkedHashSet, TreeSet 
	Queue 
		Cấu trúc hàng đợi FIFO 
		Một số trường hợp hỗ trợ ưu tiên 
		Các lớp triển khai phổ biến : LinkedList , PriorityQueue 
		
		
	
	
//==========Lession 8 == ArrayList ==========//
	 ArrayList là một lớp trong Java thuộc gói Java util, là một phần triển khai của giao diện List. Nó hoạt động như một mảng động cung cấp các tính năng linh hoạt hơn mảng thông thường 
		# Đặc điểm chính : 
			- Kích thước động : Tự động thay đổi kích thước khi thêm hoặc xóa các phần tử  
			- Dựa trên mảng: Dữ liệu được lưu trữ trong một mảng nội bộ 
			- Truy cập nhanh : Truy cập phần tử theo chỉ số(O(1)).
			- Hiệu suất thêm/xóa : Thêm vào cuối nhanh(O(1)), nhưng thêm xóa ở giữa hoặc đầu danh sách có chi phí cao(O(n))
			
		# Các phương thức quan trọng  : 
			- add(E e)	, add(int index,  E element )		: Thêm phần tử vào cuối hoặc vị trí index cụ thể -> nếu index > size() sẽ ném IndexOutOfBoundException  
			
			- remove(int index) và remove(Object o)  		: Xóa phần tử tại chỉ số hoặc theo giá trị, Nếu không tìm thấy giá trị, remove(Object O) không ném lỗi chỉ trả về false 
			
			- set(int index , E element ) : Thay thế phẩn tử tại chỉ số index 
				
			- get(int index) 	: Lấy phẩn tử tại chỉ số index 

			- size() 		: Trả về số lượng phần tử trong danh sách  
			
		# Các phương thức nâng cao 
			- isEmpty() 	: Kiểm tra danh sách có rỗng không 
			- contains(Object o)	: Kiểm tra xem danh sách có chứa một phần tử cụ thể không 
			- indexOf(Object o) và lastIndexOf(Object o)	: Trả về chỉ số xuất hiện đầu tiên hoặc cuối cùng trong phần tử 
			- toArray()  : Chuyển đổi tử ArrayList sang Array 
			- subList(int fromIndex , int toIndex) : Trả về một danh sách con (sublist) từ fromIndex đến toIndex -1 
			
		# Vấn đề hiệu suất  
			Khi nào nên sử dụng ArrayList 
				- Khi cần truy cập phần tử nhanh qua chỉ số 
				- Khi số lượng thêm/xóa không lớn hoặc chủ yếu thao tác ở cuối danh sách 
			 ## Nhược điểm của ArrayList 
				
				- Chi phí mở rộng mảng  
					Khi mảng nội bộ đầy, ArrayList tạo ra một mảng mới với kích thước gấp 1.5 lần và sao chép dữ liệu từ mảng cũ sang mảng mới. Quá trình này tốn tài nguyên 
				
				- Xóa/ Thêm ở giữa hoặc đầu 
					Khi xóa/ thêm ở giữa danh sách , các phần tử phía sau phải dịch chuyển(O(n))
				
				- Không đồng bộ (Non Thread-Safe )
					ArrayList Không đồng bộ, không được phù hợp cho các ứng dụng đa luồng trừ khi được quản lý thủ công hoặc dùng 
					Collections.synchronizedList 
				
		# So sánh với các cấu trúc khác  
				Đặc điểm			ArrayList		LinkedList			Vector
				Truy cập			Nhanh (O(1))	Chậm (O(n))			Nhanh (O(1))
				Thêm/xóa ở đầu		Chậm (O(n))		Nhanh (O(1))		Chậm (O(n))
				Đồng bộ				Không			Không				Có
				Mở rộng kích thước	Gấp 1.5 lần		Không áp dụng		Gấp đôi
				
			
		
		# Chuyển đổi từ  ArrayList và các cấu trúc khác : 
			Từ ArrayList sang mảng : 
				ArrayList<String> lst = new ArrayList<>();
				lst.add("a"); lst.add("b");
				String[] arr = lst.toArray(new String[0]);
				
			Từ Mảng sang ArrayList 
				String[] arr = {"a" , "b" , "c"};
				ArrayList<String> lst = new ArrayList<>(Arrays.asList(arr));
			
			Từ ArrayList sang LinkedList: 
				LinkedList<String> linkedList = new LinkedList<>(list);
				
		# Vấn đề đồng bộ hóa(Thread-Safety ) :
			Đồng bộ hóa với Collections.synchronizedList
				List<String> syncList = Collections.synchronizedList(new ArrayList<>());
				
			Ví dụ trong sử dụng đa luồng  
				synchronized(list){
					for(String s : list){
						System.out.println(s);
					}
				}
			
		# Sử dụng ArrayList với Generics 
			Generics giúp đảo bảo kiểu dữ liệu 
			- Tránh lỗi Runtime 
			
			ArrayList<Integer> numbers = new ArrayList<>();
			number.add(1)
			int value = numbers.get(0		// không cần ép kiểu  
			
		
		# Hiểu chi tiết về Sublist: 
			Cách hoạt động : 
				subList(int fromIndex , int toIndex) tạo một view trên danh sách gốc , không phải bản sao .
				- Thay đổi giá trị trong sublist cũng thay đổi giá trị trong danh sách gốc 
				- THAY ĐỔI CẤU TRÚC TRONG DANH SÁCH GỐC(THÊM / XÓA), VIỆC TRUY CẬP SUBLIST SẼ GÂY LỖI (ConcurrentModificationException)
				
				ArrayList<String> list = new ArrayList<>(Arrays.asList("a" , "b", "c" , "d" , e ));
				List<String> subList = list.subList(1, 4)  // [b , c , d]  ->  getIndex  1 ,  2  , 3 
				subList.set(1 , "x") // Thay đổi sublist cũng làm thay đổi giá trị của list gốc 
				System.out.println(list)  // [a, b, x, d, e]
			
			
			
		# Các lỗi thường gặp khi làm việc với ArrayList 
			- IndexOutOfBoundException : Thêm xóa các phần tử tại chỉ số không hợp lệ  
			- ClassCastException : Xảy ra khi không sử dụng Generics và có ép kiểu sai 
			- ConcurrentModificationException : Khi danh sách bị thay đổi trong khi đang duyệt bằng Iterator hoặc for-each 
			
			
//==========Lession 9 == LinkedList ==========//
			
</pre></body></html>