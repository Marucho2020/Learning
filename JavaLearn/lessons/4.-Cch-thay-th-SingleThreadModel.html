<html><head><title>4. Cách thay thế SingleThreadModel</title></head><body><h1>4. Cách thay thế SingleThreadModel</h1><pre>				
			
	## 🔹 Cách 1: Dùng synchronized (Không khuyến khích) 
		Đặt synchronized vào doGet() hoặc doPost(), nhưng làm giảm hiệu suất.
				@WebServlet("/sync")
				public class SyncServlet extends HttpServlet {
					private int counter = 0;
				
					protected synchronized void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
						counter++;
						resp.getWriter().println("Counter: " + counter);
					}
				}

					⚠ Nhược điểm:
		
					Tất cả request phải chờ nhau, giảm tốc độ xử lý.
			
			
			
			
	## 	🔹 Cách 2: Dùng ThreadLocal để tạo biến riêng cho từng request	
	
	
			@WebServlet("/threadlocal")
			public class ThreadLocalServlet extends HttpServlet {
				private ThreadLocal<Integer> counter = ThreadLocal.withInitial(() -> 0);
			
				protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
					counter.set(counter.get() + 1);
					resp.getWriter().println("Counter: " + counter.get());
				}
			}
	
			🚀 Ưu điểm:
			Không cần đồng bộ hóa.
			Mỗi request có một biến riêng, tránh lỗi race condition.	🚀 Ưu điểm:
			
			Không cần đồng bộ hóa.
			Mỗi request có một biến riêng, tránh lỗi race condition.
			
			
			
	## 	🔹 Cách 3: Dùng Stateless Servlet (Cách tốt nhất)
			
			Không dùng biến instance để tránh vấn đề đồng bộ hóa.
			📌 Ví dụ: Servlet Stateless
			
			@WebServlet("/stateless")
			public class StatelessServlet extends HttpServlet {
				protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
					int counter = Integer.parseInt(req.getParameter("count")); // Không dùng biến instance
					resp.getWriter().println("Counter: " + (counter + 1));
				}
			}

			✅ Lợi ích:

Servlet không giữ trạng thái, mọi request độc lập với nhau.
Không lo lắng về đồng bộ hóa hay bộ nhớ.
			


//==========Lession 53 == ThreadLocal & Stateless Servlet ==========//

</pre></body></html>