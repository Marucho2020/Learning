<html><head><title>Cách hoạt động</title></head><body><h1>Cách hoạt động</h1><pre>				
	Khi một servlet implement SingleThreadModel, server có hai cách xử lý request:

	Tạo một instance servlet mới cho mỗi request.
	Dùng một pool servlet instance để xử lý nhiều request song song.
	💡 Lý do: Servlet bản chất là đa luồng (multi-threaded), nếu nhiều request đến cùng lúc, có thể gây ra vấn đề race condition nếu servlet có biến instance chung


	## 📌 Ví dụ: Servlet không thread-safe 
		@WebServlet("/unsafe")
		public class UnsafeServlet extends HttpServlet {
			private int counter = 0;  // Biến instance dùng chung
		
			protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
				counter++;  // Có thể bị ghi đè bởi nhiều luồng khác nhau!
				resp.getWriter().println("Counter: " + counter);
			}
		}
		
			⚠ Lỗi có thể xảy ra: 
			Nếu 2 request chạy song song, biến counter có thể bị ghi đè không mong muốn, dẫn đến bug dữ liệu.
			
			
			
	## 		📌 Dùng SingleThreadModel để tránh lỗi trên 
			@WebServlet("/safe")
			public class SafeServlet extends HttpServlet implements SingleThreadModel {
				private int counter = 0;  // Biến instance không bị truy cập đồng thời
			
				protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
					counter++;  
					resp.getWriter().println("Counter: " + counter);
				}
			}

			🚀 Lúc này, mỗi request có một instance servlet riêng, tránh được lỗi đồng bộ hóa.
			
			
</pre></body></html>