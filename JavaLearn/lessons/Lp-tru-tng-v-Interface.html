<html><head><title>Lớp trừu tượng và Interface</title></head><body><h1>Lớp trừu tượng và Interface</h1><pre>

	
		- Các class không thể truy cập trực tiếp vào các phần tử của class cha nếu : các phần tử đó là private 
			- Private chỉ cho phép truy cập từ trong nội bộ của class(kể cả class con cũng không thể )
			
		- Trong một class khi gọi constructor của chính nó phải gọi this()  chứ không được gọi ClassName()   
			Vì constructor là đặc biệt nên cách sử dụng bên trong nội bộ và bên ngoài khác nhau , bên trong this() , bên ngoài ClassName()  , Tuyệt đối ko đc làm ngược lại 
		
		- Trong lớp con khi định nghĩa constructor mặc định mà không có super() thì sẽ tự động thêm implicit câu gọi super() và đầu của logic constructor 
			-> java sẽ luôn gọi super() trước khi thực hiện constructor của sub class , -> không có super() nhưng nó sẽ vẫn tự thêm vào để chương trình chạy đúng  
	
		
	# Abstract Class 
		- Abstract class có thể kế thừa lại từ một class khác (class cha không bắt buộc phải là Abstract , Abstract hay class cụ thể đều OK )

		

	
	# Abstract method 	
		- Trong Interface có thể khai báo abstract nhưng bắt buộc phải là PUBLIC method , 
		- còn trong abstract class thì abstract method KHÔNG BẮT BUỘC phải là public 
		- Nếu method trong một lớp trừu tượng là abstract method thì mới có thể khai báo hàm không mà không có nội dung hàm, public abstract void run(); , còn đâu nếu k phải là abstract method thì BẮT BUỘC phải có nội dung hàm hoặc cặp ngoặc {} rỗng 
		- 		abstract int func() ;  // OK 
		abstract int func() {}	// ERROR lỗi k đc dùng {} trong abstract method
		abstract int num ; 		// ERROR Không có abstract variable 
		trong abstract class public int func() {logic herre}	// OK 
		
		
		
		
	# Interface
		Interface Không được kế thừa từ abstract class , nó CHỈ CÓ THỂ IMPLEMENTS(実装) từ một interface khác thôi 
	
	
	
	//====== Giải thích nghĩa của các ngoại lệ : 
	
		IllegalArgumentException : Là một ngoại lệ UncheckedException , Được ném ra khi một phương thức nhận một đối số không phù hợp với param được yêu cầu trong hàm , ví dụ thường gặp là ép kiểu Integer.ParseInt("17b") truyền vào 1 đối số cả chữ và số và muốn ép sang kiểu int 
	
	
	
//---------------- Xử lý ngoại lệ ------------------------------------

	Ta có cây ngoại lệ như sau 
		
	Throwable
	│
	├── Error
	│   ├── IOError
	│   └── VirtualMachineError
	│
	└── Exception
		├── RuntimeException 
		│   └── IllegalArgumentException, NumberFormatException, NullPointerException
		├── IOException
		│   └── FileNotFoundException
		├── SQLException
		└── ClassNotFoundException
		
		
	java.lang.Throwabe : Là class cha của tất cả các class xử lý và ném ra ngoại lệ trong JVM 	
	
	Error : Là class xử lý các lỗi xảy ra ở phần cứng và bộ nhớ, Không liên quan đến logic của phần mềm(source code)
	
	Exception : Là class cha của các class ném ra ngoại lệ lỗi khi phần mềm(source code) gặp sự cố lỗi 
	
	RuntimeExeption : Và class con của nó thực hiện xử lý lỗi TRONG KHI CHƯƠNG TRÌNH CHẠY , chứ không phụ trách lỗi khi complier 
		-->	Các class con của Exception *(NGOẠI TRỪ RUNTIME EXCEPTION VÀ CÁC CLASS CON CỦA NÓ ) :  Là những lớp ngoại lệ để kiểm tra ngoại lệ trong quá trình Complier 
		

	## Phân loại 
		- Ngoại lệ unchecked  (チェックされない例外) : Là những ngoại lệ không được kiểm tra có xử lý không khi chương trình biên dịch . Cụ thể là các ngoại lệ của lớp RunTimeException và các lớp con của nó 
		
	
		- Ngoại lệ checked (チェック例外) : Là ngoại lệ được kiểm tra có được xử lý không khi chương trình complier , nếu xử lý thiếu các ngoại lệ này ở các caller ... thì sẽ báo lỗi biên dịch . Tức là toàn bộ các class ngoại lệ trừ RunTimeException


	
		
	
	
	
	//---------------- Các loại Exception phổ biến ---------------------------// 
	
	###  RuntimeException    và các class con của nó 
	
	- ArrayIndexOutOfBoundsException : Tràn vùng nhớ của mảng 
	- ArthmeticException : Ngoại lệ thuật toán : Một số thực hiện chia cho 0 sẽ ra lỗi này  
	- ClassCastException : Ngoại lệ khi ép kiểu không tương thích 
	- NumberFormatException :  Ngoại lệ khi ép kiểu String sang Số không được 
	- NullPointerException : Sử dụng một biến là Null  
	
	
	###  Erorr và các class Con của nó  
	
	- OutOfMemoryError : Lỗi tràn vùng nhớ , thiếu RAM 
	
	
	### Exception và các class con của nó -> Ngoại trừ RuntimeException
		### Những class thuộc nhóm này là : NHỮNG CLASS CẦN THIẾT CHO XỬ LÝ NGOẠI LỆ :例芸処理が必須クラス
		- ClassNotFoundException : Không tìm thấy class khi biên dịch 
		- FileNotFoundException : Không tìm thấy file xử lý 
		- IOException 		: Lỗi liên quan đến input , output 
		
		
	
	
	
	//------------ Khai báo một lớp dùng để xử lý ngoại lệ 
	--> PHẢI KẾ THỪA LẠI TỪ LỚP EXCEPTION 
	public VideoControlException extends Exception  {
		// Logic 
	}
	
	
	//-------------- Throwabe class----------------
	
	- Các method để lấy ra lỗi từ class Throwabe 
		
		void printStackTrace(); 		// In ra thông báo lỗi ra console 
		String getMessage(); 			// Lấy ra thông báo lỗi 
	--> Các class khi gọi hàm có throws ném ra ngoại lệ (KHÔNG PHẢI LÀ NGOẠI LỆ RunTimeException ) thì bắt buộc phải xử lý ngoại lệ nếu không . COMPLIER sẽ lỗi 	
	--> Vậy khi có chỗ ném ra ngoại lệ(trừ ngoại lệ RunTimeException) thì hàm chứa nó và TẤT CẢ CÁC hàm gọi đến nó liên quan đến nó sẽ cần phải có trycatch hoặc throws Exception ở phần khai báo hàm 
	---> Cẩn thận với những chỗ có throws , code xử lý mà có throws new Exception() thì hàm chứa nó + hàm gọi hàm chứa nó sẽ phải có trycatch hoặc throws ở phần khai báo hàm,(Bắt buộc chỗ nào caller throws Exception thì phải có xử lý ngoại lệ k là sẽ complier lỗi )	
	
		## Quy tắc khi override phương thức có throws 
		
			1. Giảm hoặc giữ nguyên phạm vi ngoại lệ : Phương thức override trong lớp con có thể 
				- Không khai báo bất kỳ ngoại lệ nào(không sử dụng throws giống class cha )
				- Khai báo ngoại lệ cùng loại hoặc NHỎ hơn về phạm vi so với method ở class cha  
				- KHÔNG KHAI BÁO NGOẠI LỆ LỚN HƠN HOẶC KHÁC SO VỚI NGOẠI LỆ CỦA LỚP CHA 
			2. Không tăng phạm vi ngoại lệ : 
				- Nếu phương thức của lớp cha khai báo throws , lớp con không được phép khai báo thêm ngoại lệ checked lớn hoặc hoặc hoàn toàn mới không có trong lớp cha 
				- Nếu lớp cha không có ngoại lệ thì lớp con TUYỆT ĐỐI KHÔNG được có ngoại lệ (throws ..)
				
			3. Ngoại lệ unchecked (RuntimeException hoặc các con của nó ) 
				- Bạn có thể thêm hoặc bỏ việc khai báo chúng 
				
				//***** Sơ đồ hình dung mức ngoại lệ : Lớp cha luôn phải có class Ngoại lệ lớn hơn hoặc bằng lớp con 
				//****** Nếu làm sai sẽ không thể Complier và báo lỗi tại lớp con sai trái 
			->   Ngoại lệ :   Lớp cha  >=  Lớp con  	
			
			!!! Chú ý : 
				- Những điều 1 2 3 chỉ áp dụng cho các ngoại lệ Checked Exceptions , Còn nếu gặp ngoại lệ Unchecked Exception(RunTimeException) thì JVM sẽ bỏ qua không kiểm tra tính đúng sai hợp lệ của nó .
				Do đó nếu lớp con có khai báo ngoại lệ lớn hơn phạm vi ngoại lệ của lớp cha nhưng đều là Unchecked Exception
				thì sẽ không gây ra lỗi khi biên dịch . VÌ BẢN CHẤT LÀ Unchecked Exception mà 
			
			
			-> Tại sao lại loằng ngoằng thế ?  : Bởi vì khi JVM biên dịch (Build) chương trình, nếu để lại các RunTimeException thì khi biên dịch sẽ làm nặng chương trình và có thể gây ra việc biên dịch rất lâu. Cho nên nhà phát triển Java đã chia thành 2 nhóm CheckedException và UncheckedException để JVM phân biệt chúng và chỉ kiểm tra tính hợp lệ của nhóm CheckedExeption khi biên dịch thôi. Còn UncheckedException là class RunTimeException và các con của nó, bản chất nó là lỗi sẽ xảy ra khi hoạt động(Runtime) nên không cần thiết phải kiểm tra trước 
			
			
		
	//------------------ Try-catch ---------------------
	Catch có thể bắt toàn bộ các class Exception và class con của nó -> NHƯNG KHÔNG THỂ BẮT ĐƯỢC OBJECT 
	
	Có 2 cách để ngăn chặn lỗi xảy ra ở một method : 1> Cho khối code có khả năng xảy ra lỗi trong method đó vào try-catch ,
													2> Đặt Throws vào chỗ gọi hàm đó để bắt lỗi khi gọi hàm 
													
	- Khi bắt ngoại lệ từ 1 hàm , chỉ có thể bắt được chính ngoại lệ được ném ra hoặc CLASS CHA của ngoại lệ đó-> KHÔNG THỂ BẮT BẰNG NGOẠI LỆ CLASS CON ĐƯỢC VÌ SẼ BỊ SÓT  
	
	- Bắt buộc phải có try-catch khi gọi đến các method CheckedException, Và KHÔNG BẮT BUỘC khi gọi đến các method UncheckedException
	
	

	# exception hierarchy 
		- Khi viết khối try-catch bắt buộc phải viết theo thứ tự cây phân cấp trở lên, tức là class con, rồi class cha ... TUYỆT ĐỐI K ĐƯỢC VIẾT NGƯỢC NHƯ VÍ DỤ DƯỚI ĐÂY 
		- Đối với các class ngoại lệ KHÔNG có quan hệ kế thừa thì viết thứ tự nào cũng được không quan trọng  
		- Tại sao : Lỗi này liên quan đến tính chất đa hình(polimorphism) và cấu trúc kế thừa inheritance trong hệ thống ngoại lệ của Java ,Khối catch đầu tiên phù hợp được thực thi thì các khối sau sẽ được bỏ qua, vì vậy nó sẽ dễ dẫn tới việc có thể không thực hiện đúng chính xác ngoại lệ đang xảy ra vì nó thực  hiện vào lớp cha và thoát mất rồi, còn lớp chính xác hơn nằm ở dưới sẽ bị bỏ qua . -> Đảm bảo tính chính xác và tính dự đoán của chương trình  
		- Nó còn giúp ngăn lỗi logic (unreachable code) , Tránh trường hợp ngoại lệ bị nuốt bởi khối cha 
		- Tăng tính minh bạch và giúp mã dễ đọc, dễ bảo trì  
		
	### e.g lỗi 	
	public static void main(String[] args){
		try{
			String a ;
		}catch(Exception e){					// Exception là class cha 
			e.printStackTrace();
		}catch(RuntimeException e) {			// RuntimeException là class con của nó, viết theo thứ tự này sẽ lỗi 
			e.printStackTrace();
		}
	
	}
	
	### e.g đúng  
		public static void main(String[] args){
		try{
			String a ;
		}catch(RuntimeException e){					//  RuntimeException là class con của Exception nên phải viết trước
			e.printStackTrace();
		}catch(Exception e) {						// Exception là class cha nên phải viết sau 
			e.printStackTrace();
		}
	
	}
	
	
	//==================== throws và throw ====================================
	// Cẩn thận đừng nhầm lẫn nhé 
	 
	
	//---------------- throws -------------------------  có S -> dùng cho method và class tức là có thể xảy ra nhiều ngoại lệ ở nhiều chỗ 
	- Mục đích sử dụng từ khóa Throws : Khai báo ngoại lệ 
	 
	 - Từ khóa throws sử dụng để khai báo ngoại lệ có thể xảy ra tại một method, hoặc một class  
	
	Với hàm được khai báo từ khóa Throws , Bên trong nội dung hàm đó không cần phải xử lý ngoại lệ , Công việc xử lý ngoại lệ sẽ được giao cho Caller nơi gọi nó xử lý 
	- Lúc này tại nơi xử lý gọi nó sẽ có thể TÙY Ý sử dụng Exception nào để bắt lấy ngoại lệ được ném ra từ hàm đó, Điều này giúp lập trình viên tùy biến và bắt được nhiều trường hợp ngoại lệ , và mỗi chỗ gọi ta có thể định nghĩa cho một ngoại lệ khác nhau  
	
	//------------------- throw ------------------------ không S -> dùng cho code xử lý chỉ định vị trí sẽ ném ra ngoại lệ 
	- Mục đích sử dụng từ khóa throw : Ném ngoại lệ 
	 - Từ khóa throw sử dụng để NÉM ra ngoại lệ, ngược lại với throws , throw chỉ được sử dụng trong mã xử lý và thường đi kèm với new (VD : throw new NullPointerException )
	 
	 
	 
	 
	 
	 //=============== Package các nhóm Exception 
	
	java.lang : 
				- ArrayIndexOutOfBoundsException
				- IllegalArgumentException 	-> NumberFormatException 			
				- NullPointerException
				- SecurityException 
	
	
	java.io 
				- IOException
	
	
	//------------------ Iterator ----------------------------- 
	Iterator là một đối tượng thuộc lớp triển khai Iterable (List m Set , Queue)
	- Iterator không Phải là Iterable nên không thể duyệt theo index giống như list 
	- Iterator không cho phép thay đổi cấu trúc collection trong khi duyệt qua (ngoại trừ sử dụng phương thức remove() của chính Iterator )
	- Iterator là đơn hướng, nghĩa là chỉ có thể đi từ đầu đến cuối giống thời gian , không thể quay lại 
	- Nếu cần duyệt 2 chiều, phải sử dụng ListIterator(áp dụng cho danh sách như ArrayList,LinkedList)
	
	
	
	 # Các phương thức của Iterator 
		hasNext()          : Kiểm tra xem còn phẩn tử có thể đi tiếp không 
		next()             : đi tiếp đến phần tử tiếp theo 
		remove()           : xóa phần tử cuối cùng được trả về next() trước đó(nếu chưa gọi next lần nào sẽ lỗi vì khi này chưa đi vào chạy được xíu nào đã xóa nên k xóa được và lỗi IllegalStateException 
		)
		
	# Ví dụ sử dụng LỖI khi sử dụng Iterator duyệt như List 
	
	List list = new ArrayList();        list.add("1");list.add("2");list.add("3");
	Iterator iterator = list.iterator();
		
	for (Object obj : iterator) {			/./ Lỗi tại đây vì k thể duyệt Iterator thế này đâu bạn 
		System.out.println(obj + " , ");
	}
	
	
	# Ví dụ ĐÚNG khi muốn duyệt qua một iterator 
	while(iterator.hasNext()){
		String num = iterator.next();
		System.out.println(num);			 1 , 2 , 3 
	}
	
	# Ví dụ duyệt 2 chiều List Iterator  
	ListIterator<String> lstIterator = list.listIterator();
	
	//duyệt xuôi 
	while(lstIterator.hasNext()){
		System.out.println(lstIterator.next())			// 1 ,  2 ,  3 
	}
	
	//duyệt ngược 
	while(lstIterator.hasPrevious()){
		System.out.println(lstIterator.previous())		// 3 , 2  ,  1
	}
	


//==========Lession 4 == functional interface ==========//
		
//==========Lession 5 ==Predicate ==========//
 Predicate trong java là một functional interface (giao diện chức năng )được giới thiệu trong Java 8 thuộc gói java.util.function 
 Nó đại diện cho một phép thử logic boolean trên một đối tượng kiểu cụ thể 
 
 # Cú pháp : 
	@FunctionalInterface 
	public interface Predicate<T>{
		boolean test(T t);
	}
	
 # Các phương thức chính : 
	- boolean test(T t) -> thực hiện kiểm tra logic và trả về true hoặc false 
	- Thường được sử dụng để kiểm tra điều kiện(filter , validate )
	
	
	# Ví dụ sử dụng kết hợp với lambda 
	// gọi hàm và truyền vào method xử lý là lambda kiểm tra xem cái nào có point nhỏ hơn 500 thì sẽ là true 
	func(list, (Customer c) -> c.getPoint() < 500 );

	public static void func(List<Customer> list , Predocate<Customer> p ) {
	for(Customer c : list) {		
		if(p.test(c)){		// test là hàm của Predicate FunctionalInterface Nếu cái nào thỏa mãn điều kiện truyền vào thì sẽ vào if
			System.out.println(c.getName());
		}
	}
	}
//==========Lession 6 == Vấn đề chia cho 0 ==========//

Trong Java các trường hợp số chia cho số 0 sẽ có 2 trường hợp   

	- Thực hiện phép chia  / 0
	- Thực hiện phép chia lấy dư % 0 

	- Trường hợp chia cho số double 0.0 
	
	
</pre></body></html>