<html><head><title>Các dùng Reflection trong Java</title></head><body><h1>Các dùng Reflection trong Java</h1><pre>
	## 🔹 Lấy thông tin lúc Runtime 
		Dùng Class<?> để lấy thông tin về một class 
		📌 Lệnh Class.forName("Tên class") giúp lấy class tại runtime! 
		
		
		Class<?> clazz = Class.forName("com.example.Person");
		System.out.println("Class Name: " + clazz.getName());

	
	## 🔹 Lấy danh sách Constructor 

		Constructor<?>[] constructors = clazz.getDeclaredConstructors();
		for (Constructor<?> constructor : constructors) {
			System.out.println("Constructor: " + constructor);
		}



	## 🔹 Lấy danh sách Field (biến)
	
		Field[] fields = clazz.getDeclaredFields();
		for (Field field : fields) {
			System.out.println("Field: " + field.getName());
		}


	## 🔹 Lấy danh sách Method 
	
		Method[] methods = clazz.getDeclaredMethods();
		for (Method method : methods) {
			System.out.println("Method: " + method.getName());
		}

		

	## 🔹 Truy cập Field private (Hack biến private)
		Bình thường không thể truy cập biến private, nhưng với Reflection thì có thể:
		
		Person person = new Person();
		Field nameField = clazz.getDeclaredField("name");
		nameField.setAccessible(true); // Bypass private!
		nameField.set(person, "John Doe"); // Gán giá trị mới
		System.out.println(person.getName()); // In ra John Doe

	🚨 Lưu ý: Việc này phá vỡ nguyên tắc đóng gói (encapsulation), nên chỉ dùng khi thực sự cần
	
	
	## 🔹 Gọi Method tại runtime 
		Method method = clazz.getDeclaredMethod("sayHello");
		method.invoke(person);  // Gọi sayHello() mà không cần biết trước class
 
		📌 Ứng dụng: Spring dùng để gọi Bean method tự động.

	

	## 🔹 Tạo Object tại runtime 
	
		Constructor<?> constructor = clazz.getDeclaredConstructor();
		Person person = (Person) constructor.newInstance(); // Tạo object
		System.out.println(person);



</pre></body></html>