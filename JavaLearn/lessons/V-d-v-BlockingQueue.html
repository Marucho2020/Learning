<html><head><title>Ví dụ về BlockingQueue</title></head><body><h1>Ví dụ về BlockingQueue</h1><pre>	Dưới đây là ví dụ về cách sử dụng BlockingQueue để giải quyết bài toán nahf sản xuất và người tiêu dùng  
		
								class Producer implements Runnable {
									private BlockingQueue<Integer> queue;
								
									public Producer(BlockingQueue<Integer> queue) {
										this.queue = queue;
									}
								
									@Override
									public void run() {
										try {
											int i = 0;
											while (true) {
												queue.put(i);  // Thêm phần tử vào hàng đợi, sẽ chặn nếu hàng đợi đầy
												System.out.println("Produced: " + i);
												i++;
												Thread.sleep(1000);  // Giả lập thời gian sản xuất
											}
										} catch (InterruptedException e) {
											Thread.currentThread().interrupt();
										}
									}
								}
								
								class Consumer implements Runnable {
									private BlockingQueue<Integer> queue;
								
									public Consumer(BlockingQueue<Integer> queue) {
										this.queue = queue;
									}
								
									@Override
									public void run() {
										try {
											while (true) {
												Integer item = queue.take();  // Lấy phần tử ra khỏi hàng đợi, sẽ chặn nếu hàng đợi rỗng
												System.out.println("Consumed: " + item);
												Thread.sleep(1500);  // Giả lập thời gian tiêu thụ
											}
										} catch (InterruptedException e) {
											Thread.currentThread().interrupt();
										}
									}
								}
								
								public class BlockingQueueExample {
									public static void main(String[] args) {
										BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);  // Hàng đợi có dung lượng tối đa là 10
								
										Thread producerThread = new Thread(new Producer(queue));
										Thread consumerThread = new Thread(new Consumer(queue));
								
										producerThread.start();
										consumerThread.start();
									}
								}


			// Giải thích  
			Producer (Nhà sản xuất) sẽ liên tục tạo ra các số nguyên và thêm chúng vào BlockingQueue. Nếu hàng đợi đầy, put() sẽ chặn và đợi cho đến khi có không gian trống
			
			Consumer (Người tiêu dùng)
				Sẽ liên tục lấy ra các số nguyên từ BlockingQueue và in ra . Nếu hàng đợi rỗng, take() sẽ chặn và đợi cho đến khi có phần tử mới trong hàng đợi. 
				
</pre></body></html>