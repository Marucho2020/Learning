<html><head><title>GSON</title></head><body><h1>GSON</h1><pre>	
	Đơn giản và ít tùy chỉnh hơn Jackson 
	
	
	## Dependency 
			<dependency>
				<groupId>com.google.code.gson</groupId>
				<artifactId>gson</artifactId>
				<version>2.10</version>
			</dependency>



	## Serializable đơn giản với GSON 
		import com.google.gson.Gson;
		class Student {
			public String name;
			public int age;
		
			public Student(String name, int age) {
				this.name = name;
				this.age = age;
			}
		}
		
		public class GsonExample {
			public static void main(String[] args) {
				Gson gson = new Gson();
		
				// Serialize
				Student student = new Student("Bob", 22);
				String json = gson.toJson(student);
				System.out.println("Serialized JSON: " + json);
		
				// Deserialize
				Student deserializedStudent = gson.fromJson(json, Student.class);
				System.out.println("Deserialized Object: " + deserializedStudent.name);
			}
		}

		--> {"name":"Bob","age":22}
		
		

Câu hỏi																			Câu trả lời
Khi nào nên dùng Jackson thay vì Gson?								Khi cần tốc độ và tùy chỉnh mạnh mẽ bằng annotation.
@JsonIgnore dùng để làm gì?											Để bỏ qua một field khi serialize.
@JsonProperty("id") có tác dụng gì?									Đổi tên field trong JSON thành "id".
Gson có hỗ trợ annotation như Jackson không?						❌ Không, Gson không mạnh về annotation.
Khi nào nên dùng @JsonInclude(JsonInclude.Include.NON_NULL)?		Khi muốn bỏ qua các field có giá trị null.


Jackson mạnh hơn Gson, nhưng phức tạp hơn.
Gson đơn giản, dễ dùng, nhưng ít tùy chỉnh hơn.



//==========Lession 39 == transient ==========//
	
	# Khái niệm 
		transient là một từ khóa(modifier) được sử dụng trong serialization để chỉ định rằng một biến của đối tượng KHÔNG nên được lưu trữ khi thực hiện (serialized) 
		
		- Khi bạn lưu một object vào file, db , hoặc gửi qua mạng, Java sẽ chuyển object thành byte stream(serialization)
		- Một sô biến có thể chứa dữ liệu nhạy cảm hoặc không cần thiết để lưu trữ(mật khẩu, cache , token , session ID , socket ... )
		- Sử dụng transient giúp ngăn không cho các biến này bị serialize 
		📌 transient chỉ áp dụng cho instance variable 
				-> Không dùng được với biến static (static transient không có ý nghĩa)
				-> Không dùng với  biến local trong method 
				
				
		
		
		
						import java.io.*;
				
						class User implements Serializable {
							private static final long serialVersionUID = 1L;
							
							String username;
							transient String password; // Không được serialize
						
							public User(String username, String password) {
								this.username = username;
								this.password = password;
							}
						}
						
						public class TransientExample {
							public static void main(String[] args) throws Exception {
								User user = new User("admin", "123456");
						
								// Serialize object
								FileOutputStream fos = new FileOutputStream("user.ser");
								ObjectOutputStream oos = new ObjectOutputStream(fos);
								oos.writeObject(user);
								oos.close();
								fos.close();
						
								// Deserialize object
								FileInputStream fis = new FileInputStream("user.ser");
								ObjectInputStream ois = new ObjectInputStream(fis);
								User deserializedUser = (User) ois.readObject();
								ois.close();
								fis.close();
						
								// Kết quả: password bị mất do transient
								System.out.println("Username: " + deserializedUser.username); // admin
								System.out.println("Password: " + deserializedUser.password); // null
							}
						}
	

//==========Lession 40 == serialVersionUID ==========//

	# Khái niệm 
		Là một hằng số dùng trong serialization để xác định phiên bản của class 
		
	#📌 Vấn đề khi không có seriaVersioUID
		- Khi serialize một object, Java lưu cả cấu trúc của class 
		- Nếu sau này bạn sửa đổi class (thêm field ,  xóa field , đổi kiểu dữ liệu) rồi deserialize object cũ. Java sẽ báo lỗi InvalidClassException 
		- Giải pháp : dùng serialVersionUID để chỉ định một ID cố định  
		
			import java.io.*;
			class Employee implements Serializable {
				private static final long serialVersionUID = 1L; // Định danh cố định
			
				String name;
				int age;
			
				public Employee(String name, int age) {
					this.name = name;
					this.age = age;
				}
			}

	
	# ✅ Lợi ích của serialVersionUID 
		
		+> Khi deserialize object cũ, nếu serialVersionUID không thay đổi, Java sẽ bỏ qua sự khác biệt nhỏ (VD: thêm field mới)
		+> Nếu không có serialVersionUID, Java tự động tạo một ID dựa trên class, và khi class thay đổi, ID này cũng gây ra thay đổi, gây lỗi 
		
		📌 Lưu ý: 
			Nếu không khai báo serialVersionUID, Java sẽ tự động tạo, nhưng dễ gây lỗi khi sửa class 
			
			Dùng serialVersionUID giúp kiểm soát phiên bản của class 
			
		
//==========Lession 41 == Marker Interface ==========//
	
	# Khái niệm 
		Marker Interface là một interface không có phương thức nào, chỉ dùng để đánh dấu(marker) cho class để Java hiểu nó có một ý nghĩa đặc biệt  
		
		## Ví dụ về Marker Interface 
		
			Serializable					: 		Đánh dấu class có thể được serialize.
			Cloneable						: 		Đánh dấu class có thể sao chép (clone) bằng .clone().
			Remote							: 		Đánh dấu class có thể gọi từ xa (RMI - Remote Method Invocation).
			SingleThreadModel				: 		Đánh dấu Servlet chỉ có 1 thread chạy cùng lúc (deprecated).




	# Sử dụng 
		
		## Ví dụ về Cloneable 
			
					class Person implements Cloneable {
						String name;
					
						public Person(String name) {
							this.name = name;
						}
					
						@Override
						protected Object clone() throws CloneNotSupportedException {
							return super.clone(); // Cho phép clone
						}
					}
					
					public class MarkerInterfaceExample {
						public static void main(String[] args) throws CloneNotSupportedException {
							Person p1 = new Person("Alice");
							Person p2 = (Person) p1.clone(); // Cho phép clone vì có implements Cloneable
					
							System.out.println("Original: " + p1.name);
							System.out.println("Cloned: " + p2.name);
						}
					}



			📌 Nếu không implement Cloneable, gọi clone() sẽ báo lỗi CloneNotSupportedException.


	
✅ Tóm lại: Marker Interface không có method, chỉ đánh dấu để JVM xử lý đặc biệt.



//==========Lession 42 == Các loại interface trong Java ==========//

	# Khái niệm 
		Có 4 loại interface chính  
	

	# Normal Interface(Interface thông thường )
		- Có thể chứa public abstract methods ,  default method và static methods 
		- Class phải implement tất cả abstract methods 
		- Không thể có constructor 
		
		
		## Ví dụ 
				interface Animal {
				void makeSound(); // Abstract method
				}
				
				class Dog implements Animal {
					public void makeSound() {
						System.out.println("Woof! Woof!");
					}
				}
	

	# Funtional Interface(Interface hàm)
		
		- Chỉ có 1 phương thức trừu tượng 
		- Có thể dùng Lambda Expression 
		- Dùng annotation @FunctionalInterface để đảm bảo chỉ có 1 method 
		
		
		## Ví dụ 
			@FunctionalInterface
			interface Calculator {
				int add(int a, int b);
			}
			
			public class LambdaExample {
				public static void main(String[] args) {
					Calculator sum = (a, b) -> a + b;
					System.out.println(sum.add(10, 20)); // Output: 30
				}
			}
			
			
			
		🎯 Functional Interface – Khi nào nên và không nên dùng?
		✅ Khi nào nên dùng Functional Interface?
		
		Khi cần sử dụng Lambda Expression để viết code ngắn gọn và dễ đọc.
		Khi làm việc với Stream API (map(), filter(), reduce()).
		Khi cần callback trong lập trình bất đồng bộ.
		Khi sử dụng Java Functional Programming (Predicate, Consumer, Supplier, Function).
		❌ Khi nào KHÔNG nên dùng Functional Interface?
		
		Khi logic quá phức tạp, Lambda Expression sẽ làm code khó đọc.
		Khi cần mở rộng (extensibility), vì Functional Interface chỉ có 1 method abstract, khó mở rộng thêm.
		Khi code cần rõ ràng và dễ debug – vì stack trace của Lambda không trực quan.



		@FunctionalInterface
		interface MathOperation {
			int operate(int a, int b);
		}
		
		public class FunctionalInterfaceExample {
			public static void main(String[] args) {
				MathOperation add = (a, b) -> a + b;
				System.out.println("Sum: " + add.operate(10, 20)); // Output: 30
			}
		}
		
		
		💡 Nhưng nếu cần nhiều logic hơn, tốt hơn nên dùng class bình thường thay vì Functional Interface.


			
	
	
	# Marker Interface
		- Interface dùng để đánh dấu class có cách xử lý đặc biệt 



	# Nested Interface (Interface lồng nhau ) 
		Interface có thể được khai báo bên trong một class hoặc một interface khác. 
			
			class Outer {
			interface Inner {
					void show();
				}
			}
			
			class Test implements Outer.Inner {
				public void show() {
					System.out.println("Hello from Nested Interface");
				}
			}

		
		
		🎯 Nested Interface – Khi nào nên và không nên dùng?
		✅ Khi nào nên dùng Nested Interface?
		
		Khi muốn giới hạn phạm vi sử dụng của Interface (chỉ dùng trong class chứa nó).
		Khi mô tả quan hệ chặt chẽ giữa interface và class chứa nó.
		Khi xây dựng plugin architecture hoặc design pattern đặc biệt.
		🔥 Ví dụ hợp lý (Nested Interface giúp đảm bảo Button chỉ có OnClickListener):
	


			class Button {
			interface OnClickListener {
					void onClick();
				}
				
				private OnClickListener listener;
				
				public void setOnClickListener(OnClickListener listener) {
					this.listener = listener;
				}
			
				public void click() {
					if (listener != null) listener.onClick();
				}
			}
			
			public class NestedInterfaceExample {
				public static void main(String[] args) {
					Button button = new Button();
					button.setOnClickListener(() -> System.out.println("Button clicked!"));
					button.click();
				}
			}
		
		💡 Trường hợp này Nested Interface hợp lý vì OnClickListener không cần thiết bên ngoài Button.

		❌ Khi nào KHÔNG nên dùng Nested Interface?
		Khi interface có thể tái sử dụng ở nhiều nơi → Nên để thành interface bình thường.
		Khi Nested Interface không có liên kết chặt chẽ với class chứa nó.
		Khi Nested Interface khiến code khó đọc và khó bảo trì.


📌 Kết luận
🔹 Functional Interface phù hợp khi làm việc với Lambda, nhưng tránh dùng nếu logic quá phức tạp.
🔹 Nested Interface hữu ích khi cần giới hạn phạm vi sử dụng, nhưng nên tránh nếu không thực sự cần.
🔹 Dự án lớn thường tránh lạm dụng hai loại này vì làm giảm khả năng bảo trì và khó mở rộng về sau.


//==========Lession 43 == Remote Interface ==========//

</pre></body></html>