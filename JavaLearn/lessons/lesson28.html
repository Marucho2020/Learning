<html><head><title>Lession 28  Delayed Interface //</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px; white-space: pre-wrap; transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }#backTop, #backBottom {    font-size: 3em; padding: 20px 40px;    background: #bb86fc; color: white; text-decoration: none;    border-radius: 10px; display: inline-block; text-align: center; }#backTop:hover, #backBottom:hover { background: #9b67e2; }button { font-size: 2em; padding: 15px 30px;    background: #03dac6; color: #121212; border: none;    cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }button:hover { background: #02b8a3; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>üîô Quay l·∫°i danh s√°ch</a><br><h1>Lession 28  Delayed Interface //</h1><pre>
# Kh√°i ni·ªám  
	Delayed l√† m·ªôt interface trong Java thu·ªôc g√≥i java.util.concurrent. N√≥ ƒë∆∞·ª£c thi·∫øt k·∫ø cho c√°c ƒë·ªëi t∆∞·ª£ng c√≥ th·ªÉ ƒë∆∞·ª£c l·∫≠p l·ªãch ƒë·ªÉ x·ª≠ l√Ω sau m·ªôt kho·∫£ng th·ªùi gian nh·∫•t ƒë·ªãnh. C√°c ƒë·ªëi t∆∞·ª£ng tri·ªÉn khai Delayed th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c h√†ng ƒë·ª£i ∆∞u ti√™n c√≥ th·ªùi gian tr·ªÖ(DelayQueue) 
	
		public interface Delayed extends Comparable<Delayed> {
				long getDelay(TimeUnit unit);
		}
	
		- getDelay(TimeUnit unit): Tr·∫£ v·ªÅ kho·∫£ng th·ªùi gian tr·ªÖ c√≤n l·∫°i c·ªßa ƒë·ªëi t∆∞·ª£ng t√≠nh theo ƒë∆°n v·ªã th·ªùi gian (unit)
		
		- Comparable<Delayed> : Interface n√†y m·ªü r·ªông  nghƒ©a l√† c√°c ƒë·ªëi t∆∞·ª£ng Delayed c·∫ßn ƒë∆∞·ª£c x·∫Øp x·∫øp theo th·ªùi gian tr·ªÖ c·ªßa ch√∫ng  
		
# ·ª®ng d·ª•ng th·ª±c t·∫ø c·ªßa Delayed 
			- H√†ng ƒë·ª£i th·ª±c hi·ªán t√°c v·ª• sau m·ªôt kho·∫£ng th·ªùi gian(nh∆∞ h·ªá th·ªëng nh·∫Øn tin tr·ªÖ)
			- H√†ng ƒë·ª£i y√™u c·∫ßu retry sau khi th·∫•t b·∫°i 
			- C∆° ch·∫ø caching v·ªõi th·ªùi gian h·∫øt h·∫°n 
			- Ki·ªÉm so√°t t·ªëc ƒë·ªô th·ª±c thi t√°c v·ª•(Rate Limiting)
			
# V√≠ d·ª• c∆° b·∫£n v·ªÅ Delayed 
	Gi·∫£ s·ª≠ b·∫°n ƒëang l·∫≠p tr√¨nh m·ªôt h·ªá th·ªëng nh·∫Øn tin, n∆°i m·ªôt tin nh·∫Øn s·∫Ω ch·ªâ ƒë∆∞·ª£c x·ª≠ l√Ω sau m·ªôt kho·∫£ng th·ªùi gian nh·∫•t ƒë·ªãnh 
		import java.util.concurrent.TimeUnit;
		import java.util.concurrent.Delayed;
		
		class DelayedMessage implements Delayed {
			private String message;
			private long startTime;
		
			public DelayedMessage(String message, long delayInMillis) {
				this.message = message;
				this.startTime = System.currentTimeMillis() + delayInMillis;
			}
		
			@Override
			public long getDelay(TimeUnit unit) {
				long diff = startTime - System.currentTimeMillis();
				return unit.convert(diff, TimeUnit.MILLISECONDS);
			}
		
			@Override
			public int compareTo(Delayed other) {
				return Long.compare(this.getDelay(TimeUnit.MILLISECONDS), other.getDelay(TimeUnit.MILLISECONDS));
			}
		
			public String getMessage() {
				return message;
			}
		}


		import java.util.concurrent.DelayQueue;
		
		public class DelayedQueueExample {
			public static void main(String[] args) throws InterruptedException {
				DelayQueue<DelayedMessage> queue = new DelayQueue<>();
		
				queue.put(new DelayedMessage("Tin nh·∫Øn 1 sau 3 gi√¢y", 3000));
				queue.put(new DelayedMessage("Tin nh·∫Øn 2 sau 5 gi√¢y", 5000));
				queue.put(new DelayedMessage("Tin nh·∫Øn 3 sau 1 gi√¢y", 1000));
		
				while (!queue.isEmpty()) {
					DelayedMessage msg = queue.take(); // take() s·∫Ω ch·ªù ƒë·∫øn khi ph·∫ßn t·ª≠ c√≥ th·ªÉ l·∫•y ra
					System.out.println("ƒê√£ nh·∫≠n ƒë∆∞·ª£c: " + msg.getMessage());
				}
			}
		}

		
	## ·ª®ng d·ª•ng n√¢ng cao : Caching v·ªõi th·ªùi gian h·∫øt h·∫°n  
		import java.util.concurrent.DelayQueue;
		import java.util.concurrent.TimeUnit;
		
		class CacheItem implements Delayed {
			private String key;
			private long expireTime;
		
			public CacheItem(String key, long ttl) {
				this.key = key;
				this.expireTime = System.currentTimeMillis() + ttl;
			}
		
			@Override
			public long getDelay(TimeUnit unit) {
				long remainingTime = expireTime - System.currentTimeMillis();
				return unit.convert(remainingTime, TimeUnit.MILLISECONDS);
			}
		
			@Override
			public int compareTo(Delayed other) {
				return Long.compare(this.getDelay(TimeUnit.MILLISECONDS), other.getDelay(TimeUnit.MILLISECONDS));
			}
		
			public String getKey() {
				return key;
			}
		}
		
		public class ExpiringCache {
			private static final DelayQueue<CacheItem> cacheQueue = new DelayQueue<>();
		
			public static void main(String[] args) throws InterruptedException {
				cacheQueue.put(new CacheItem("session_123", 4000));
				cacheQueue.put(new CacheItem("session_456", 2000));
		
				while (!cacheQueue.isEmpty()) {
					CacheItem expiredItem = cacheQueue.take();
					System.out.println("X√≥a kh·ªèi cache: " + expiredItem.getKey());
				}
			}
		}
		
		
		CacheItem l√† m·ªôt ƒë·ªëi t∆∞·ª£ng c√≥ th·ªùi gian t·ªìn t·∫°i (TTL - Time To Live).
		Sau khi th·ªùi gian TTL h·∫øt h·∫°n, m·ª•c cache s·∫Ω t·ª± ƒë·ªông b·ªã lo·∫°i b·ªè.
		DelayQueue ƒë·∫£m b·∫£o r·∫±ng ch·ªâ nh·ªØng m·ª•c h·∫øt h·∫°n m·ªõi b·ªã x√≥a.

# Nh·ªØng ƒëi·ªÉm c·∫ßn l∆∞u √Ω  

	- Delayed l√† interface c√≥ m·ªôt ph∆∞∆°ng th·ª©c quan tr·ªçng getDelay(timeUnit unit)
	- C√°c l·ªõp tri·ªÉn khai Delayed ph·∫£i x√°c ƒë·ªãnh c√°ch t√≠nh th·ªùi gian tr·ªÖ v√† c√°ch so s√°nh th·ª© t·ª± ∆∞u ti√™n 
	- DelayQueue l√† m·ªôt h√†ng ƒë·ª£i ch·ªâ l·∫•y ƒë∆∞·ª£c ph·∫ßn t·ª≠ khi ƒë√£ h·∫øt th·ªùi gian tr·ªÖ  
	
	- ·ª®ng d·ª•ng quan tr·ªçng c·ªßa Delayed : 
		- L·∫≠p l·ªãch th·ª±c thi nhi·ªám v·ª• 
		- Cache v·ªõi th·ªùi gian h·∫øt h·∫°n  
		- H√†ng ƒë·ª£i retry(th·ª≠ l·∫°i sau khi th·∫•t b·∫°i )
	- S·∫Øp x·∫øp trong DelayQueue d·ª±a tr√™n th·ªùi gian tr·ªÖ c√≤n l·∫°i 
	
		DelayQueue ho·∫°t ƒë·ªông nh∆∞ m·ªôt PriorityQueue, s·ª≠ d·ª•ng compareTo() ƒë·ªÉ s·∫Øp x·∫øp.
		getDelay() ph·∫£i t√≠nh to√°n ch√≠nh x√°c th·ªùi gian tr·ªÖ c√≤n l·∫°i.
		take() s·∫Ω ch·ªù ƒë·∫øn khi ph·∫ßn t·ª≠ c√≥ th·ªÉ l·∫•y ƒë∆∞·ª£c.
	

</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>üîô Quay l·∫°i danh s√°ch</a><br><button onclick='toggleTheme()'>üåô Chuy·ªÉn giao di·ªán</button></div><script>function toggleTheme() {let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';document.body.className = mode; localStorage.setItem('theme', mode);syncTheme();}function applyTheme() {let savedTheme = localStorage.getItem('theme') || 'dark-mode';document.body.className = savedTheme;syncTheme();}function syncTheme() {let preElement = document.querySelector('pre');if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {let contentHeight = document.body.scrollHeight;let windowHeight = window.innerHeight;if (contentHeight > windowHeight * 1.2) {document.getElementById('backBottom').style.display = 'block';} else {document.getElementById('backBottom').style.display = 'none';}}</script></body></html>