<html><head><title>Lession 20  ArrayDeque //</title><style>body { font-family: Arial, sans-serif; transition: background 0.3s, color 0.3s; }.dark-mode { background-color: #121212; color: #e0e0e0; }.light-mode { background-color: #ffffff; color: #333333; }h1 { text-align: center; color: #73d9f5; }pre { padding: 15px; border-radius: 5px; white-space: pre-wrap; transition: background 0.3s, color 0.3s; }.dark-mode pre { background: #1e1e1e; color: #e0e0e0; }.light-mode pre { background: #f5f5f5; color: #333333; }button { background: #03dac6; color: #121212; border: none; padding: 10px 20px; font-size: 16px; cursor: pointer; border-radius: 5px; display: block; margin: 10px auto; }.dark-mode a { color: #03dac6; } .light-mode a { color: #007bff; }</style></head><body onload='applyTheme(); checkPageHeight()'><div class='container'><a id='backTop' href='../java-learning-list.html'>🔙 Quay lại danh sách</a><br><h1>Lession 20  ArrayDeque //</h1><pre>	#1. Định nghĩa :
		ArrayDeque(Double Ended Queue) là một cấu trúc dữu liệu trong Java được cung cấp bởi java.util package. Nó là một deque (hàng đợi 2 đầu) được triển khai dựa trên một mảng động 
		
	Nó có thể được sử dụng 2 đầu nhưng 
		+ Hàng đợi (Queue) : FIFO : Thêm vào cuối và xóa từ đầu  
		+ Ngăn xếp(Stack) : LIFO  : Thêm vào đầu và xóa từ cuối 
		
	ArrayDeque được ưu tiên hơn LinkedList khi làm việc với deque hoặc stack vì hiệu suất tốt hơn(không có các overhead từ các nút liên kết) 



	# 2. Tính năng nổi bật 
	- Không giới hạn kích thước ban đầu: Kích thước của ArrayDeque tự động tăng khi cần. 
	- Hiệu suât cao : hoạt động nhanh hơn LinkedList cho các thao tác đầu và cuối(enqueue, dequeue , pop)
	- Không hỗ trợ null : Không cho phép lưu trữ giá trị null để tránh lỗi không xác định khi sử dụng các phương thức như peek() , poll 
	
	
	#3 Khởi tạo  
		// Khởi tạo với kích thước tự động 
		ArrayDeque<Integer> deque = new ArrrayDeque<>(); 
		
		// Khởi tạo với kích thước ban đầu: 
		ArrayDeque<Integer> deque = new ArrayDeque<>(50);
		
		
	# 4. Các phương thức quan trọng  
		## Thao tác thêm phần tử  
			.addFirst(E e)        : Thêm vào đầu 
			.addLast(E e)         : Thêm vào cuối 
			.offerFirst(E e)      : Thêm vào đầu, trả về false nếu k thể thêm 
			.offerLast(E e)       : Thêm vào cuối, trả về false nếu k thể thêm 
		
		
		## Thao tác lấy/xóa phần tử 
			.removeFirst() : Xóa và trả về phần tử ở đầu deque(exception nếu deque rỗng )
			.removeLast() : Xóa và trả về phần tử ở cuối deque(exception nếu deque rỗng )
			.pollFirst()  : Xóa và trả về phần tử ở đầu deque(trả về null nếu rỗng )
			.pollLast() : Xóa và trả về phần tử ở cuối deque(trả về null nếu rỗng )
			
		## Thao tác xem phần tử 
			.getFirst() : Trả về phần tử ở đầu deque(exception nếu deque rỗng)
			.getLast()  : Trả về phần tử ở cuối deque(exception nếu deque rỗng )
			.peekFirst(): Trả về phần tử ở đầu deque(trả về null nếu rỗng)
			.peekLast() : Trả về phần tử ở cuối deque(trả về null nếu rỗng )
		
		
		## Thao tác như Stack 
			push(E e) 	: Thêm phần tử vào đầu(giống addFirst)
			pop() 		: Xóa và trả về phần tử ở đầu(hoạt động như removeFirst )
			
			
		
	# 5 Ưu điểm và nhược điểm 
		## Ưu điểm 
			Hiệu suất cao hơn so với LinkedList khi làm việc với các thao tác đầu và cuối 
			Đa năng, có thể hoạt động như một hàng đợi hoặc ngăn xếp 
			Không cần quản lý các nút liên kết như trong LinkedList 
			
		## Nhược điểm 
			Không cho phép giá trị null 
			Không phải là thread-safe(Phải sử dụng Collections.synchronizedDeque()) để đồng bộ 
			
			
	
		
		
	# 6 Ví dụ 
		##  Sử dụng ArrayDeque như một Queue(hàng đợi )
			        ArrayDeque<String> deque = new ArrayDeque<>();
        
					// Thêm phần tử
					deque.addLast("A");
					deque.addLast("B");
					deque.addLast("C");
			
					// Xem phần tử
					System.out.println(deque.peekFirst()); // A
					System.out.println(deque.peekLast());  // C
			
					// Xóa phần tử
					deque.removeFirst(); // Xóa A
					System.out.println(deque); // [B, C]
		
		// Sử dụng ArrayDeque như môt Stack(ngăn xếp)
		        ArrayDeque<Integer> stack = new ArrayDeque<>();

				// Thêm phần tử vào ngăn xếp
				stack.push(10);
				stack.push(20);
				stack.push(30);
		
				// Lấy phần tử ra khỏi ngăn xếp
				System.out.println(stack.pop()); // 30
				System.out.println(stack.pop()); // 20
				System.out.println(stack); // [10]
		
		
		
	# 7  So sánh với các cấu trúc dữ liệu khác  
	Đặc điểm				ArrayDeque					LinkedList								Stack (deprecated)
	Triển khai				Dựa trên mảng động			Dựa trên danh sách liên kết				Dựa trên Vector
	Hiệu suất				Nhanh hơn LinkedList		Chậm hơn (do quản lý nút liên kết)		Chậm hơn (do đồng bộ hóa)
	Lưu giá trị null		Không						Có thể									Có thể
	Đa năng					Có (Deque và Stack)			Có (Deque và Stack)						Chỉ Stack
		
		
		
		
		
	# 8 Lưu ý :
		
		- Hiểu cách ArrayDeque hoạt động như một hàng đợi hoặc ngăn xếp 
		- Phân biệt ArrayDeque với LinkedList và Stack 
		- Biết các phương thức cơ bản như addFirst, pollLast, push pop 
		
		- Tập trung vào các tính chất hiệu suất và cách triển khai thực tế 
		- Hiểu rõ ngoại lệ tiềm ẩn( NoSuchElementException khi gọi removeFirs() trên deque rỗng )
		- Sử dụng ArrayDeque trong các tình huống phức tạp như hàng đợi ưu tiên hoặc DFS/BFS trong thuật toán 
			
		
</pre><a id='backBottom' href='../java-learning-list.html' style='display:none;'>🔙 Quay lại danh sách</a><br><button onclick='toggleTheme()'>🌙 Chuyển giao diện</button></div><script>function toggleTheme() {let mode = document.body.classList.contains('dark-mode') ? 'light-mode' : 'dark-mode';document.body.className = mode; localStorage.setItem('theme', mode);syncTheme();}function applyTheme() {let savedTheme = localStorage.getItem('theme') || 'dark-mode';document.body.className = savedTheme;syncTheme();}function syncTheme() {let preElement = document.querySelector('pre');if (document.body.classList.contains('dark-mode')) { preElement.style.background = '#1e1e1e'; preElement.style.color = '#e0e0e0'; }else { preElement.style.background = '#f5f5f5'; preElement.style.color = '#333333'; }}function checkPageHeight() {let contentHeight = document.body.scrollHeight;let windowHeight = window.innerHeight;if (contentHeight > windowHeight * 1.2) {document.getElementById('backBottom').style.display = 'block';} else {document.getElementById('backBottom').style.display = 'none';}}</script></body></html>